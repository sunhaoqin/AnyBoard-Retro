diff --git a/components/driver/include/driver/gpio.h b/components/driver/include/driver/gpio.h
index c2231a625..ffa88a45c 100644
--- a/components/driver/include/driver/gpio.h
+++ b/components/driver/include/driver/gpio.h
@@ -128,6 +128,7 @@ extern "C" {
 #define GPIO_IS_VALID_OUTPUT_GPIO(gpio_num)      ((GPIO_IS_VALID_GPIO(gpio_num)) && (gpio_num < 34))         /*!< Check whether it can be a valid GPIO number of output mode */
 
 typedef enum {
+    GPIO_NUM_NC = -1,    /*!< Use to signal not connected to S/W */
     GPIO_NUM_0 = 0,     /*!< GPIO0, input and output */
     GPIO_NUM_1 = 1,     /*!< GPIO1, input and output */
     GPIO_NUM_2 = 2,     /*!< GPIO2, input and output
diff --git a/components/driver/include/driver/sdmmc_defs.h b/components/driver/include/driver/sdmmc_defs.h
index 6ea567b8f..53306e9c6 100644
--- a/components/driver/include/driver/sdmmc_defs.h
+++ b/components/driver/include/driver/sdmmc_defs.h
@@ -117,6 +117,13 @@
 #define SD_SPI_R3(resp)                 ((resp)[0])
 #define SD_SPI_R7(resp)                 ((resp)[0])
 
+/* SPI mode data response decoding */
+#define SD_SPI_DATA_RSP_VALID(resp_byte)        (((resp_byte)&0x11)==0x1)
+#define SD_SPI_DATA_RSP(resp_byte)              (((resp_byte)>>1)&0x7)
+#define  SD_SPI_DATA_ACCEPTED                   0x2
+#define  SD_SPI_DATA_CRC_ERROR                  0x5
+#define  SD_SPI_DATA_WR_ERROR                   0x6
+
 /* RCA argument and response */
 #define MMC_ARG_RCA(rca)                ((rca) << 16)
 #define SD_R6_RCA(resp)                 (SD_R6((resp)) >> 16)
diff --git a/components/driver/include/driver/sdmmc_types.h b/components/driver/include/driver/sdmmc_types.h
index 369a9210f..253108302 100644
--- a/components/driver/include/driver/sdmmc_types.h
+++ b/components/driver/include/driver/sdmmc_types.h
@@ -130,6 +130,7 @@ typedef struct {
 #define SDMMC_HOST_FLAG_8BIT    BIT(2)      /*!< host supports 8-line MMC protocol */
 #define SDMMC_HOST_FLAG_SPI     BIT(3)      /*!< host supports SPI protocol */
 #define SDMMC_HOST_FLAG_DDR     BIT(4)      /*!< host supports DDR mode for SD/MMC */
+#define SDMMC_HOST_FLAG_DEINIT_ARG BIT(5)      /*!< host `deinit` function called with the slot argument */
     int slot;                   /*!< slot number, to be passed to host functions */
     int max_freq_khz;           /*!< max frequency supported by the host */
 #define SDMMC_FREQ_DEFAULT      20000       /*!< SD/MMC Default speed (limited by clock divider) */
@@ -144,7 +145,10 @@ typedef struct {
     esp_err_t (*set_bus_ddr_mode)(int slot, bool ddr_enable); /*!< host function to set DDR mode */
     esp_err_t (*set_card_clk)(int slot, uint32_t freq_khz); /*!< host function to set card clock frequency */
     esp_err_t (*do_transaction)(int slot, sdmmc_command_t* cmdinfo);    /*!< host function to do a transaction */
-    esp_err_t (*deinit)(void);  /*!< host function to deinitialize the driver */
+    union {
+        esp_err_t (*deinit)(void);  /*!< host function to deinitialize the driver */
+        esp_err_t (*deinit_p)(int slot);  /*!< host function to deinitialize the driver, called with the `slot` */
+    };
     esp_err_t (*io_int_enable)(int slot); /*!< Host function to enable SDIO interrupt line */
     esp_err_t (*io_int_wait)(int slot, TickType_t timeout_ticks); /*!< Host function to wait for SDIO interrupt line to be active */
     int command_timeout_ms;     /*!< timeout, in milliseconds, of a single command. Set to 0 to use the default value. */
@@ -156,7 +160,11 @@ typedef struct {
 typedef struct {
     sdmmc_host_t host;          /*!< Host with which the card is associated */
     uint32_t ocr;               /*!< OCR (Operation Conditions Register) value */
-    sdmmc_cid_t cid;            /*!< decoded CID (Card IDentification) register value */
+    union {
+        sdmmc_cid_t cid;            /*!< decoded CID (Card IDentification) register value */
+        sdmmc_response_t raw_cid;   /*!< raw CID of MMC card to be decoded
+                                         after the CSD is fetched in the data transfer mode*/
+    };
     sdmmc_csd_t csd;            /*!< decoded CSD (Card-Specific Data) register value */
     sdmmc_scr_t scr;            /*!< decoded SCR (SD card Configuration Register) value */
     sdmmc_ext_csd_t ext_csd;    /*!< decoded EXT_CSD (Extended Card Specific Data) register value */
diff --git a/components/driver/include/driver/sdspi_host.h b/components/driver/include/driver/sdspi_host.h
index 1b3b67017..064c68ccc 100644
--- a/components/driver/include/driver/sdspi_host.h
+++ b/components/driver/include/driver/sdspi_host.h
@@ -20,21 +20,23 @@
 #include "sdmmc_types.h"
 #include "driver/gpio.h"
 #include "driver/spi_master.h"
-#include "driver/sdmmc_host.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+/// Handle representing an SD SPI device
+typedef int sdspi_dev_handle_t;
+
 /**
  * @brief Default sdmmc_host_t structure initializer for SD over SPI driver
  *
  * Uses SPI mode and max frequency set to 20MHz
  *
- * 'slot' can be set to one of HSPI_HOST, VSPI_HOST.
+ * 'slot' should be set to an sdspi device initialized by `sdspi_host_init_device()`.
  */
 #define SDSPI_HOST_DEFAULT() {\
-    .flags = SDMMC_HOST_FLAG_SPI, \
+    .flags = SDMMC_HOST_FLAG_SPI | SDMMC_HOST_FLAG_DEINIT_ARG, \
     .slot = HSPI_HOST, \
     .max_freq_khz = SDMMC_FREQ_DEFAULT, \
     .io_voltage = 3.3f, \
@@ -44,39 +46,36 @@ extern "C" {
     .set_bus_ddr_mode = NULL, \
     .set_card_clk = &sdspi_host_set_card_clk, \
     .do_transaction = &sdspi_host_do_transaction, \
-    .deinit = &sdspi_host_deinit, \
-    .io_int_enable = NULL, \
-    .io_int_wait = NULL, \
+    .deinit_p = &sdspi_host_remove_device, \
+    .io_int_enable = &sdspi_host_io_int_enable, \
+    .io_int_wait = &sdspi_host_io_int_wait, \
     .command_timeout_ms = 0, \
 }
 
 /**
- * Extra configuration for SPI host
+ * Extra configuration for SD SPI device.
  */
 typedef struct {
-    gpio_num_t gpio_miso;   ///< GPIO number of MISO signal
-    gpio_num_t gpio_mosi;   ///< GPIO number of MOSI signal
-    gpio_num_t gpio_sck;    ///< GPIO number of SCK signal
+    spi_host_device_t host_id; ///< SPI host to use, SPIx_HOST (see spi_types.h).
     gpio_num_t gpio_cs;     ///< GPIO number of CS signal
     gpio_num_t gpio_cd;     ///< GPIO number of card detect signal
     gpio_num_t gpio_wp;     ///< GPIO number of write protect signal
-    int dma_channel;        ///< DMA channel to be used by SPI driver (1 or 2)
-} sdspi_slot_config_t;
+    gpio_num_t gpio_int;    ///< GPIO number of interrupt line (input) for SDIO card.
+} sdspi_device_config_t;
 
-#define SDSPI_SLOT_NO_CD    ((gpio_num_t) -1)   ///< indicates that card detect line is not used
-#define SDSPI_SLOT_NO_WP    ((gpio_num_t) -1)   ///< indicates that write protect line is not used
+#define SDSPI_SLOT_NO_CD    GPIO_NUM_NC ///< indicates that card detect line is not used
+#define SDSPI_SLOT_NO_WP    GPIO_NUM_NC ///< indicates that write protect line is not used
+#define SDSPI_SLOT_NO_INT   GPIO_NUM_NC ///< indicates that interrupt line is not used
 
 /**
- * Macro defining default configuration of SPI host
+ * Macro defining default configuration of SD SPI device.
  */
-#define SDSPI_SLOT_CONFIG_DEFAULT() {\
-    .gpio_miso = GPIO_NUM_2, \
-    .gpio_mosi = GPIO_NUM_15, \
-    .gpio_sck  = GPIO_NUM_14, \
+#define SDSPI_DEVICE_CONFIG_DEFAULT() {\
+    .host_id   = HSPI_HOST, \
     .gpio_cs   = GPIO_NUM_13, \
     .gpio_cd   = SDSPI_SLOT_NO_CD, \
     .gpio_wp   = SDSPI_SLOT_NO_WP, \
-    .dma_channel = 1 \
+    .gpio_int  = GPIO_NUM_NC, \
 }
 
 /**
@@ -88,23 +87,35 @@ typedef struct {
  *      - ESP_OK on success
  *      - other error codes may be returned in future versions
  */
-esp_err_t sdspi_host_init();
+esp_err_t sdspi_host_init(void);
 
 /**
-* @brief Initialize SD SPI driver for the specific SPI controller
+* @brief Attach and initialize an SD SPI device on the specific SPI bus
 *
 * @note This function is not thread safe
 *
-* @param slot         SPI controller to use (HSPI_HOST or VSPI_HOST)
-* @param slot_config  pointer to slot configuration structure
+* @note Initialize the SPI bus by `spi_bus_initialize()` before calling this function.
 *
+* @note The SDIO over sdspi needs an extra interrupt line. Call ``gpio_install_isr_service()`` before this function.
+*
+* @param dev_config pointer to device configuration structure
+* @param out_handle Output of the handle to the sdspi device.
+
 * @return
 *      - ESP_OK on success
-*      - ESP_ERR_INVALID_ARG if sdspi_init_slot has invalid arguments
+*      - ESP_ERR_INVALID_ARG if sdspi_host_init_device has invalid arguments
 *      - ESP_ERR_NO_MEM if memory can not be allocated
 *      - other errors from the underlying spi_master and gpio drivers
 */
-esp_err_t sdspi_host_init_slot(int slot, const sdspi_slot_config_t* slot_config);
+esp_err_t sdspi_host_init_device(const sdspi_device_config_t* dev_config, sdspi_dev_handle_t* out_handle);
+
+/**
+ * @brief Remove an SD SPI device
+ *
+ * @param handle Handle of the SD SPI device
+ * @return Always ESP_OK
+ */
+esp_err_t sdspi_host_remove_device(sdspi_dev_handle_t handle);
 
 /**
  * @brief Send command to the card and get response
@@ -117,7 +128,7 @@ esp_err_t sdspi_host_init_slot(int slot, const sdspi_slot_config_t* slot_config)
  *       can call sdspi_host_do_transaction as long as other sdspi_host_*
  *       functions are not called.
  *
- * @param slot      SPI controller (HSPI_HOST or VSPI_HOST)
+ * @param handle    Handle of the sdspi device
  * @param cmdinfo   pointer to structure describing command and data to transfer
  * @return
  *      - ESP_OK on success
@@ -125,7 +136,7 @@ esp_err_t sdspi_host_init_slot(int slot, const sdspi_slot_config_t* slot_config)
  *      - ESP_ERR_INVALID_CRC if response or data transfer CRC check has failed
  *      - ESP_ERR_INVALID_RESPONSE if the card has sent an invalid response
  */
-esp_err_t sdspi_host_do_transaction(int slot, sdmmc_command_t *cmdinfo);
+esp_err_t sdspi_host_do_transaction(sdspi_dev_handle_t handle, sdmmc_command_t *cmdinfo);
 
 /**
  * @brief Set card clock frequency
@@ -136,14 +147,13 @@ esp_err_t sdspi_host_do_transaction(int slot, sdmmc_command_t *cmdinfo);
  *
  * @note This function is not thread safe
  *
- * @param slot      SPI controller (HSPI_HOST or VSPI_HOST)
+ * @param host    Handle of the sdspi device
  * @param freq_khz  card clock frequency, in kHz
  * @return
  *      - ESP_OK on success
  *      - other error codes may be returned in the future
  */
-esp_err_t sdspi_host_set_card_clk(int slot, uint32_t freq_khz);
-
+esp_err_t sdspi_host_set_card_clk(sdspi_dev_handle_t host, uint32_t freq_khz);
 
 /**
  * @brief Release resources allocated using sdspi_host_init
@@ -154,7 +164,82 @@ esp_err_t sdspi_host_set_card_clk(int slot, uint32_t freq_khz);
  *      - ESP_OK on success
  *      - ESP_ERR_INVALID_STATE if sdspi_host_init function has not been called
  */
-esp_err_t sdspi_host_deinit();
+esp_err_t sdspi_host_deinit(void);
+
+/**
+ * @brief Enable SDIO interrupt.
+ *
+ * @param handle    Handle of the sdspi device
+ *
+ * @return
+ *      - ESP_OK on success
+ */
+esp_err_t sdspi_host_io_int_enable(sdspi_dev_handle_t handle);
+
+/**
+ * @brief Wait for SDIO interrupt until timeout.
+ *
+ * @param handle    Handle of the sdspi device
+ * @param timeout_ticks Ticks to wait before timeout.
+ *
+ * @return
+ *      - ESP_OK on success
+ */
+esp_err_t sdspi_host_io_int_wait(sdspi_dev_handle_t handle, TickType_t timeout_ticks);
+
+/*******************************************************************************
+ * Deprecated APIs
+ ******************************************************************************/
+
+/**
+ * Extra configuration for SPI host.
+ *
+ * @deprecated Use `sdspi_device_config_t` and corresponding `sdspi_host_init_device()` instead.
+ */
+typedef struct {
+    gpio_num_t gpio_cs;     ///< GPIO number of CS signal
+    gpio_num_t gpio_cd;     ///< GPIO number of card detect signal
+    gpio_num_t gpio_wp;     ///< GPIO number of write protect signal
+    gpio_num_t gpio_int;    ///< GPIO number of interrupt line (input) for SDIO card.
+    gpio_num_t gpio_miso;   ///< GPIO number of MISO signal.
+    gpio_num_t gpio_mosi;   ///< GPIO number of MOSI signal.
+    gpio_num_t gpio_sck;    ///< GPIO number of SCK signal.
+    int        dma_channel;        ///< DMA channel to be used by SPI driver (1 or 2).
+} sdspi_slot_config_t;
+
+/**
+ * Macro defining default configuration of SPI host
+ */
+#define SDSPI_SLOT_CONFIG_DEFAULT() {\
+    .gpio_cs   = GPIO_NUM_13, \
+    .gpio_cd   = SDSPI_SLOT_NO_CD, \
+    .gpio_wp   = SDSPI_SLOT_NO_WP, \
+    .gpio_int  = GPIO_NUM_NC, \
+    .gpio_miso = GPIO_NUM_2, \
+    .gpio_mosi = GPIO_NUM_15, \
+    .gpio_sck  = GPIO_NUM_14, \
+    .dma_channel = 1, \
+}
+
+/**
+* @brief Initialize SD SPI driver for the specific SPI controller
+*
+* @note This function is not thread safe
+*
+* @note The SDIO over sdspi needs an extra interrupt line. Call ``gpio_install_isr_service()`` before this function.
+*
+* @param slot         SPI controller to use (HSPI_HOST or VSPI_HOST)
+* @param slot_config  pointer to slot configuration structure
+
+* @deprecated Use `sdspi_host_init_device` instead.
+*
+* @return
+*      - ESP_OK on success
+*      - ESP_ERR_INVALID_ARG if sdspi_init_slot has invalid arguments
+*      - ESP_ERR_NO_MEM if memory can not be allocated
+*      - other errors from the underlying spi_master and gpio drivers
+*/
+esp_err_t sdspi_host_init_slot(int slot, const sdspi_slot_config_t* slot_config);
 
 #ifdef __cplusplus
 }
diff --git a/components/driver/sdspi_host.c b/components/driver/sdspi_host.c
index e823ee7fa..c3450b057 100644
--- a/components/driver/sdspi_host.c
+++ b/components/driver/sdspi_host.c
@@ -26,6 +26,8 @@
 #include "sdspi_private.h"
 #include "sdspi_crc.h"
 #include "esp_timer.h"
+#include "freertos/FreeRTOS.h"
+#include "freertos/semphr.h"
 
 
 /// Max number of transactions in flight (used in start_command_write_blocks)
@@ -37,13 +39,21 @@
 /// Maximum number of dummy bytes between the request and response (minimum is 1)
 #define SDSPI_RESPONSE_MAX_DELAY  8
 
-
-/// Structure containing run time configuration for a single SD slot
+/**
+ * @brief Structure containing run time configuration for a single SD slot
+ *
+ * The slot info is referenced to by an sdspi_dev_handle_t (alias int). The handle may be the raw
+ * pointer to the slot info itself (force converted to, new API in IDFv4.2), or the index of the
+ * s_slot array (deprecated API). Returning the raw pointer to the caller instead of storing it
+ * locally can save some static memory.
+ */
 typedef struct {
-    spi_device_handle_t handle; //!< SPI device handle, used for transactions
+    spi_host_device_t   host_id; //!< SPI host id.
+    spi_device_handle_t spi_handle; //!< SPI device handle, used for transactions
     uint8_t gpio_cs;            //!< CS GPIO
     uint8_t gpio_cd;            //!< Card detect GPIO, or GPIO_UNUSED
     uint8_t gpio_wp;            //!< Write protect GPIO, or GPIO_UNUSED
+    uint8_t gpio_int;            //!< Write protect GPIO, or GPIO_UNUSED
     /// Set to 1 if the higher layer has asked the card to enable CRC checks
     uint8_t data_crc_enabled : 1;
     /// Number of transactions in 'transactions' array which are in use
@@ -53,128 +63,148 @@ typedef struct {
     uint8_t* block_buf;
     /// array with SDSPI_TRANSACTION_COUNT transaction structures
     spi_transaction_t* transactions;
+    /// semaphore of gpio interrupt
+    SemaphoreHandle_t   semphr_int;
 } slot_info_t;
 
-static slot_info_t s_slots[3];
+// Reserved for old API to be back-compatible
+static slot_info_t *s_slots[SOC_SPI_PERIPH_NUM] = {};
 static const char *TAG = "sdspi_host";
 
 /// Functions to send out different kinds of commands
-static esp_err_t start_command_read_blocks(int slot, sdspi_hw_cmd_t *cmd,
-        uint8_t *data, uint32_t rx_length);
+static esp_err_t start_command_read_blocks(slot_info_t *slot, sdspi_hw_cmd_t *cmd,
+        uint8_t *data, uint32_t rx_length, bool need_stop_command);
 
-static esp_err_t start_command_write_blocks(int slot, sdspi_hw_cmd_t *cmd,
-        const uint8_t *data, uint32_t tx_length);
+static esp_err_t start_command_write_blocks(slot_info_t *slot, sdspi_hw_cmd_t *cmd,
+        const uint8_t *data, uint32_t tx_length, bool multi_block, bool stop_trans);
 
-static esp_err_t start_command_default(int slot, int flags, sdspi_hw_cmd_t *cmd);
+static esp_err_t start_command_default(slot_info_t *slot, int flags, sdspi_hw_cmd_t *cmd);
 
-static esp_err_t poll_cmd_response(int slot, sdspi_hw_cmd_t *cmd);
+static esp_err_t shift_cmd_response(sdspi_hw_cmd_t *cmd, int sent_bytes);
 
 /// A few helper functions
 
-/// Set CS high for given slot
-static void cs_high(int slot)
-{
-    gpio_set_level(s_slots[slot].gpio_cs, 1);
-}
-
-/// Set CS low for given slot
-static void cs_low(int slot)
+/// Map handle to pointer of slot information
+static slot_info_t* get_slot_info(sdspi_dev_handle_t handle)
 {
-    gpio_set_level(s_slots[slot].gpio_cs, 0);
+    if ((uint32_t) handle < SOC_SPI_PERIPH_NUM) {
+        return s_slots[handle];
+    } else {
+        return (slot_info_t *) handle;
+    }
 }
 
-/// Return true if WP pin is configured and is low
-static bool card_write_protected(int slot)
+/// Store slot information (if possible) and return corresponding handle
+static sdspi_dev_handle_t store_slot_info(slot_info_t *slot)
 {
-    if (s_slots[slot].gpio_wp == GPIO_UNUSED) {
-        return false;
+    /*
+     * To be back-compatible, the first device of each bus will always be stored locally, and
+     * referenced to by the handle `host_id`, otherwise the new API return the raw pointer to the
+     * slot info as the handle, to save some static memory.
+     */
+    if (s_slots[slot->host_id] == NULL) {
+        s_slots[slot->host_id] = slot;
+        return slot->host_id;
+    } else {
+        return (sdspi_dev_handle_t)slot;
     }
-    return gpio_get_level(s_slots[slot].gpio_wp) == 0;
 }
 
-/// Return true if CD pin is configured and is high
-static bool card_missing(int slot)
+/// Get the slot info for a specific handle, and remove the local reference (if exist).
+static slot_info_t* remove_slot_info(sdspi_dev_handle_t handle)
 {
-    if (s_slots[slot].gpio_cd == GPIO_UNUSED) {
-        return false;
+    if ((uint32_t) handle < SOC_SPI_PERIPH_NUM) {
+        slot_info_t* slot = s_slots[handle];
+        s_slots[handle] = NULL;
+        return slot;
+    } else {
+        return (slot_info_t *) handle;
     }
-    return gpio_get_level(s_slots[slot].gpio_cd) == 1;
 }
 
-/// Check if slot number is within bounds
-static bool is_valid_slot(int slot)
+/// Set CS high for given slot
+static void cs_high(slot_info_t *slot)
 {
-    return slot == VSPI_HOST || slot == HSPI_HOST;
+    gpio_set_level(slot->gpio_cs, 1);
 }
 
-static spi_device_handle_t spi_handle(int slot)
+/// Set CS low for given slot
+static void cs_low(slot_info_t *slot)
 {
-    return s_slots[slot].handle;
+    gpio_set_level(slot->gpio_cs, 0);
 }
 
-static bool is_slot_initialized(int slot)
+/// Return true if WP pin is configured and is low
+static bool card_write_protected(slot_info_t *slot)
 {
-    return spi_handle(slot) != NULL;
+    if (slot->gpio_wp == GPIO_UNUSED) {
+        return false;
+    }
+    return gpio_get_level(slot->gpio_wp) == 0;
 }
 
-static bool data_crc_enabled(int slot)
+/// Return true if CD pin is configured and is high
+static bool card_missing(slot_info_t *slot)
 {
-    return s_slots[slot].data_crc_enabled;
+    if (slot->gpio_cd == GPIO_UNUSED) {
+        return false;
+    }
+    return gpio_get_level(slot->gpio_cd) == 1;
 }
 
 /// Get pointer to a block of DMA memory, allocate if necessary.
 /// This is used if the application provided buffer is not in DMA capable memory.
-static esp_err_t get_block_buf(int slot, uint8_t** out_buf)
+static esp_err_t get_block_buf(slot_info_t *slot, uint8_t **out_buf)
 {
-    if (s_slots[slot].block_buf == NULL) {
-        s_slots[slot].block_buf = heap_caps_malloc(SDSPI_BLOCK_BUF_SIZE, MALLOC_CAP_DMA);
-        if (s_slots[slot].block_buf == NULL) {
+    if (slot->block_buf == NULL) {
+        slot->block_buf = heap_caps_malloc(SDSPI_BLOCK_BUF_SIZE, MALLOC_CAP_DMA);
+        if (slot->block_buf == NULL) {
             return ESP_ERR_NO_MEM;
         }
     }
-    *out_buf = s_slots[slot].block_buf;
+    *out_buf = slot->block_buf;
     return ESP_OK;
 }
 
-static spi_transaction_t* get_transaction(int slot)
+static spi_transaction_t* get_transaction(slot_info_t *slot)
 {
-    size_t used_transaction_count = s_slots[slot].used_transaction_count;
+    size_t used_transaction_count = slot->used_transaction_count;
     assert(used_transaction_count < SDSPI_TRANSACTION_COUNT);
-    spi_transaction_t* ret = &s_slots[slot].transactions[used_transaction_count];
-    ++s_slots[slot].used_transaction_count;
+    spi_transaction_t* ret = &slot->transactions[used_transaction_count];
+    ++slot->used_transaction_count;
     return ret;
 }
 
-static void release_transaction(int slot)
+static void release_transaction(slot_info_t *slot)
 {
-    --s_slots[slot].used_transaction_count;
+    --slot->used_transaction_count;
 }
 
-static void wait_for_transactions(int slot)
+static void wait_for_transactions(slot_info_t *slot)
 {
-    size_t used_transaction_count = s_slots[slot].used_transaction_count;
+    size_t used_transaction_count = slot->used_transaction_count;
     for (size_t i = 0; i < used_transaction_count; ++i) {
         spi_transaction_t* t_out;
-        spi_device_get_trans_result(spi_handle(slot), &t_out, portMAX_DELAY);
+        spi_device_get_trans_result(slot->spi_handle, &t_out, portMAX_DELAY);
         release_transaction(slot);
     }
 }
 
 /// Clock out one byte (CS has to be high) to make the card release MISO
 /// (clocking one bit would work as well, but that triggers a bug in SPI DMA)
-static void release_bus(int slot)
+static void release_bus(slot_info_t *slot)
 {
     spi_transaction_t t = {
         .flags = SPI_TRANS_USE_RXDATA | SPI_TRANS_USE_TXDATA,
         .length = 8,
         .tx_data = {0xff}
     };
-    spi_device_transmit(spi_handle(slot), &t);
+    spi_device_transmit(slot->spi_handle, &t);
     // don't care if this failed
 }
 
 /// Clock out 80 cycles (10 bytes) before GO_IDLE command
-static void go_idle_clockout(int slot)
+static void go_idle_clockout(slot_info_t *slot)
 {
     //actually we need 10, declare 12 to meet requirement of RXDMA
     uint8_t data[12];
@@ -184,7 +214,7 @@ static void go_idle_clockout(int slot)
         .tx_buffer = data,
         .rx_buffer = data,
     };
-    spi_device_transmit(spi_handle(slot), &t);
+    spi_device_transmit(slot->spi_handle, &t);
     // don't care if this failed
 }
 
@@ -197,115 +227,154 @@ static bool ptr_dma_compatible(const void* ptr)
 }
 
 /**
- * Initialize SPI device. Used to change clock speed.
- * @param slot  SPI host number
+ * (Re)Configure SPI device. Used to change clock speed.
+ * @param slot Pointer to the slot to be configured
  * @param clock_speed_hz  clock speed, Hz
  * @return ESP_OK on success
  */
-static esp_err_t init_spi_dev(int slot, int clock_speed_hz)
+static esp_err_t configure_spi_dev(slot_info_t *slot, int clock_speed_hz)
 {
-    if (spi_handle(slot)) {
+    if (slot->spi_handle) {
         // Reinitializing
-        spi_bus_remove_device(spi_handle(slot));
-        s_slots[slot].handle = NULL;
+        spi_bus_remove_device(slot->spi_handle);
+        slot->spi_handle = NULL;
     }
     spi_device_interface_config_t devcfg = {
         .clock_speed_hz = clock_speed_hz,
         .mode = 0,
         // For SD cards, CS must stay low during the whole read/write operation,
         // rather than a single SPI transaction.
-        .spics_io_num = -1,
+        .spics_io_num = GPIO_NUM_NC,
         .queue_size = SDSPI_TRANSACTION_COUNT,
     };
-    return spi_bus_add_device((spi_host_device_t) slot, &devcfg, &s_slots[slot].handle);
+    return spi_bus_add_device(slot->host_id, &devcfg, &slot->spi_handle);
+}
+
+esp_err_t sdspi_host_init(void)
+{
+    return ESP_OK;
+}
+
+static esp_err_t deinit_slot(slot_info_t *slot)
+{
+    esp_err_t err = ESP_OK;
+    if (slot->spi_handle) {
+        spi_bus_remove_device(slot->spi_handle);
+        slot->spi_handle = NULL;
+        free(slot->block_buf);
+        slot->block_buf = NULL;
+    }
+    free(slot->transactions);
+    slot->transactions = NULL;
+    uint64_t pin_bit_mask = 0;
+    if (slot->gpio_cs != GPIO_UNUSED) {
+        pin_bit_mask |= BIT64(slot->gpio_cs);
+    }
+    if (slot->gpio_cd != GPIO_UNUSED) {
+        pin_bit_mask |= BIT64(slot->gpio_cd);
+    }
+    if (slot->gpio_wp != GPIO_UNUSED) {
+        pin_bit_mask |= BIT64(slot->gpio_wp);
+    }
+    if (slot->gpio_int != GPIO_UNUSED) {
+        pin_bit_mask |= BIT64(slot->gpio_int);
+        gpio_intr_disable(slot->gpio_int);
+        gpio_isr_handler_remove(slot->gpio_int);
+    }
+    gpio_config_t config = {
+        .pin_bit_mask = pin_bit_mask,
+        .mode = GPIO_MODE_INPUT,
+        .intr_type = GPIO_PIN_INTR_DISABLE,
+    };
+    gpio_config(&config);
+
+    if (slot->semphr_int) {
+        vSemaphoreDelete(slot->semphr_int);
+        slot->semphr_int = NULL;
+    }
+    free(slot);
+    return err;
 }
 
-esp_err_t sdspi_host_init()
+esp_err_t sdspi_host_remove_device(sdspi_dev_handle_t handle)
 {
+    //Get the slot info and remove the reference in the static memory (if used)
+    slot_info_t* slot = remove_slot_info(handle);
+    if (slot == NULL) {
+        return ESP_ERR_INVALID_ARG;
+    }
+
+   deinit_slot(slot);
     return ESP_OK;
 }
 
-esp_err_t sdspi_host_deinit()
+//only the slots locally stored can be deinit in this function.
+esp_err_t sdspi_host_deinit(void)
 {
     for (size_t i = 0; i < sizeof(s_slots)/sizeof(s_slots[0]); ++i) {
-        if (s_slots[i].handle) {
-            spi_bus_remove_device(s_slots[i].handle);
-            free(s_slots[i].block_buf);
-            s_slots[i].block_buf = NULL;
-            free(s_slots[i].transactions);
-            s_slots[i].transactions = NULL;
-            spi_bus_free((spi_host_device_t) i);
-            s_slots[i].handle = NULL;
-        }
+        slot_info_t* slot = remove_slot_info(i);
+        //slot isn't used, skip
+        if (slot == NULL) continue;
+
+        deinit_slot(slot);
     }
     return ESP_OK;
 }
 
-esp_err_t sdspi_host_set_card_clk(int slot, uint32_t freq_khz)
+esp_err_t sdspi_host_set_card_clk(sdspi_dev_handle_t handle, uint32_t freq_khz)
 {
-    if (!is_valid_slot(slot)) {
+    slot_info_t *slot = get_slot_info(handle);
+    if (slot == NULL) {
         return ESP_ERR_INVALID_ARG;
     }
-    if (!is_slot_initialized(slot)) {
-        return ESP_ERR_INVALID_STATE;
-    }
     ESP_LOGD(TAG, "Setting card clock to %d kHz", freq_khz);
-    return init_spi_dev(slot, freq_khz * 1000);
+    return configure_spi_dev(slot, freq_khz * 1000);
 }
 
-esp_err_t sdspi_host_init_slot(int slot, const sdspi_slot_config_t* slot_config)
+static void gpio_intr(void* arg)
 {
-    ESP_LOGD(TAG, "%s: SPI%d miso=%d mosi=%d sck=%d cs=%d cd=%d wp=%d, dma_ch=%d",
-            __func__, slot + 1,
-            slot_config->gpio_miso, slot_config->gpio_mosi,
-            slot_config->gpio_sck, slot_config->gpio_cs,
-            slot_config->gpio_cd, slot_config->gpio_wp,
-            slot_config->dma_channel);
-
-    spi_host_device_t host = (spi_host_device_t) slot;
-    if (!is_valid_slot(slot)) {
-        return ESP_ERR_INVALID_ARG;
+    BaseType_t awoken = pdFALSE;
+    slot_info_t* slot = (slot_info_t*)arg;
+    xSemaphoreGiveFromISR(slot->semphr_int, &awoken);
+    gpio_intr_disable(slot->gpio_int);
+    if (awoken) {
+        portYIELD_FROM_ISR();
     }
+}
 
-    spi_bus_config_t buscfg = {
-        .miso_io_num = slot_config->gpio_miso,
-        .mosi_io_num = slot_config->gpio_mosi,
-        .sclk_io_num = slot_config->gpio_sck,
-        .quadwp_io_num = -1,
-        .quadhd_io_num = -1
-    };
+esp_err_t sdspi_host_init_device(const sdspi_device_config_t* slot_config, sdspi_dev_handle_t* out_handle)
+{
+    ESP_LOGD(TAG, "%s: SPI%d cs=%d cd=%d wp=%d",
+             __func__, slot_config->host_id + 1, slot_config->gpio_cs,
+             slot_config->gpio_cd, slot_config->gpio_wp);
 
-    // Initialize SPI bus
-    esp_err_t ret = spi_bus_initialize((spi_host_device_t)slot, &buscfg,
-            slot_config->dma_channel);
-    if (ret != ESP_OK) {
-        ESP_LOGD(TAG, "spi_bus_initialize failed with rc=0x%x", ret);
-        return ret;
+    slot_info_t* slot = (slot_info_t*)malloc(sizeof(slot_info_t));
+    if (slot == NULL) {
+        return ESP_ERR_NO_MEM;
     }
+    *slot = (slot_info_t) {
+        .host_id = slot_config->host_id,
+        .gpio_cs = slot_config->gpio_cs,
+    };
 
     // Attach the SD card to the SPI bus
-    ret = init_spi_dev(slot, SDMMC_FREQ_PROBING * 1000);
+    esp_err_t ret = configure_spi_dev(slot, SDMMC_FREQ_PROBING * 1000);
     if (ret != ESP_OK) {
         ESP_LOGD(TAG, "spi_bus_add_device failed with rc=0x%x", ret);
-        spi_bus_free(host);
-        return ret;
+        goto cleanup;
     }
 
     // Configure CS pin
-    s_slots[slot].gpio_cs = (uint8_t) slot_config->gpio_cs;
     gpio_config_t io_conf = {
         .intr_type = GPIO_PIN_INTR_DISABLE,
         .mode = GPIO_MODE_OUTPUT,
-        .pin_bit_mask = 1LL << slot_config->gpio_cs,
+        .pin_bit_mask = 1ULL << slot_config->gpio_cs,
     };
 
     ret = gpio_config(&io_conf);
     if (ret != ESP_OK) {
         ESP_LOGD(TAG, "gpio_config (CS) failed with rc=0x%x", ret);
-        spi_bus_remove_device(spi_handle(slot));
-        s_slots[slot].handle = NULL;
-        spi_bus_free(host);
-        return ret;
+        goto cleanup;
     }
     cs_high(slot);
 
@@ -317,51 +386,89 @@ esp_err_t sdspi_host_init_slot(int slot, const sdspi_slot_config_t* slot_config)
         .pull_up_en = true
     };
     if (slot_config->gpio_cd != SDSPI_SLOT_NO_CD) {
-        io_conf.pin_bit_mask |= (1 << slot_config->gpio_cd);
-        s_slots[slot].gpio_cd = slot_config->gpio_cd;
+        io_conf.pin_bit_mask |= (1ULL << slot_config->gpio_cd);
+        slot->gpio_cd = slot_config->gpio_cd;
     } else {
-        s_slots[slot].gpio_cd = GPIO_UNUSED;
+        slot->gpio_cd = GPIO_UNUSED;
     }
 
     if (slot_config->gpio_wp != SDSPI_SLOT_NO_WP) {
-        io_conf.pin_bit_mask |= (1 << slot_config->gpio_wp);
-        s_slots[slot].gpio_wp = slot_config->gpio_wp;
+        io_conf.pin_bit_mask |= (1ULL << slot_config->gpio_wp);
+        slot->gpio_wp = slot_config->gpio_wp;
     } else {
-        s_slots[slot].gpio_wp = GPIO_UNUSED;
+        slot->gpio_wp = GPIO_UNUSED;
     }
 
     if (io_conf.pin_bit_mask != 0) {
         ret = gpio_config(&io_conf);
         if (ret != ESP_OK) {
             ESP_LOGD(TAG, "gpio_config (CD/WP) failed with rc=0x%x", ret);
-            spi_bus_remove_device(spi_handle(slot));
-            s_slots[slot].handle = NULL;
-            spi_bus_free(host);
-            return ret;
+            goto cleanup;
         }
     }
 
-    s_slots[slot].transactions = calloc(SDSPI_TRANSACTION_COUNT, sizeof(spi_transaction_t));
-    if (s_slots[slot].transactions == NULL) {
-        spi_bus_remove_device(spi_handle(slot));
-        s_slots[slot].handle = NULL;
-        spi_bus_free(host);
-        return ESP_ERR_NO_MEM;
-    }
+    if (slot_config->gpio_int != SDSPI_SLOT_NO_INT) {
+        slot->gpio_int = slot_config->gpio_int;
+        io_conf = (gpio_config_t) {
+            .intr_type = GPIO_INTR_LOW_LEVEL,
+            .mode = GPIO_MODE_INPUT,
+            .pull_up_en = true,
+            .pin_bit_mask = (1ULL << slot_config->gpio_int),
+        };
+        ret = gpio_config(&io_conf);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "gpio_config (interrupt) failed with rc=0x%x", ret);
+            goto cleanup;
+        }
 
+        slot->semphr_int = xSemaphoreCreateBinary();
+        if (slot->semphr_int == NULL) {
+            ret = ESP_ERR_NO_MEM;
+            goto cleanup;
+        }
+
+        gpio_intr_disable(slot->gpio_int);
+        // 1. the interrupt is better to be disabled before the ISR is registered
+        // 2. the semaphore MUST be initialized before the ISR is registered
+        // 3. the gpio_int member should be filled before the ISR is registered
+        ret = gpio_isr_handler_add(slot->gpio_int, &gpio_intr, slot);
+        if (ret != ESP_OK) {
+            ESP_LOGE(TAG, "gpio_isr_handle_add failed with rc=0x%x", ret);
+            goto cleanup;
+        }
+    } else {
+        slot->gpio_int = GPIO_UNUSED;
+    }
+    slot->transactions = calloc(SDSPI_TRANSACTION_COUNT, sizeof(spi_transaction_t));
+    if (slot->transactions == NULL) {
+        ret = ESP_ERR_NO_MEM;
+        goto cleanup;
+    }
+    //Initialization finished, store the store information if possible
+    //Then return corresponding handle
+    *out_handle = store_slot_info(slot);
     return ESP_OK;
-}
+cleanup:
+    if (slot->semphr_int) {
+        vSemaphoreDelete(slot->semphr_int);
+        slot->semphr_int = NULL;
+    }
+    if (slot->spi_handle) {
+        spi_bus_remove_device(slot->spi_handle);
+        slot->spi_handle = NULL;
+    }
+    free(slot);
+    return ret;
 
+}
 
-esp_err_t sdspi_host_start_command(int slot, sdspi_hw_cmd_t *cmd, void *data,
+esp_err_t sdspi_host_start_command(sdspi_dev_handle_t handle, sdspi_hw_cmd_t *cmd, void *data,
                                    uint32_t data_size, int flags)
 {
-    if (!is_valid_slot(slot)) {
+    slot_info_t *slot = get_slot_info(handle);
+    if (slot == NULL) {
         return ESP_ERR_INVALID_ARG;
     }
-    if (!is_slot_initialized(slot)) {
-        return ESP_ERR_INVALID_STATE;
-    }
     if (card_missing(slot)) {
         return ESP_ERR_NOT_FOUND;
     }
@@ -371,7 +478,7 @@ esp_err_t sdspi_host_start_command(int slot, sdspi_hw_cmd_t *cmd, void *data,
     memcpy(&cmd_arg, cmd->arguments, sizeof(cmd_arg));
     cmd_arg = __builtin_bswap32(cmd_arg);
     ESP_LOGV(TAG, "%s: slot=%i, CMD%d, arg=0x%08x flags=0x%x, data=%p, data_size=%i crc=0x%02x",
-             __func__, slot, cmd_index, cmd_arg, flags, data, data_size, cmd->crc7);
+             __func__, handle, cmd_index, cmd_arg, flags, data, data_size, cmd->crc7);
 
 
     // For CMD0, clock out 80 cycles to help the card enter idle state,
@@ -381,12 +488,17 @@ esp_err_t sdspi_host_start_command(int slot, sdspi_hw_cmd_t *cmd, void *data,
     }
     // actual transaction
     esp_err_t ret = ESP_OK;
+
+    spi_device_acquire_bus(slot->spi_handle, portMAX_DELAY);
     cs_low(slot);
     if (flags & SDSPI_CMD_FLAG_DATA) {
+        const bool multi_block = flags & SDSPI_CMD_FLAG_MULTI_BLK;
+        //send stop transmission token only when multi-block write and non-SDIO mode
+        const bool stop_transmission = multi_block && !(flags & SDSPI_CMD_FLAG_RSP_R5);
         if (flags & SDSPI_CMD_FLAG_WRITE) {
-            ret = start_command_write_blocks(slot, cmd, data, data_size);
+            ret = start_command_write_blocks(slot, cmd, data, data_size, multi_block, stop_transmission);
         } else {
-            ret = start_command_read_blocks(slot, cmd, data, data_size);
+            ret = start_command_read_blocks(slot, cmd, data, data_size, stop_transmission);
         }
     } else {
         ret = start_command_default(slot, flags, cmd);
@@ -394,20 +506,21 @@ esp_err_t sdspi_host_start_command(int slot, sdspi_hw_cmd_t *cmd, void *data,
     cs_high(slot);
 
     release_bus(slot);
+    spi_device_release_bus(slot->spi_handle);
 
     if (ret != ESP_OK) {
         ESP_LOGD(TAG, "%s: cmd=%d error=0x%x", __func__, cmd_index, ret);
     } else {
         // Update internal state when some commands are sent successfully
         if (cmd_index == SD_CRC_ON_OFF) {
-            s_slots[slot].data_crc_enabled = (uint8_t) cmd_arg;
-            ESP_LOGD(TAG, "data CRC set=%d", s_slots[slot].data_crc_enabled);
+            slot->data_crc_enabled = (uint8_t) cmd_arg;
+            ESP_LOGD(TAG, "data CRC set=%d", slot->data_crc_enabled);
         }
     }
     return ret;
 }
 
-static esp_err_t start_command_default(int slot, int flags, sdspi_hw_cmd_t *cmd)
+static esp_err_t start_command_default(slot_info_t *slot, int flags, sdspi_hw_cmd_t *cmd)
 {
     size_t cmd_size = SDSPI_CMD_R1_SIZE;
     if ((flags & SDSPI_CMD_FLAG_RSP_R1) ||
@@ -417,16 +530,22 @@ static esp_err_t start_command_default(int slot, int flags, sdspi_hw_cmd_t *cmd)
         cmd_size = SDSPI_CMD_R2_SIZE;
     } else if (flags & SDSPI_CMD_FLAG_RSP_R3) {
         cmd_size = SDSPI_CMD_R3_SIZE;
+    } else if (flags & SDSPI_CMD_FLAG_RSP_R4) {
+        cmd_size = SDSPI_CMD_R4_SIZE;
+    } else if (flags & SDSPI_CMD_FLAG_RSP_R5) {
+        cmd_size = SDSPI_CMD_R5_SIZE;
     } else if (flags & SDSPI_CMD_FLAG_RSP_R7) {
         cmd_size = SDSPI_CMD_R7_SIZE;
     }
+    //add extra clocks to avoid polling
+    cmd_size += (SDSPI_NCR_MAX_SIZE-SDSPI_NCR_MIN_SIZE);
     spi_transaction_t t = {
         .flags = 0,
         .length = cmd_size * 8,
         .tx_buffer = cmd,
-        .rx_buffer = cmd
+        .rx_buffer = cmd,
     };
-    esp_err_t ret = spi_device_transmit(spi_handle(slot), &t);
+    esp_err_t ret = spi_device_transmit(slot->spi_handle, &t);
     if (cmd->cmd_index == MMC_STOP_TRANSMISSION) {
         /* response is a stuff byte from previous transfer, ignore it */
         cmd->r1 = 0xff;
@@ -440,16 +559,16 @@ static esp_err_t start_command_default(int slot, int flags, sdspi_hw_cmd_t *cmd)
         ESP_LOGV(TAG, "%s: ignoring response byte", __func__);
         cmd->r1 = 0x00;
     }
-    ret = poll_cmd_response(slot, cmd);
-    if (ret != ESP_OK) {
-        ESP_LOGD(TAG, "%s: poll_cmd_response returned 0x%x", __func__, ret);
-        return ret;
-    }
+    // we have sent and received bytes with enough length.
+    // now shift the response to match the offset of sdspi_hw_cmd_t
+    ret = shift_cmd_response(cmd, cmd_size);
+    if (ret != ESP_OK) return ESP_ERR_TIMEOUT;
+
     return ESP_OK;
 }
 
 // Wait until MISO goes high
-static esp_err_t poll_busy(int slot, spi_transaction_t* t, int timeout_ms)
+static esp_err_t poll_busy(slot_info_t *slot, spi_transaction_t* t, int timeout_ms)
 {
     uint8_t t_rx;
     *t = (spi_transaction_t) {
@@ -464,7 +583,7 @@ static esp_err_t poll_busy(int slot, spi_transaction_t* t, int timeout_ms)
     do {
         t_rx = SDSPI_MOSI_IDLE_VAL;
         t->rx_data[0] = 0;
-        ret = spi_device_transmit(spi_handle(slot), t);
+        ret = spi_device_transmit(slot->spi_handle, t);
         if (ret != ESP_OK) {
             return ret;
         }
@@ -478,43 +597,10 @@ static esp_err_t poll_busy(int slot, spi_transaction_t* t, int timeout_ms)
     return ESP_ERR_TIMEOUT;
 }
 
-// Wait for response token
-static esp_err_t poll_response_token(int slot, spi_transaction_t* t, int timeout_ms)
-{
-    uint8_t t_rx;
-    *t = (spi_transaction_t) {
-        .tx_buffer = &t_rx,
-        .flags = SPI_TRANS_USE_RXDATA,
-        .length = 8,
-    };
-    esp_err_t ret;
-    uint64_t t_end = esp_timer_get_time() + timeout_ms * 1000;
-    do {
-        t_rx = SDSPI_MOSI_IDLE_VAL;
-        t->rx_data[0] = 0;
-        ret = spi_device_transmit(spi_handle(slot), t);
-        if (ret != ESP_OK) {
-            return ret;
-        }
-        if ((t->rx_data[0] & TOKEN_RSP_MASK) == TOKEN_RSP_OK) {
-            return ESP_OK;
-        }
-        if ((t->rx_data[0] & TOKEN_RSP_MASK) == TOKEN_RSP_CRC_ERR) {
-            return ESP_ERR_INVALID_CRC;
-        }
-        if ((t->rx_data[0] & TOKEN_RSP_MASK) == TOKEN_RSP_WRITE_ERR) {
-            return ESP_ERR_INVALID_RESPONSE;
-        }
-    } while (esp_timer_get_time() < t_end);
-
-    ESP_LOGD(TAG, "%s: timeout", __func__);
-    return ESP_ERR_TIMEOUT;
-}
-
 // Wait for data token, reading 8 bytes at a time.
 // If the token is found, write all subsequent bytes to extra_ptr,
 // and store the number of bytes written to extra_size.
-static esp_err_t poll_data_token(int slot, spi_transaction_t* t,
+static esp_err_t poll_data_token(slot_info_t *slot, spi_transaction_t* t,
         uint8_t* extra_ptr, size_t* extra_size, int timeout_ms)
 {
     uint8_t t_rx[8];
@@ -527,7 +613,7 @@ static esp_err_t poll_data_token(int slot, spi_transaction_t* t,
     uint64_t t_end = esp_timer_get_time() + timeout_ms * 1000;
     do {
         memset(t_rx, SDSPI_MOSI_IDLE_VAL, sizeof(t_rx));
-        ret = spi_device_transmit(spi_handle(slot), t);
+        ret = spi_device_transmit(slot->spi_handle, t);
         if (ret != ESP_OK) {
             return ret;
         }
@@ -554,27 +640,24 @@ static esp_err_t poll_data_token(int slot, spi_transaction_t* t,
     return ESP_ERR_TIMEOUT;
 }
 
-static esp_err_t poll_cmd_response(int slot, sdspi_hw_cmd_t *cmd)
+// the r1 respond could appear 1-8 clocks after the command token is sent
+// this function search for r1 in the buffer after 1 clocks to max 8 clocks
+// then shift the data after R1, to match the definition of sdspi_hw_cmd_t.
+static esp_err_t shift_cmd_response(sdspi_hw_cmd_t* cmd, int sent_bytes)
 {
-    int response_delay_bytes = SDSPI_RESPONSE_MAX_DELAY;
-    while ((cmd->r1 & SD_SPI_R1_NO_RESPONSE) != 0 && response_delay_bytes-- > 0) {
-        spi_transaction_t* t = get_transaction(slot);
-        *t = (spi_transaction_t) {
-            .flags = SPI_TRANS_USE_RXDATA | SPI_TRANS_USE_TXDATA,
-            .length = 8,
-        };
-        t->tx_data[0] = 0xff;
-        esp_err_t ret = spi_device_transmit(spi_handle(slot), t);
-        uint8_t r1 = t->rx_data[0];
-        release_transaction(slot);
-        if (ret != ESP_OK) {
-            return ret;
-        }
-        cmd->r1 = r1;
+    uint8_t* pr1 = &cmd->r1;
+    int ncr_cnt = 1;
+    while(true) {
+        if ((*pr1 & SD_SPI_R1_NO_RESPONSE) == 0) break;
+        pr1++;
+        if (++ncr_cnt > 8) return ESP_ERR_NOT_FOUND;
     }
-    if (cmd->r1 & SD_SPI_R1_NO_RESPONSE) {
-        return ESP_ERR_TIMEOUT;
+
+    int copy_bytes = sent_bytes - SDSPI_CMD_SIZE - ncr_cnt;
+    if (copy_bytes > 0) {
+        memcpy(&cmd->r1, pr1, copy_bytes);
     }
+
     return ESP_OK;
 }
 
@@ -620,17 +703,16 @@ static esp_err_t poll_cmd_response(int slot, sdspi_hw_cmd_t *cmd)
  * Further speedup is possible by pipelining transfers and CRC checks, at an
  * expense of one extra temporary buffer.
  */
-static esp_err_t start_command_read_blocks(int slot, sdspi_hw_cmd_t *cmd,
-        uint8_t *data, uint32_t rx_length)
+static esp_err_t start_command_read_blocks(slot_info_t *slot, sdspi_hw_cmd_t *cmd,
+        uint8_t *data, uint32_t rx_length, bool need_stop_command)
 {
-    bool need_stop_command = rx_length > SDSPI_MAX_DATA_LEN;
     spi_transaction_t* t_command = get_transaction(slot);
     *t_command = (spi_transaction_t) {
         .length = (SDSPI_CMD_R1_SIZE + SDSPI_RESPONSE_MAX_DELAY) * 8,
         .tx_buffer = cmd,
         .rx_buffer = cmd,
     };
-    esp_err_t ret = spi_device_transmit(spi_handle(slot), t_command);
+    esp_err_t ret = spi_device_transmit(slot->spi_handle, t_command);
     if (ret != ESP_OK) {
         return ret;
     }
@@ -698,7 +780,7 @@ static esp_err_t start_command_read_blocks(int slot, sdspi_hw_cmd_t *cmd,
             .tx_buffer = rx_data
         };
 
-        ret = spi_device_transmit(spi_handle(slot), t_data);
+        ret = spi_device_transmit(slot->spi_handle, t_data);
         if (ret != ESP_OK) {
             return ret;
         }
@@ -720,7 +802,7 @@ static esp_err_t start_command_read_blocks(int slot, sdspi_hw_cmd_t *cmd,
 
         // compute CRC of the received data
         uint16_t crc_of_data = 0;
-        if (data_crc_enabled(slot)) {
+        if (slot->data_crc_enabled) {
             crc_of_data = sdspi_crc16(data, will_receive + extra_data_size);
             if (crc_of_data != crc) {
                 ESP_LOGE(TAG, "data CRC failed, got=0x%04x expected=0x%04x", crc_of_data, crc);
@@ -757,44 +839,52 @@ static esp_err_t start_command_read_blocks(int slot, sdspi_hw_cmd_t *cmd,
     return ESP_OK;
 }
 
-static esp_err_t start_command_write_blocks(int slot, sdspi_hw_cmd_t *cmd,
-        const uint8_t *data, uint32_t tx_length)
+/* For CMD53, we can send in byte mode, or block mode
+ * The data start token is different, and cannot be determined by the length
+ * That's why we need ``multi_block``.
+ * It's also different that stop transmission token is not needed in the SDIO mode.
+ */
+static esp_err_t start_command_write_blocks(slot_info_t *slot, sdspi_hw_cmd_t *cmd,
+        const uint8_t *data, uint32_t tx_length, bool multi_block, bool stop_trans)
 {
     if (card_write_protected(slot)) {
         ESP_LOGW(TAG, "%s: card write protected", __func__);
         return ESP_ERR_INVALID_STATE;
     }
+    // Send the minimum length that is sure to get the complete response
+    // SD cards always return R1 (1bytes), SDIO returns R5 (2 bytes)
+    const int send_bytes = SDSPI_CMD_R5_SIZE+SDSPI_NCR_MAX_SIZE-SDSPI_NCR_MIN_SIZE;
+
     spi_transaction_t* t_command = get_transaction(slot);
     *t_command = (spi_transaction_t) {
-        .length = SDSPI_CMD_R1_SIZE * 8,
+        .length = send_bytes * 8,
         .tx_buffer = cmd,
         .rx_buffer = cmd,
     };
-    esp_err_t ret = spi_device_queue_trans(spi_handle(slot), t_command, 0);
+    esp_err_t ret = spi_device_queue_trans(slot->spi_handle, t_command, 0);
     if (ret != ESP_OK) {
         return ret;
     }
     wait_for_transactions(slot);
 
-    // Poll for command response which may be delayed up to 8 bytes
-    ret = poll_cmd_response(slot, cmd);
+    // check if command response valid
+    ret = shift_cmd_response(cmd, send_bytes);
     if (ret != ESP_OK) {
-        ESP_LOGD(TAG, "%s: poll_cmd_response returned 0x%x", __func__, ret);
+        ESP_LOGD(TAG, "%s: check_cmd_response returned 0x%x", __func__, ret);
         return ret;
     }
 
-    uint8_t start_token = tx_length <= SDSPI_MAX_DATA_LEN ?
-            TOKEN_BLOCK_START : TOKEN_BLOCK_START_WRITE_MULTI;
+    uint8_t start_token = multi_block ?
+             TOKEN_BLOCK_START_WRITE_MULTI : TOKEN_BLOCK_START;
 
     while (tx_length > 0) {
-
         // Write block start token
         spi_transaction_t* t_start_token = get_transaction(slot);
         *t_start_token = (spi_transaction_t) {
             .length = sizeof(start_token) * 8,
             .tx_buffer = &start_token
         };
-        ret = spi_device_queue_trans(spi_handle(slot), t_start_token, 0);
+        ret = spi_device_queue_trans(slot->spi_handle, t_start_token, 0);
         if (ret != ESP_OK) {
             return ret;
         }
@@ -819,19 +909,24 @@ static esp_err_t start_command_write_blocks(int slot, sdspi_hw_cmd_t *cmd,
             .length = will_send * 8,
             .tx_buffer = tx_data,
         };
-        ret = spi_device_queue_trans(spi_handle(slot), t_data, 0);
+        ret = spi_device_queue_trans(slot->spi_handle, t_data, 0);
         if (ret != ESP_OK) {
             return ret;
         }
 
-        // Write CRC
+        // Write CRC and get the response in one transaction
         uint16_t crc = sdspi_crc16(data, will_send);
-        spi_transaction_t* t_crc = get_transaction(slot);
-        *t_crc = (spi_transaction_t) {
-            .length = sizeof(crc) * 8,
-            .tx_buffer = (uint8_t*) &crc,
+        const int size_crc_response = sizeof(crc) + 1;
+
+        spi_transaction_t* t_crc_rsp = get_transaction(slot);
+        *t_crc_rsp = (spi_transaction_t) {
+            .length = size_crc_response * 8,
+            .flags = SPI_TRANS_USE_TXDATA|SPI_TRANS_USE_RXDATA,
         };
-        ret = spi_device_queue_trans(spi_handle(slot), t_crc, 0);
+        memset(t_crc_rsp->tx_data, 0xff, 4);
+        memcpy(t_crc_rsp->tx_data, &crc, sizeof(crc));
+
+        ret = spi_device_queue_trans(slot->spi_handle, t_crc_rsp, 0);
         if (ret != ESP_OK) {
             return ret;
         }
@@ -839,16 +934,21 @@ static esp_err_t start_command_write_blocks(int slot, sdspi_hw_cmd_t *cmd,
         // Wait for data to be sent
         wait_for_transactions(slot);
 
-        // Poll for response
-        spi_transaction_t* t_poll = get_transaction(slot);
-        ret = poll_response_token(slot, t_poll, cmd->timeout_ms);
-        release_transaction(slot);
-        if (ret != ESP_OK) {
-            return ret;
+        uint8_t data_rsp = t_crc_rsp->rx_data[2];
+        if (!SD_SPI_DATA_RSP_VALID(data_rsp)) return ESP_ERR_INVALID_RESPONSE;
+        switch (SD_SPI_DATA_RSP(data_rsp)) {
+        case SD_SPI_DATA_ACCEPTED:
+            break;
+        case SD_SPI_DATA_CRC_ERROR:
+            return ESP_ERR_INVALID_CRC;
+        case SD_SPI_DATA_WR_ERROR:
+            return ESP_FAIL;
+        default:
+            return ESP_ERR_INVALID_RESPONSE;
         }
 
         // Wait for the card to finish writing data
-        t_poll = get_transaction(slot);
+        spi_transaction_t* t_poll = get_transaction(slot);
         ret = poll_busy(slot, t_poll, cmd->timeout_ms);
         release_transaction(slot);
         if (ret != ESP_OK) {
@@ -859,23 +959,23 @@ static esp_err_t start_command_write_blocks(int slot, sdspi_hw_cmd_t *cmd,
         data += will_send;
     }
 
-    if (start_token == TOKEN_BLOCK_START_WRITE_MULTI) {
+    if (stop_trans) {
         uint8_t stop_token[2] = {
-                TOKEN_BLOCK_STOP_WRITE_MULTI,
-                SDSPI_MOSI_IDLE_VAL
+            TOKEN_BLOCK_STOP_WRITE_MULTI,
+            SDSPI_MOSI_IDLE_VAL
         };
-        spi_transaction_t* t_stop_token = get_transaction(slot);
+        spi_transaction_t *t_stop_token = get_transaction(slot);
         *t_stop_token = (spi_transaction_t) {
             .length = sizeof(stop_token) * 8,
             .tx_buffer = &stop_token,
         };
-        ret = spi_device_queue_trans(spi_handle(slot), t_stop_token, 0);
+        ret = spi_device_queue_trans(slot->spi_handle, t_stop_token, 0);
         if (ret != ESP_OK) {
             return ret;
         }
         wait_for_transactions(slot);
 
-        spi_transaction_t* t_poll = get_transaction(slot);
+        spi_transaction_t *t_poll = get_transaction(slot);
         ret = poll_busy(slot, t_poll, cmd->timeout_ms);
         release_transaction(slot);
         if (ret != ESP_OK) {
@@ -885,3 +985,78 @@ static esp_err_t start_command_write_blocks(int slot, sdspi_hw_cmd_t *cmd,
 
     return ESP_OK;
 }
+
+esp_err_t sdspi_host_io_int_enable(sdspi_dev_handle_t handle)
+{
+    //the pin and its interrupt is already initialized, nothing to do here.
+    return ESP_OK;
+}
+
+//the interrupt will give the semaphore and then disable itself
+esp_err_t sdspi_host_io_int_wait(sdspi_dev_handle_t handle, TickType_t timeout_ticks)
+{
+    slot_info_t* slot = get_slot_info(handle);
+    //skip the interrupt and semaphore if the gpio is already low.
+    if (gpio_get_level(slot->gpio_int)==0) return ESP_OK;
+
+    //clear the semaphore before wait
+    xSemaphoreTake(slot->semphr_int, 0);
+    //enable the interrupt and wait for the semaphore
+    gpio_intr_enable(slot->gpio_int);
+    BaseType_t ret = xSemaphoreTake(slot->semphr_int, timeout_ticks);
+    if (ret == pdFALSE) {
+        gpio_intr_disable(slot->gpio_int);
+        return ESP_ERR_TIMEOUT;
+    }
+    return ESP_OK;
+}
+
+//Deprecated, make use of new sdspi_host_init_device
+esp_err_t sdspi_host_init_slot(int slot, const sdspi_slot_config_t* slot_config)
+{
+    esp_err_t ret = ESP_OK;
+    if (get_slot_info(slot) != NULL) {
+        ESP_LOGE(TAG, "Bus already initialized. Call `sdspi_host_init_dev` to attach an sdspi device to an initialized bus.");
+        return ESP_ERR_INVALID_STATE;
+    }
+
+    //Assume the slot number equals to the host id.
+    spi_host_device_t host_id = slot;
+    // Initialize SPI bus
+    spi_bus_config_t buscfg = {
+        .miso_io_num = slot_config->gpio_miso,
+        .mosi_io_num = slot_config->gpio_mosi,
+        .sclk_io_num = slot_config->gpio_sck,
+        .quadwp_io_num = GPIO_NUM_NC,
+        .quadhd_io_num = GPIO_NUM_NC
+    };
+    ret = spi_bus_initialize(host_id, &buscfg,
+            slot_config->dma_channel);
+    if (ret != ESP_OK) {
+        ESP_LOGE(TAG, "spi_bus_initialize failed with rc=0x%x", ret);
+        return ret;
+    }
+
+    sdspi_dev_handle_t sdspi_handle;
+    sdspi_device_config_t dev_config = {
+        .host_id = host_id,
+        .gpio_cs = slot_config->gpio_cs,
+        .gpio_cd = slot_config->gpio_cd,
+        .gpio_wp = slot_config->gpio_wp,
+        .gpio_int = slot_config->gpio_int,
+    };
+    ret =  sdspi_host_init_device(&dev_config, &sdspi_handle);
+    if (ret != ESP_OK) {
+        goto cleanup;
+    }
+    if (sdspi_handle != host_id) {
+        ESP_LOGE(TAG, "The deprecated sdspi_host_init_slot should be called before all other devices on the specified bus.");
+        sdspi_host_remove_device(sdspi_handle);
+        ret = ESP_ERR_INVALID_STATE;
+        goto cleanup;
+    }
+    return ESP_OK;
+cleanup:
+    spi_bus_free(slot);
+    return ret;
+}
diff --git a/components/driver/sdspi_private.h b/components/driver/sdspi_private.h
index 32500ac77..dfed1cc3e 100644
--- a/components/driver/sdspi_private.h
+++ b/components/driver/sdspi_private.h
@@ -19,7 +19,7 @@
 #include "esp_err.h"
 #include "freertos/FreeRTOS.h"
 #include "freertos/queue.h"
-
+#include "driver/sdspi_host.h"
 
 /// Control tokens used to frame data transfers
 /// (see section 7.3.3 of SD simplified spec)
@@ -77,23 +77,33 @@ typedef struct {
     int timeout_ms;
 } sdspi_hw_cmd_t;
 
-#define SDSPI_CMD_NORESP_SIZE   6   //!< Size of the command without any response
-#define SDSPI_CMD_R1_SIZE       8   //!< Size of the command with R1 response
-#define SDSPI_CMD_R2_SIZE       9   //!< Size of the command with R1b response
-#define SDSPI_CMD_R3_SIZE       12  //!< Size of the command with R3 response
-#define SDSPI_CMD_R7_SIZE       12  //!< Size of the command with R7 response
+#define SDSPI_CMD_SIZE      6
+#define SDSPI_NCR_MIN_SIZE  1
+#define SDSPI_NCR_MAX_SIZE  8
+
+//the size here contains 6 bytes of CMD, 1 bytes of dummy and the actual response
+#define SDSPI_CMD_NORESP_SIZE   (SDSPI_CMD_SIZE+0)   //!< Size of the command without any response
+#define SDSPI_CMD_R1_SIZE       (SDSPI_CMD_SIZE+SDSPI_NCR_MIN_SIZE+1)   //!< Size of the command with R1 response
+#define SDSPI_CMD_R2_SIZE       (SDSPI_CMD_SIZE+SDSPI_NCR_MIN_SIZE+2)   //!< Size of the command with R1b response
+#define SDSPI_CMD_R3_SIZE       (SDSPI_CMD_SIZE+SDSPI_NCR_MIN_SIZE+5)  //!< Size of the command with R3 response
+#define SDSPI_CMD_R4_SIZE       (SDSPI_CMD_SIZE+SDSPI_NCR_MIN_SIZE+5)  //!< Size of the command with R4 response
+#define SDSPI_CMD_R5_SIZE       (SDSPI_CMD_SIZE+SDSPI_NCR_MIN_SIZE+2)   //!< Size of the command with R5 response
+#define SDSPI_CMD_R7_SIZE       (SDSPI_CMD_SIZE+SDSPI_NCR_MIN_SIZE+5)  //!< Size of the command with R7 response
 
 #define SDSPI_CMD_FLAG_DATA     BIT(0)  //!< Command has data transfer
 #define SDSPI_CMD_FLAG_WRITE    BIT(1)  //!< Data is written to the card
 #define SDSPI_CMD_FLAG_RSP_R1   BIT(2)  //!< Response format R1 (1 byte)
 #define SDSPI_CMD_FLAG_RSP_R2   BIT(3)  //!< Response format R2 (2 bytes)
 #define SDSPI_CMD_FLAG_RSP_R3   BIT(4)  //!< Response format R3 (5 bytes)
-#define SDSPI_CMD_FLAG_RSP_R7   BIT(5)  //!< Response format R7 (5 bytes)
-#define SDSPI_CMD_FLAG_NORSP    BIT(6)  //!< Don't expect response (used when sending CMD0 first time).
+#define SDSPI_CMD_FLAG_RSP_R4   BIT(5)  //!< Response format R4 (5 bytes)
+#define SDSPI_CMD_FLAG_RSP_R5   BIT(6)  //!< Response format R5 (2 bytes)
+#define SDSPI_CMD_FLAG_RSP_R7   BIT(7)  //!< Response format R7 (5 bytes)
+#define SDSPI_CMD_FLAG_NORSP    BIT(8)  //!< Don't expect response (used when sending CMD0 first time).
+#define SDSPI_CMD_FLAG_MULTI_BLK BIT(9) //!< For the write multiblock commands, the start token should be different
 
 #define SDSPI_MAX_DATA_LEN      512     //!< Max size of single block transfer
 
 void make_hw_cmd(uint32_t opcode, uint32_t arg, int timeout_ms, sdspi_hw_cmd_t *hw_cmd);
 
-esp_err_t sdspi_host_start_command(int slot, sdspi_hw_cmd_t *cmd,
+esp_err_t sdspi_host_start_command(sdspi_dev_handle_t handle, sdspi_hw_cmd_t *cmd,
                                    void *data, uint32_t data_size, int flags);
diff --git a/components/fatfs/CMakeLists.txt b/components/fatfs/CMakeLists.txt
index 4df07d30b..08aa762be 100644
--- a/components/fatfs/CMakeLists.txt
+++ b/components/fatfs/CMakeLists.txt
@@ -1,15 +1,15 @@
-set(COMPONENT_SRCS "src/diskio.c"
-                   "src/diskio_rawflash.c"
-                   "src/diskio_sdmmc.c"
-                   "src/diskio_wl.c"
-                   "src/ff.c"
-                   "src/ffsystem.c"
-                   "src/ffunicode.c"
-                   "src/vfs_fat.c"
-                   "src/vfs_fat_sdmmc.c"
-                   "src/vfs_fat_spiflash.c")
-set(COMPONENT_ADD_INCLUDEDIRS src)
+set(srcs "diskio/diskio.c"
+         "diskio/diskio_rawflash.c"
+         "diskio/diskio_sdmmc.c"
+         "diskio/diskio_wl.c"
+         "src/ff.c"
+         "port/freertos/ffsystem.c"
+         "src/ffunicode.c"
+         "vfs/vfs_fat.c"
+         "vfs/vfs_fat_sdmmc.c"
+         "vfs/vfs_fat_spiflash.c")
 
-set(COMPONENT_REQUIRES wear_levelling sdmmc)
-
-register_component()
+idf_component_register(SRCS ${srcs}
+                       INCLUDE_DIRS diskio vfs src
+                       REQUIRES wear_levelling sdmmc
+                      )
diff --git a/components/fatfs/component.mk b/components/fatfs/component.mk
index 591e080c6..bf33270c1 100644
--- a/components/fatfs/component.mk
+++ b/components/fatfs/component.mk
@@ -1,2 +1,3 @@
-COMPONENT_ADD_INCLUDEDIRS := src
-COMPONENT_SRCDIRS := src/option src
+COMPONENT_ADD_INCLUDEDIRS := diskio vfs src
+COMPONENT_SRCDIRS := diskio vfs port/freertos src
+COMPONENT_OBJEXCLUDE := src/diskio.o src/ffsystem.o
diff --git a/components/fatfs/diskio/diskio.c b/components/fatfs/diskio/diskio.c
new file mode 100644
index 000000000..c8075166d
--- /dev/null
+++ b/components/fatfs/diskio/diskio.c
@@ -0,0 +1,93 @@
+/*-----------------------------------------------------------------------*/
+/* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2016        */
+/* ESP-IDF port Copyright 2016 Espressif Systems (Shanghai) PTE LTD      */
+/*-----------------------------------------------------------------------*/
+/* If a working storage control module is available, it should be        */
+/* attached to the FatFs via a glue function rather than modifying it.   */
+/* This is an example of glue functions to attach various exsisting      */
+/* storage control modules to the FatFs module with a defined API.       */
+/*-----------------------------------------------------------------------*/
+
+#include <string.h>
+#include <time.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include "diskio_impl.h"
+#include "ffconf.h"
+#include "ff.h"
+
+static ff_diskio_impl_t * s_impls[FF_VOLUMES] = { NULL };
+
+#if FF_MULTI_PARTITION		/* Multiple partition configuration */
+PARTITION VolToPart[] = {
+    {0, 0},    /* Logical drive 0 ==> Physical drive 0, auto detection */
+    {1, 0}     /* Logical drive 1 ==> Physical drive 1, auto detection */
+};
+#endif
+
+esp_err_t ff_diskio_get_drive(BYTE* out_pdrv)
+{
+    BYTE i;
+    for(i=0; i<FF_VOLUMES; i++) {
+        if (!s_impls[i]) {
+            *out_pdrv = i;
+            return ESP_OK;
+        }
+    }
+    return ESP_ERR_NOT_FOUND;
+}
+
+void ff_diskio_register(BYTE pdrv, const ff_diskio_impl_t* discio_impl)
+{
+    assert(pdrv < FF_VOLUMES);
+
+    if (s_impls[pdrv]) {
+        ff_diskio_impl_t* im = s_impls[pdrv];
+        s_impls[pdrv] = NULL;
+        free(im);
+    }
+
+    if (!discio_impl) {
+        return;
+    }
+
+    ff_diskio_impl_t * impl = (ff_diskio_impl_t *)malloc(sizeof(ff_diskio_impl_t));
+    assert(impl != NULL);
+    memcpy(impl, discio_impl, sizeof(ff_diskio_impl_t));
+    s_impls[pdrv] = impl;
+}
+
+DSTATUS ff_disk_initialize (BYTE pdrv)
+{
+    return s_impls[pdrv]->init(pdrv);
+}
+DSTATUS ff_disk_status (BYTE pdrv)
+{
+    return s_impls[pdrv]->status(pdrv);
+}
+DRESULT ff_disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count)
+{
+    return s_impls[pdrv]->read(pdrv, buff, sector, count);
+}
+DRESULT ff_disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count)
+{
+    return s_impls[pdrv]->write(pdrv, buff, sector, count);
+}
+DRESULT ff_disk_ioctl (BYTE pdrv, BYTE cmd, void* buff)
+{
+    return s_impls[pdrv]->ioctl(pdrv, cmd, buff);
+}
+
+DWORD get_fattime(void)
+{
+    time_t t = time(NULL);
+    struct tm tmr;
+    localtime_r(&t, &tmr);
+    int year = tmr.tm_year < 80 ? 0 : tmr.tm_year - 80;
+    return    ((DWORD)(year) << 25)
+            | ((DWORD)(tmr.tm_mon + 1) << 21)
+            | ((DWORD)tmr.tm_mday << 16)
+            | (WORD)(tmr.tm_hour << 11)
+            | (WORD)(tmr.tm_min << 5)
+            | (WORD)(tmr.tm_sec >> 1);
+}
diff --git a/components/fatfs/diskio/diskio_impl.h b/components/fatfs/diskio/diskio_impl.h
new file mode 100644
index 000000000..1e5614c55
--- /dev/null
+++ b/components/fatfs/diskio/diskio_impl.h
@@ -0,0 +1,73 @@
+// Copyright 2017-2019 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdint.h>
+typedef unsigned int UINT;
+typedef unsigned char BYTE;
+typedef uint32_t DWORD;
+
+#define FF_DRV_NOT_USED 0xFF
+
+#include "diskio.h"
+#include "esp_err.h"
+
+/**
+ * Structure of pointers to disk IO driver functions.
+ *
+ * See FatFs documentation for details about these functions
+ */
+typedef struct {
+    DSTATUS (*init) (unsigned char pdrv);    /*!< disk initialization function */
+    DSTATUS (*status) (unsigned char pdrv);  /*!< disk status check function */
+    DRESULT (*read) (unsigned char pdrv, unsigned char* buff, uint32_t sector, unsigned count);  /*!< sector read function */
+    DRESULT (*write) (unsigned char pdrv, const unsigned char* buff, uint32_t sector, unsigned count);   /*!< sector write function */
+    DRESULT (*ioctl) (unsigned char pdrv, unsigned char cmd, void* buff); /*!< function to get info about disk and do some misc operations */
+} ff_diskio_impl_t;
+
+/**
+ * Register or unregister diskio driver for given drive number.
+ *
+ * When FATFS library calls one of disk_xxx functions for driver number pdrv,
+ * corresponding function in discio_impl for given pdrv will be called.
+ *
+ * @param pdrv drive number
+ * @param discio_impl   pointer to ff_diskio_impl_t structure with diskio functions
+ *                      or NULL to unregister and free previously registered drive
+ */
+void ff_diskio_register(BYTE pdrv, const ff_diskio_impl_t* discio_impl);
+
+#define ff_diskio_unregister(pdrv_) ff_diskio_register(pdrv_, NULL)
+
+
+/**
+ * Get next available drive number
+ *
+ * @param   out_pdrv            pointer to the byte to set if successful
+ *
+ * @return  ESP_OK              on success
+ *          ESP_ERR_NOT_FOUND   if all drives are attached
+ */
+esp_err_t ff_diskio_get_drive(BYTE* out_pdrv);
+
+
+#ifdef __cplusplus
+}
+#endif
+
diff --git a/components/fatfs/src/diskio_rawflash.c b/components/fatfs/diskio/diskio_rawflash.c
similarity index 99%
rename from components/fatfs/src/diskio_rawflash.c
rename to components/fatfs/diskio/diskio_rawflash.c
index bc3b204b5..363bd9b32 100644
--- a/components/fatfs/src/diskio_rawflash.c
+++ b/components/fatfs/diskio/diskio_rawflash.c
@@ -13,7 +13,7 @@
 // limitations under the License.
 
 #include <string.h>
-#include "diskio.h"
+#include "diskio_impl.h"
 #include "ffconf.h"
 #include "ff.h"
 #include "esp_log.h"
diff --git a/components/fatfs/src/diskio_rawflash.h b/components/fatfs/diskio/diskio_rawflash.h
similarity index 84%
rename from components/fatfs/src/diskio_rawflash.h
rename to components/fatfs/diskio/diskio_rawflash.h
index a7b61a470..73ff15f88 100644
--- a/components/fatfs/src/diskio_rawflash.h
+++ b/components/fatfs/diskio/diskio_rawflash.h
@@ -19,7 +19,6 @@
 extern "C" {
 #endif
 
-#include "integer.h"
 #include "esp_partition.h"
 
 /**
@@ -28,8 +27,8 @@ extern "C" {
  * @param pdrv  drive number
  * @param part_handle  pointer to raw flash partition.
  */
-esp_err_t ff_diskio_register_raw_partition(BYTE pdrv, const esp_partition_t* part_handle);
-BYTE ff_diskio_get_pdrv_raw(const esp_partition_t* part_handle);
+esp_err_t ff_diskio_register_raw_partition(unsigned char pdrv, const esp_partition_t* part_handle);
+unsigned char ff_diskio_get_pdrv_raw(const esp_partition_t* part_handle);
 
 #ifdef __cplusplus
 }
diff --git a/components/fatfs/src/diskio_sdmmc.c b/components/fatfs/diskio/diskio_sdmmc.c
similarity index 91%
rename from components/fatfs/src/diskio_sdmmc.c
rename to components/fatfs/diskio/diskio_sdmmc.c
index 168b29a97..c24473421 100644
--- a/components/fatfs/src/diskio_sdmmc.c
+++ b/components/fatfs/diskio/diskio_sdmmc.c
@@ -12,7 +12,7 @@
 // See the License for the specific language governing permissions and
 // limitations under the License.
 
-#include "diskio.h"
+#include "diskio_impl.h"
 #include "ffconf.h"
 #include "ff.h"
 #include "sdmmc_cmd.h"
@@ -88,3 +88,12 @@ void ff_diskio_register_sdmmc(BYTE pdrv, sdmmc_card_t* card)
     ff_diskio_register(pdrv, &sdmmc_impl);
 }
 
+BYTE ff_diskio_get_pdrv_card(const sdmmc_card_t* card)
+{
+    for (int i = 0; i < FF_VOLUMES; i++) {
+        if (card == s_cards[i]) {
+            return i;
+        }
+    }
+    return 0xff;
+}
diff --git a/components/fatfs/diskio/diskio_sdmmc.h b/components/fatfs/diskio/diskio_sdmmc.h
new file mode 100644
index 000000000..539b3b89a
--- /dev/null
+++ b/components/fatfs/diskio/diskio_sdmmc.h
@@ -0,0 +1,43 @@
+// Copyright 2017-2019 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#pragma once
+
+#include "sdmmc_cmd.h"
+#include "driver/sdmmc_defs.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * Register SD/MMC diskio driver
+ *
+ * @param pdrv  drive number
+ * @param card  pointer to sdmmc_card_t structure describing a card; card should be initialized before calling f_mount.
+ */
+void ff_diskio_register_sdmmc(unsigned char pdrv, sdmmc_card_t* card);
+
+/**
+ * @brief Get the driver number corresponding to a card
+ *
+ * @param card The card to get its driver
+ * @return Driver number to the card
+ */
+BYTE ff_diskio_get_pdrv_card(const sdmmc_card_t* card);
+
+#ifdef __cplusplus
+}
+#endif
+
diff --git a/components/fatfs/src/diskio_wl.c b/components/fatfs/diskio/diskio_wl.c
similarity index 99%
rename from components/fatfs/src/diskio_wl.c
rename to components/fatfs/diskio/diskio_wl.c
index 40547906f..2a17f5ba0 100644
--- a/components/fatfs/src/diskio_wl.c
+++ b/components/fatfs/diskio/diskio_wl.c
@@ -13,7 +13,7 @@
 // limitations under the License.
 
 #include <string.h>
-#include "diskio.h"
+#include "diskio_impl.h"
 #include "ffconf.h"
 #include "ff.h"
 #include "esp_log.h"
diff --git a/components/fatfs/src/diskio_wl.h b/components/fatfs/diskio/diskio_wl.h
similarity index 86%
rename from components/fatfs/src/diskio_wl.h
rename to components/fatfs/diskio/diskio_wl.h
index 9abff7ae0..af3f14797 100644
--- a/components/fatfs/src/diskio_wl.h
+++ b/components/fatfs/diskio/diskio_wl.h
@@ -19,7 +19,6 @@
 extern "C" {
 #endif
 
-#include "integer.h"
 #include "wear_levelling.h"
 
 
@@ -29,8 +28,8 @@ extern "C" {
  * @param pdrv  drive number
  * @param flash_handle  handle of the wear levelling partition.
  */
-esp_err_t ff_diskio_register_wl_partition(BYTE pdrv, wl_handle_t flash_handle);
-BYTE ff_diskio_get_pdrv_wl(wl_handle_t flash_handle);
+esp_err_t ff_diskio_register_wl_partition(unsigned char pdrv, wl_handle_t flash_handle);
+unsigned char ff_diskio_get_pdrv_wl(wl_handle_t flash_handle);
 void ff_diskio_clear_pdrv_wl(wl_handle_t flash_handle);
 
 #ifdef __cplusplus
diff --git a/components/fatfs/port/freertos/ffsystem.c b/components/fatfs/port/freertos/ffsystem.c
new file mode 100644
index 000000000..45a894de5
--- /dev/null
+++ b/components/fatfs/port/freertos/ffsystem.c
@@ -0,0 +1,108 @@
+/*------------------------------------------------------------------------*/
+/* Sample Code of OS Dependent Functions for FatFs                        */
+/* (C)ChaN, 2017                                                          */
+/*------------------------------------------------------------------------*/
+
+
+#include <string.h>
+#include <stdlib.h>
+#include "ff.h"
+#include "sdkconfig.h"
+#ifdef CONFIG_FATFS_ALLOC_EXTRAM_FIRST
+#include "esp_heap_caps.h"
+#endif
+
+void* ff_memalloc (    /* Returns pointer to the allocated memory block (null on not enough core) */
+    unsigned msize     /* Number of bytes to allocate */
+)
+{
+#ifdef CONFIG_FATFS_ALLOC_EXTRAM_FIRST
+    return heap_caps_malloc_prefer(size, 2, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM,
+                                            MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
+#else
+    return malloc(msize);
+#endif
+}
+
+
+/*------------------------------------------------------------------------*/
+/* Free a memory block                                                    */
+/*------------------------------------------------------------------------*/
+
+void ff_memfree (
+    void* mblock    /* Pointer to the memory block to free (nothing to do for null) */
+)
+{
+    free(mblock);   /* Free the memory block with POSIX API */
+}
+
+
+
+
+#if FF_FS_REENTRANT    /* Mutal exclusion */
+
+/*------------------------------------------------------------------------*/
+/* Create a Synchronization Object                                        */
+/*------------------------------------------------------------------------*/
+/* This function is called in f_mount() function to create a new
+/  synchronization object for the volume, such as semaphore and mutex.
+/  When a 0 is returned, the f_mount() function fails with FR_INT_ERR.
+*/
+
+
+int ff_cre_syncobj (    /* 1:Function succeeded, 0:Could not create the sync object */
+    BYTE vol,           /* Corresponding volume (logical drive number) */
+    FF_SYNC_t *sobj     /* Pointer to return the created sync object */
+)
+{
+    *sobj = xSemaphoreCreateMutex();
+    return (*sobj != NULL) ? 1 : 0;
+}
+
+
+/*------------------------------------------------------------------------*/
+/* Delete a Synchronization Object                                        */
+/*------------------------------------------------------------------------*/
+/* This function is called in f_mount() function to delete a synchronization
+/  object that created with ff_cre_syncobj() function. When a 0 is returned,
+/  the f_mount() function fails with FR_INT_ERR.
+*/
+
+int ff_del_syncobj (    /* 1:Function succeeded, 0:Could not delete due to an error */
+    FF_SYNC_t sobj      /* Sync object tied to the logical drive to be deleted */
+)
+{
+    vSemaphoreDelete(sobj);
+    return 1;
+}
+
+
+/*------------------------------------------------------------------------*/
+/* Request Grant to Access the Volume                                     */
+/*------------------------------------------------------------------------*/
+/* This function is called on entering file functions to lock the volume.
+/  When a 0 is returned, the file function fails with FR_TIMEOUT.
+*/
+
+int ff_req_grant (    /* 1:Got a grant to access the volume, 0:Could not get a grant */
+    FF_SYNC_t sobj    /* Sync object to wait */
+)
+{
+    return (xSemaphoreTake(sobj, FF_FS_TIMEOUT) == pdTRUE) ? 1 : 0;
+}
+
+
+/*------------------------------------------------------------------------*/
+/* Release Grant to Access the Volume                                     */
+/*------------------------------------------------------------------------*/
+/* This function is called on leaving file functions to unlock the volume.
+*/
+
+void ff_rel_grant (
+    FF_SYNC_t sobj    /* Sync object to be signaled */
+)
+{
+    xSemaphoreGive(sobj);
+}
+
+#endif // FF_FS_REENTRANT
diff --git a/components/fatfs/port/linux/ffsystem.c b/components/fatfs/port/linux/ffsystem.c
new file mode 100644
index 000000000..5013c8b12
--- /dev/null
+++ b/components/fatfs/port/linux/ffsystem.c
@@ -0,0 +1,46 @@
+/*------------------------------------------------------------------------*/
+/* OS Dependent Functions for FatFs                                       */
+/* (C)ChaN, 2018                                                          */
+/*------------------------------------------------------------------------*/
+
+
+#include "ff.h"
+#include <stdlib.h>
+
+/* This is the implementation for host-side testing on Linux.
+ * Host-side tests are single threaded, so lock functionality isn't needed.
+ */
+
+void* ff_memalloc(UINT msize)
+{
+    return malloc(msize);
+}
+
+void ff_memfree(void* mblock)
+{
+    free(mblock);
+}
+
+/* 1:Function succeeded, 0:Could not create the sync object */
+int ff_cre_syncobj(BYTE vol, FF_SYNC_t* sobj)
+{
+    *sobj = NULL;
+    return 1;
+}
+
+/* 1:Function succeeded, 0:Could not delete due to an error */
+int ff_del_syncobj(FF_SYNC_t sobj)
+{
+    return 1;
+}
+
+/* 1:Function succeeded, 0:Could not acquire lock */
+int ff_req_grant (FF_SYNC_t sobj)
+{
+    return 1;
+}
+
+void ff_rel_grant (FF_SYNC_t sobj)
+{
+}
+
diff --git a/components/fatfs/src/00history.txt b/components/fatfs/src/00history.txt
index 6789ab07f..db12a9e1b 100644
--- a/components/fatfs/src/00history.txt
+++ b/components/fatfs/src/00history.txt
@@ -312,3 +312,19 @@ R0.13a (October 14, 2017)
   Fixed f_setlabel() rejects some valid characters for exFAT volume. (appeared at R0.12)
 
 
+
+R0.13b (April 07, 2018)
+
+  Added support for UTF-32 encoding on the API. (FF_LFN_UNICODE = 3)
+  Added support for Unix style volume ID. (FF_STR_VOLUME_ID = 2)
+  Fixed accesing any object on the exFAT root directory beyond the cluster boundary can fail. (appeared at R0.12c)
+  Fixed f_setlabel() does not reject some invalid characters. (appeared at R0.09b)
+
+
+
+R0.13c (October 14, 2018)
+  Supported stdint.h for C99 and later. (integer.h was included in ff.h)
+  Fixed reading a directory gets infinite loop when the last directory entry is not empty. (appeared at R0.12)
+  Fixed creating a sub-directory in the fragmented sub-directory on the exFAT volume collapses FAT chain of the parent directory. (appeared at R0.12)
+  Fixed f_getcwd() cause output buffer overrun when the buffer has a valid drive number. (appeared at R0.13b)
+
diff --git a/components/fatfs/src/00readme.txt b/components/fatfs/src/00readme.txt
index 6eff7fce9..dcccbdbeb 100644
--- a/components/fatfs/src/00readme.txt
+++ b/components/fatfs/src/00readme.txt
@@ -1,4 +1,4 @@
-FatFs Module Source Files R0.13a
+FatFs Module Source Files R0.13c
 
 
 FILES
@@ -10,7 +10,6 @@ FILES
   ff.h           Common include file for FatFs and application module.
   diskio.h       Common include file for FatFs and disk I/O module.
   diskio.c       An example of glue function to attach existing disk I/O module to FatFs.
-  integer.h      Integer type definitions for FatFs.
   ffunicode.c    Optional Unicode utility functions.
   ffsystem.c     An example of optional O/S related functions.
 
diff --git a/components/fatfs/src/diskio.c b/components/fatfs/src/diskio.c
index 1bc78ea97..08ffcc860 100644
--- a/components/fatfs/src/diskio.c
+++ b/components/fatfs/src/diskio.c
@@ -1,6 +1,5 @@
 /*-----------------------------------------------------------------------*/
 /* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2016        */
-/* ESP-IDF port Copyright 2016 Espressif Systems (Shanghai) PTE LTD      */
 /*-----------------------------------------------------------------------*/
 /* If a working storage control module is available, it should be        */
 /* attached to the FatFs via a glue function rather than modifying it.   */
@@ -8,85 +7,223 @@
 /* storage control modules to the FatFs module with a defined API.       */
 /*-----------------------------------------------------------------------*/
 
-#include <string.h>
-#include <time.h>
-#include <sys/time.h>
-#include "diskio.h"		/* FatFs lower layer API */
-#include "ffconf.h"
-#include "ff.h"
+#include "ff.h"			/* Obtains integer types */
+#include "diskio.h"		/* Declarations of disk functions */
 
-static ff_diskio_impl_t * s_impls[FF_VOLUMES] = { NULL };
+/* Definitions of physical drive number for each drive */
+#define DEV_RAM		0	/* Example: Map Ramdisk to physical drive 0 */
+#define DEV_MMC		1	/* Example: Map MMC/SD card to physical drive 1 */
+#define DEV_USB		2	/* Example: Map USB MSD to physical drive 2 */
 
-#if FF_MULTI_PARTITION		/* Multiple partition configuration */
-PARTITION VolToPart[] = {
-    {0, 0},    /* Logical drive 0 ==> Physical drive 0, auto detection */
-    {1, 0}     /* Logical drive 1 ==> Physical drive 1, auto detection */
-};
-#endif
 
-esp_err_t ff_diskio_get_drive(BYTE* out_pdrv)
-{
-    BYTE i;
-    for(i=0; i<FF_VOLUMES; i++) {
-        if (!s_impls[i]) {
-            *out_pdrv = i;
-            return ESP_OK;
-        }
-    }
-    return ESP_ERR_NOT_FOUND;
-}
+/*-----------------------------------------------------------------------*/
+/* Get Drive Status                                                      */
+/*-----------------------------------------------------------------------*/
 
-void ff_diskio_register(BYTE pdrv, const ff_diskio_impl_t* discio_impl)
+DSTATUS disk_status (
+	BYTE pdrv		/* Physical drive nmuber to identify the drive */
+)
 {
-    assert(pdrv < FF_VOLUMES);
-
-    if (s_impls[pdrv]) {
-        ff_diskio_impl_t* im = s_impls[pdrv];
-        s_impls[pdrv] = NULL;
-        free(im);
-    }
-
-    if (!discio_impl) {
-        return;
-    }
-
-    ff_diskio_impl_t * impl = (ff_diskio_impl_t *)malloc(sizeof(ff_diskio_impl_t));
-    assert(impl != NULL);
-    memcpy(impl, discio_impl, sizeof(ff_diskio_impl_t));
-    s_impls[pdrv] = impl;
-}
+	DSTATUS stat;
+	int result;
 
-DSTATUS ff_disk_initialize (BYTE pdrv)
-{
-    return s_impls[pdrv]->init(pdrv);
-}
-DSTATUS ff_disk_status (BYTE pdrv)
-{
-    return s_impls[pdrv]->status(pdrv);
+	switch (pdrv) {
+	case DEV_RAM :
+		result = RAM_disk_status();
+
+		// translate the reslut code here
+
+		return stat;
+
+	case DEV_MMC :
+		result = MMC_disk_status();
+
+		// translate the reslut code here
+
+		return stat;
+
+	case DEV_USB :
+		result = USB_disk_status();
+
+		// translate the reslut code here
+
+		return stat;
+	}
+	return STA_NOINIT;
 }
-DRESULT ff_disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count)
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Inidialize a Drive                                                    */
+/*-----------------------------------------------------------------------*/
+
+DSTATUS disk_initialize (
+	BYTE pdrv				/* Physical drive nmuber to identify the drive */
+)
 {
-    return s_impls[pdrv]->read(pdrv, buff, sector, count);
+	DSTATUS stat;
+	int result;
+
+	switch (pdrv) {
+	case DEV_RAM :
+		result = RAM_disk_initialize();
+
+		// translate the reslut code here
+
+		return stat;
+
+	case DEV_MMC :
+		result = MMC_disk_initialize();
+
+		// translate the reslut code here
+
+		return stat;
+
+	case DEV_USB :
+		result = USB_disk_initialize();
+
+		// translate the reslut code here
+
+		return stat;
+	}
+	return STA_NOINIT;
 }
-DRESULT ff_disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count)
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Read Sector(s)                                                        */
+/*-----------------------------------------------------------------------*/
+
+DRESULT disk_read (
+	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
+	BYTE *buff,		/* Data buffer to store read data */
+	DWORD sector,	/* Start sector in LBA */
+	UINT count		/* Number of sectors to read */
+)
 {
-    return s_impls[pdrv]->write(pdrv, buff, sector, count);
+	DRESULT res;
+	int result;
+
+	switch (pdrv) {
+	case DEV_RAM :
+		// translate the arguments here
+
+		result = RAM_disk_read(buff, sector, count);
+
+		// translate the reslut code here
+
+		return res;
+
+	case DEV_MMC :
+		// translate the arguments here
+
+		result = MMC_disk_read(buff, sector, count);
+
+		// translate the reslut code here
+
+		return res;
+
+	case DEV_USB :
+		// translate the arguments here
+
+		result = USB_disk_read(buff, sector, count);
+
+		// translate the reslut code here
+
+		return res;
+	}
+
+	return RES_PARERR;
 }
-DRESULT ff_disk_ioctl (BYTE pdrv, BYTE cmd, void* buff)
+
+
+
+/*-----------------------------------------------------------------------*/
+/* Write Sector(s)                                                       */
+/*-----------------------------------------------------------------------*/
+
+#if FF_FS_READONLY == 0
+
+DRESULT disk_write (
+	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
+	const BYTE *buff,	/* Data to be written */
+	DWORD sector,		/* Start sector in LBA */
+	UINT count			/* Number of sectors to write */
+)
 {
-    return s_impls[pdrv]->ioctl(pdrv, cmd, buff);
+	DRESULT res;
+	int result;
+
+	switch (pdrv) {
+	case DEV_RAM :
+		// translate the arguments here
+
+		result = RAM_disk_write(buff, sector, count);
+
+		// translate the reslut code here
+
+		return res;
+
+	case DEV_MMC :
+		// translate the arguments here
+
+		result = MMC_disk_write(buff, sector, count);
+
+		// translate the reslut code here
+
+		return res;
+
+	case DEV_USB :
+		// translate the arguments here
+
+		result = USB_disk_write(buff, sector, count);
+
+		// translate the reslut code here
+
+		return res;
+	}
+
+	return RES_PARERR;
 }
 
-DWORD get_fattime(void)
+#endif
+
+
+/*-----------------------------------------------------------------------*/
+/* Miscellaneous Functions                                               */
+/*-----------------------------------------------------------------------*/
+
+DRESULT disk_ioctl (
+	BYTE pdrv,		/* Physical drive nmuber (0..) */
+	BYTE cmd,		/* Control code */
+	void *buff		/* Buffer to send/receive control data */
+)
 {
-    time_t t = time(NULL);
-    struct tm tmr;
-    localtime_r(&t, &tmr);
-    int year = tmr.tm_year < 80 ? 0 : tmr.tm_year - 80;
-    return    ((DWORD)(year) << 25)
-            | ((DWORD)(tmr.tm_mon + 1) << 21)
-            | ((DWORD)tmr.tm_mday << 16)
-            | (WORD)(tmr.tm_hour << 11)
-            | (WORD)(tmr.tm_min << 5)
-            | (WORD)(tmr.tm_sec >> 1);
+	DRESULT res;
+	int result;
+
+	switch (pdrv) {
+	case DEV_RAM :
+
+		// Process of the command for the RAM drive
+
+		return res;
+
+	case DEV_MMC :
+
+		// Process of the command for the MMC/SD card
+
+		return res;
+
+	case DEV_USB :
+
+		// Process of the command the USB drive
+
+		return res;
+	}
+
+	return RES_PARERR;
 }
+
diff --git a/components/fatfs/src/diskio.h b/components/fatfs/src/diskio.h
index 572f03dce..31776b8b6 100644
--- a/components/fatfs/src/diskio.h
+++ b/components/fatfs/src/diskio.h
@@ -9,10 +9,6 @@
 extern "C" {
 #endif
 
-#include "integer.h"
-#include "sdmmc_cmd.h"
-#include "driver/sdmmc_host.h"
-
 /* Status of Disk Functions */
 typedef BYTE	DSTATUS;
 
@@ -30,64 +26,12 @@ typedef enum {
 /* Prototypes for disk control functions */
 
 
-/* Redefine names of disk IO functions to prevent name collisions */
-#define disk_initialize     ff_disk_initialize
-#define disk_status         ff_disk_status
-#define disk_read           ff_disk_read
-#define disk_write          ff_disk_write
-#define disk_ioctl          ff_disk_ioctl
-
-
 DSTATUS disk_initialize (BYTE pdrv);
 DSTATUS disk_status (BYTE pdrv);
 DRESULT disk_read (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);
 DRESULT disk_write (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);
 DRESULT disk_ioctl (BYTE pdrv, BYTE cmd, void* buff);
 
-/**
- * Structure of pointers to disk IO driver functions.
- *
- * See FatFs documentation for details about these functions
- */
-typedef struct {
-    DSTATUS (*init) (BYTE pdrv);    /*!< disk initialization function */
-    DSTATUS (*status) (BYTE pdrv);  /*!< disk status check function */
-    DRESULT (*read) (BYTE pdrv, BYTE* buff, DWORD sector, UINT count);  /*!< sector read function */
-    DRESULT (*write) (BYTE pdrv, const BYTE* buff, DWORD sector, UINT count);   /*!< sector write function */
-    DRESULT (*ioctl) (BYTE pdrv, BYTE cmd, void* buff); /*!< function to get info about disk and do some misc operations */
-} ff_diskio_impl_t;
-
-/**
- * Register or unregister diskio driver for given drive number.
- *
- * When FATFS library calls one of disk_xxx functions for driver number pdrv,
- * corresponding function in discio_impl for given pdrv will be called.
- *
- * @param pdrv drive number
- * @param discio_impl   pointer to ff_diskio_impl_t structure with diskio functions
- *                      or NULL to unregister and free previously registered drive
- */
-void ff_diskio_register(BYTE pdrv, const ff_diskio_impl_t* discio_impl);
-
-#define ff_diskio_unregister(pdrv_) ff_diskio_register(pdrv_, NULL)
-
-/**
- * Register SD/MMC diskio driver
- *
- * @param pdrv  drive number
- * @param card  pointer to sdmmc_card_t structure describing a card; card should be initialized before calling f_mount.
- */
-void ff_diskio_register_sdmmc(BYTE pdrv, sdmmc_card_t* card);
-
-/**
- * Get next available drive number
- *
- * @param   out_pdrv            pointer to the byte to set if successful
- *
- * @return  ESP_OK              on success
- *          ESP_ERR_NOT_FOUND   if all drives are attached
- */
-esp_err_t ff_diskio_get_drive(BYTE* out_pdrv);
 
 /* Disk Status Bits (DSTATUS) */
 
@@ -99,11 +43,11 @@ esp_err_t ff_diskio_get_drive(BYTE* out_pdrv);
 /* Command code for disk_ioctrl fucntion */
 
 /* Generic command (Used by FatFs) */
-#define CTRL_SYNC			0	/* Complete pending write process (needed at _FS_READONLY == 0) */
-#define GET_SECTOR_COUNT	1	/* Get media size (needed at _USE_MKFS == 1) */
-#define GET_SECTOR_SIZE		2	/* Get sector size (needed at _MAX_SS != _MIN_SS) */
-#define GET_BLOCK_SIZE		3	/* Get erase block size (needed at _USE_MKFS == 1) */
-#define CTRL_TRIM			4	/* Inform device that the data on the block of sectors is no longer used (needed at _USE_TRIM == 1) */
+#define CTRL_SYNC			0	/* Complete pending write process (needed at FF_FS_READONLY == 0) */
+#define GET_SECTOR_COUNT	1	/* Get media size (needed at FF_USE_MKFS == 1) */
+#define GET_SECTOR_SIZE		2	/* Get sector size (needed at FF_MAX_SS != FF_MIN_SS) */
+#define GET_BLOCK_SIZE		3	/* Get erase block size (needed at FF_USE_MKFS == 1) */
+#define CTRL_TRIM			4	/* Inform device that the data on the block of sectors is no longer used (needed at FF_USE_TRIM == 1) */
 
 /* Generic command (Not used by FatFs) */
 #define CTRL_POWER			5	/* Get/Set power status */
diff --git a/components/fatfs/src/ff.c b/components/fatfs/src/ff.c
index 5ebdf4919..d9833c72e 100644
--- a/components/fatfs/src/ff.c
+++ b/components/fatfs/src/ff.c
@@ -1,8 +1,8 @@
 /*----------------------------------------------------------------------------/
-/  FatFs - Generic FAT Filesystem Module  R0.13a                              /
+/  FatFs - Generic FAT Filesystem Module  R0.13c                              /
 /-----------------------------------------------------------------------------/
 /
-/ Copyright (C) 2017, ChaN, all right reserved.
+/ Copyright (C) 2018, ChaN, all right reserved.
 /
 / FatFs module is an open source software. Redistribution and use of FatFs in
 / source and binary forms, with or without modification, are permitted provided
@@ -29,11 +29,20 @@
 
 ---------------------------------------------------------------------------*/
 
-#if FF_DEFINED != 89352	/* Revision ID */
+#if FF_DEFINED != 86604	/* Revision ID */
 #error Wrong include file (ff.h).
 #endif
 
 
+/* Limits and boundaries */
+#define MAX_DIR		0x200000		/* Max size of FAT directory */
+#define MAX_DIR_EX	0x10000000		/* Max size of exFAT directory */
+#define MAX_FAT12	0xFF5			/* Max FAT12 clusters (differs from specs, but right for real DOS/Windows behavior) */
+#define MAX_FAT16	0xFFF5			/* Max FAT16 clusters (differs from specs, but right for real DOS/Windows behavior) */
+#define MAX_FAT32	0x0FFFFFF5		/* Max FAT32 clusters (not specified, practical limit) */
+#define MAX_EXFAT	0x7FFFFFFD		/* Max exFAT clusters (differs from specs, implementation limit) */
+
+
 /* Character code support macros */
 #define IsUpper(c)		((c) >= 'A' && (c) <= 'Z')
 #define IsLower(c)		((c) >= 'a' && (c) <= 'z')
@@ -43,18 +52,18 @@
 #define IsSurrogateL(c)	((c) >= 0xDC00 && (c) <= 0xDFFF)
 
 
-/* Additional file attribute bits for internal use */
-#define AM_VOL		0x08	/* Volume label */
-#define AM_LFN		0x0F	/* LFN entry */
-#define AM_MASK		0x3F	/* Mask of defined bits */
-
-
 /* Additional file access control and file status flags for internal use */
 #define FA_SEEKEND	0x20	/* Seek to end of the file on file open */
 #define FA_MODIFIED	0x40	/* File has been modified */
 #define FA_DIRTY	0x80	/* FIL.buf[] needs to be written-back */
 
 
+/* Additional file attribute bits for internal use */
+#define AM_VOL		0x08	/* Volume label */
+#define AM_LFN		0x0F	/* LFN entry */
+#define AM_MASK		0x3F	/* Mask of defined bits */
+
+
 /* Name status flags in fn[11] */
 #define NSFLAG		11		/* Index of the name status byte */
 #define NS_LOSS		0x01	/* Out of 8.3 format */
@@ -67,13 +76,13 @@
 #define NS_NONAME	0x80	/* Not followed */
 
 
-/* Limits and boundaries */
-#define MAX_DIR		0x200000		/* Max size of FAT directory */
-#define MAX_DIR_EX	0x10000000		/* Max size of exFAT directory */
-#define MAX_FAT12	0xFF5			/* Max FAT12 clusters (differs from specs, but right for real DOS/Windows behavior) */
-#define MAX_FAT16	0xFFF5			/* Max FAT16 clusters (differs from specs, but right for real DOS/Windows behavior) */
-#define MAX_FAT32	0x0FFFFFF5		/* Max FAT32 clusters (not specified, practical limit) */
-#define MAX_EXFAT	0x7FFFFFFD		/* Max exFAT clusters (differs from specs, implementation limit) */
+/* exFAT directory entry types */
+#define	ET_BITMAP	0x81	/* Allocation bitmap */
+#define	ET_UPCASE	0x82	/* Up-case table */
+#define	ET_VLABEL	0x83	/* Volume label */
+#define	ET_FILEDIR	0x85	/* File and directory */
+#define	ET_STREAM	0xC0	/* Stream extension */
+#define	ET_FILENAME	0xC1	/* Name extension */
 
 
 /* FatFs refers the FAT structure as simple byte array instead of structure member
@@ -426,10 +435,10 @@ typedef struct {
 #if FF_VOLUMES < 1 || FF_VOLUMES > 10
 #error Wrong FF_VOLUMES setting
 #endif
-static FATFS *FatFs[FF_VOLUMES];	/* Pointer to the filesystem objects (logical drives) */
-static WORD Fsid;					/* File system mount ID */
+static FATFS* FatFs[FF_VOLUMES];	/* Pointer to the filesystem objects (logical drives) */
+static WORD Fsid;					/* Filesystem mount ID */
 
-#if FF_FS_RPATH != 0 && FF_VOLUMES >= 2
+#if FF_FS_RPATH != 0
 static BYTE CurrVol;				/* Current drive */
 #endif
 
@@ -437,6 +446,11 @@ static BYTE CurrVol;				/* Current drive */
 static FILESEM Files[FF_FS_LOCK];	/* Open object lock semaphores */
 #endif
 
+#if FF_STR_VOLUME_ID
+#ifdef FF_VOLUME_STRS
+static const char* const VolumeStr[FF_VOLUMES] = {FF_VOLUME_STRS};	/* Pre-defined volume ID */
+#endif
+#endif
 
 
 /*--------------------------------*/
@@ -456,10 +470,10 @@ static FILESEM Files[FF_FS_LOCK];	/* Open object lock semaphores */
 #if FF_MAX_LFN < 12 || FF_MAX_LFN > 255
 #error Wrong setting of FF_MAX_LFN
 #endif
-#if FF_LFN_BUF < 12 || FF_SFN_BUF < 12 || FF_LFN_BUF < FF_SFN_BUF
+#if FF_LFN_BUF < FF_SFN_BUF || FF_SFN_BUF < 12
 #error Wrong setting of FF_LFN_BUF or FF_SFN_BUF
 #endif
-#if FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 2
+#if FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3
 #error Wrong setting of FF_LFN_UNICODE
 #endif
 static const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* FAT: Offset of LFN characters in the directory entry */
@@ -498,7 +512,7 @@ static WCHAR LfnBuf[FF_MAX_LFN + 1];		/* LFN working buffer */
 #define FREE_NAMBUF()	ff_memfree(lfn)
 #endif
 #define LEAVE_MKFS(res)	{ if (!work) ff_memfree(buf); return res; }
-#define MAX_MALLOC	0x8000
+#define MAX_MALLOC	0x8000	/* Must be >=FF_MAX_SS */
 
 #else
 #error Wrong setting of FF_USE_LFN
@@ -516,6 +530,7 @@ static WCHAR LfnBuf[FF_MAX_LFN + 1];		/* LFN working buffer */
 #define CODEPAGE CodePage
 static WORD CodePage;	/* Current code page */
 static const BYTE *ExCvt, *DbcTbl;	/* Pointer to current SBCS up-case table and DBCS code range table below */
+
 static const BYTE Ct437[] = TBL_CT437;
 static const BYTE Ct720[] = TBL_CT720;
 static const BYTE Ct737[] = TBL_CT737;
@@ -562,8 +577,7 @@ static const BYTE DbcTbl[] = MKCVTBL(TBL_DC, FF_CODE_PAGE);
 /* Load/Store multi-byte word in the FAT structure                       */
 /*-----------------------------------------------------------------------*/
 
-static
-WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
+static WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
 {
 	WORD rv;
 
@@ -572,8 +586,7 @@ WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
 	return rv;
 }
 
-static
-DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
+static DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
 {
 	DWORD rv;
 
@@ -585,8 +598,7 @@ DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
 }
 
 #if FF_FS_EXFAT
-static
-QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
+static QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
 {
 	QWORD rv;
 
@@ -603,15 +615,13 @@ QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
 #endif
 
 #if !FF_FS_READONLY
-static
-void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
+static void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
 {
 	*ptr++ = (BYTE)val; val >>= 8;
 	*ptr++ = (BYTE)val;
 }
 
-static
-void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
+static void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
 {
 	*ptr++ = (BYTE)val; val >>= 8;
 	*ptr++ = (BYTE)val; val >>= 8;
@@ -620,8 +630,7 @@ void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
 }
 
 #if FF_FS_EXFAT
-static
-void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
+static void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
 {
 	*ptr++ = (BYTE)val; val >>= 8;
 	*ptr++ = (BYTE)val; val >>= 8;
@@ -642,8 +651,7 @@ void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
 /*-----------------------------------------------------------------------*/
 
 /* Copy memory to memory */
-static
-void mem_cpy (void* dst, const void* src, UINT cnt)
+static void mem_cpy (void* dst, const void* src, UINT cnt)
 {
 	BYTE *d = (BYTE*)dst;
 	const BYTE *s = (const BYTE*)src;
@@ -657,8 +665,7 @@ void mem_cpy (void* dst, const void* src, UINT cnt)
 
 
 /* Fill memory block */
-static
-void mem_set (void* dst, int val, UINT cnt)
+static void mem_set (void* dst, int val, UINT cnt)
 {
 	BYTE *d = (BYTE*)dst;
 
@@ -669,8 +676,7 @@ void mem_set (void* dst, int val, UINT cnt)
 
 
 /* Compare memory block */
-static
-int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
+static int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:different */
 {
 	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
 	int r = 0;
@@ -684,8 +690,7 @@ int mem_cmp (const void* dst, const void* src, UINT cnt)	/* ZR:same, NZ:differen
 
 
 /* Check if chr is contained in the string */
-static
-int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
+static int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
 {
 	while (*str && *str != chr) str++;
 	return *str;
@@ -693,8 +698,7 @@ int chk_chr (const char* str, int chr)	/* NZ:contained, ZR:not contained */
 
 
 /* Test if the character is DBC 1st byte */
-static
-int dbc_1st (BYTE c)
+static int dbc_1st (BYTE c)
 {
 #if FF_CODE_PAGE == 0		/* Variable code page */
 	if (DbcTbl && c >= DbcTbl[0]) {
@@ -714,8 +718,7 @@ int dbc_1st (BYTE c)
 
 
 /* Test if the character is DBC 2nd byte */
-static
-int dbc_2nd (BYTE c)
+static int dbc_2nd (BYTE c)
 {
 #if FF_CODE_PAGE == 0		/* Variable code page */
 	if (DbcTbl && c >= DbcTbl[4]) {
@@ -739,9 +742,8 @@ int dbc_2nd (BYTE c)
 #if FF_USE_LFN
 
 /* Get a character from TCHAR string in defined API encodeing */
-static
-DWORD tchar2uni (		/* Returns character in UTF-16 encoding (>=0x10000 on double encoding unit, 0xFFFFFFFF on decode error) */
-	const TCHAR** str	/* Pointer to pointer to TCHAR string in configured encoding */
+static DWORD tchar2uni (	/* Returns character in UTF-16 encoding (>=0x10000 on double encoding unit, 0xFFFFFFFF on decode error) */
+	const TCHAR** str		/* Pointer to pointer to TCHAR string in configured encoding */
 )
 {
 	DWORD uc;
@@ -750,7 +752,7 @@ DWORD tchar2uni (		/* Returns character in UTF-16 encoding (>=0x10000 on double
 #if FF_LFN_UNICODE == 1		/* UTF-16 input */
 	WCHAR wc;
 
-	uc = *p++;
+	uc = *p++;	/* Get a unit */
 	if (IsSurrogate(uc)) {	/* Surrogate? */
 		wc = *p++;		/* Get low surrogate */
 		if (!IsSurrogateH(uc) || !IsSurrogateL(wc)) return 0xFFFFFFFF;	/* Wrong surrogate? */
@@ -761,7 +763,7 @@ DWORD tchar2uni (		/* Returns character in UTF-16 encoding (>=0x10000 on double
 	BYTE b;
 	int nf;
 
-	uc = (BYTE)*p++;	/* Get a byte */
+	uc = (BYTE)*p++;	/* Get a unit */
 	if (uc & 0x80) {	/* Multiple byte code? */
 		if ((uc & 0xE0) == 0xC0) {	/* 2-byte sequence? */
 			uc &= 0x1F; nf = 1;
@@ -782,9 +784,14 @@ DWORD tchar2uni (		/* Returns character in UTF-16 encoding (>=0x10000 on double
 			uc = uc << 6 | (b & 0x3F);
 		} while (--nf != 0);
 		if (uc < 0x80 || IsSurrogate(uc) || uc >= 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
-		if (uc >= 0x10000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
+		if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
 	}
 
+#elif FF_LFN_UNICODE == 3	/* UTF-32 input */
+	uc = (TCHAR)*p++;	/* Get a unit */
+	if (uc >= 0x110000) return 0xFFFFFFFF;	/* Wrong code? */
+	if (uc >= 0x010000) uc = 0xD800DC00 | ((uc - 0x10000) << 6 & 0x3FF0000) | (uc & 0x3FF);	/* Make a surrogate pair if needed */
+
 #else		/* ANSI/OEM input */
 	BYTE b;
 	WCHAR wc;
@@ -808,8 +815,7 @@ DWORD tchar2uni (		/* Returns character in UTF-16 encoding (>=0x10000 on double
 
 
 /* Output a TCHAR string in defined API encoding */
-static
-BYTE put_utf (	/* Returns number of encoding units written (0:buffer overflow or wrong encoding) */
+static BYTE put_utf (	/* Returns number of encoding units written (0:buffer overflow or wrong encoding) */
 	DWORD chr,	/* UTF-16 encoded character (Double encoding unit char if >=0x10000) */
 	TCHAR* buf,	/* Output buffer */
 	UINT szb	/* Size of the buffer */
@@ -863,6 +869,19 @@ BYTE put_utf (	/* Returns number of encoding units written (0:buffer overflow or
 	*buf++ = (TCHAR)(0x80 | (chr >> 0 & 0x3F));
 	return 4;
 
+#elif FF_LFN_UNICODE == 3	/* UTF-32 output */
+	DWORD hc;
+
+	if (szb < 1) return 0;	/* Buffer overflow? */
+	if (chr >= 0x10000) {	/* Out of BMP? */
+		hc = ((chr & 0xFFFF0000) - 0xD8000000) >> 6;	/* Get high 10 bits */
+		chr = (chr & 0xFFFF) - 0xDC00;					/* Get low 10 bits */
+		if (hc >= 0x100000 || chr >= 0x400) return 0;	/* Wrong surrogate? */
+		chr = (hc | chr) + 0x10000;
+	}
+	*buf++ = (TCHAR)chr;
+	return 1;
+
 #else						/* ANSI/OEM output */
 	WCHAR wc;
 
@@ -885,8 +904,7 @@ BYTE put_utf (	/* Returns number of encoding units written (0:buffer overflow or
 /*-----------------------------------------------------------------------*/
 /* Request/Release grant to access the volume                            */
 /*-----------------------------------------------------------------------*/
-static
-int lock_fs (		/* 1:Ok, 0:timeout */
+static int lock_fs (		/* 1:Ok, 0:timeout */
 	FATFS* fs		/* Filesystem object */
 )
 {
@@ -894,8 +912,7 @@ int lock_fs (		/* 1:Ok, 0:timeout */
 }
 
 
-static
-void unlock_fs (
+static void unlock_fs (
 	FATFS* fs,		/* Filesystem object */
 	FRESULT res		/* Result code to be returned */
 )
@@ -914,8 +931,7 @@ void unlock_fs (
 /* File lock control functions                                           */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT chk_lock (	/* Check if the file can be accessed */
+static FRESULT chk_lock (	/* Check if the file can be accessed */
 	FF_DIR* dp,		/* Directory object pointing the file to be checked */
 	int acc			/* Desired access type (0:Read mode open, 1:Write mode open, 2:Delete or rename) */
 )
@@ -942,8 +958,7 @@ FRESULT chk_lock (	/* Check if the file can be accessed */
 }
 
 
-static
-int enq_lock (void)	/* Check if an entry is available for a new object */
+static int enq_lock (void)	/* Check if an entry is available for a new object */
 {
 	UINT i;
 
@@ -952,8 +967,7 @@ int enq_lock (void)	/* Check if an entry is available for a new object */
 }
 
 
-static
-UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
+static UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
 	FF_DIR* dp,	/* Directory object pointing the file to register or increment */
 	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
 )
@@ -984,8 +998,7 @@ UINT inc_lock (	/* Increment object open counter and returns its index (0:Intern
 }
 
 
-static
-FRESULT dec_lock (	/* Decrement object open counter */
+static FRESULT dec_lock (	/* Decrement object open counter */
 	UINT i			/* Semaphore index (1..) */
 )
 {
@@ -1007,8 +1020,7 @@ FRESULT dec_lock (	/* Decrement object open counter */
 }
 
 
-static
-void clear_lock (	/* Clear lock entries of the volume */
+static void clear_lock (	/* Clear lock entries of the volume */
 	FATFS *fs
 )
 {
@@ -1027,8 +1039,7 @@ void clear_lock (	/* Clear lock entries of the volume */
 /* Move/Flush disk access window in the filesystem object                */
 /*-----------------------------------------------------------------------*/
 #if !FF_FS_READONLY
-static
-FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
+static FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 	FATFS* fs			/* Filesystem object */
 )
 {
@@ -1050,8 +1061,7 @@ FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERR */
 #endif
 
 
-static
-FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
+static FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 	FATFS* fs,			/* Filesystem object */
 	DWORD sector		/* Sector number to make appearance in the fs->win[] */
 )
@@ -1082,8 +1092,7 @@ FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERR */
 /* Synchronize filesystem and data on the storage                        */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
+static FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
 	FATFS* fs		/* Filesystem object */
 )
 {
@@ -1094,7 +1103,7 @@ FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
 	if (res == FR_OK) {
 		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {	/* FAT32: Update FSInfo sector if needed */
 			/* Create FSInfo structure */
-			mem_set(fs->win, 0, SS(fs));
+			mem_set(fs->win, 0, sizeof fs->win);
 			st_word(fs->win + BS_55AA, 0xAA55);
 			st_dword(fs->win + FSI_LeadSig, 0x41615252);
 			st_dword(fs->win + FSI_StrucSig, 0x61417272);
@@ -1120,8 +1129,7 @@ FRESULT sync_fs (	/* Returns FR_OK or FR_DISK_ERR */
 /* Get physical sector number from cluster number                        */
 /*-----------------------------------------------------------------------*/
 
-static
-DWORD clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
+static DWORD clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
 	FATFS* fs,		/* Filesystem object */
 	DWORD clst		/* Cluster# to be converted */
 )
@@ -1138,8 +1146,7 @@ DWORD clst2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
 /* FAT access - Read value of a FAT entry                                */
 /*-----------------------------------------------------------------------*/
 
-static
-DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
+static DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 	FFOBJID* obj,	/* Corresponding object */
 	DWORD clst		/* Cluster number to get the value */
 )
@@ -1176,7 +1183,7 @@ DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Clust
 			break;
 #if FF_FS_EXFAT
 		case FS_EXFAT :
-			if (obj->objsize != 0) {
+			if ((obj->objsize != 0 && obj->sclust != 0) || obj->stat == 0) {	/* Object except root dir must have valid data length */
 				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
 				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
 
@@ -1216,8 +1223,7 @@ DWORD get_fat (		/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Clust
 /* FAT access - Change value of a FAT entry                              */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
+static FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 	FATFS* fs,		/* Corresponding filesystem object */
 	DWORD clst,		/* FAT index number (cluster number) to be changed */
 	DWORD val		/* New value to be set to the entry */
@@ -1282,8 +1288,7 @@ FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
 /* Find a contiguous free cluster block */
 /*--------------------------------------*/
 
-static
-DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk error */
+static DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk error */
 	FATFS* fs,	/* Filesystem object */
 	DWORD clst,	/* Cluster number to scan from */
 	DWORD ncl	/* Number of contiguous clusters to find (1..) */
@@ -1298,7 +1303,7 @@ DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk err
 	if (clst >= fs->n_fatent - 2) clst = 0;
 	scl = val = clst; ctr = 0;
 	for (;;) {
-		if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;	/* (assuming bitmap is located top of the cluster heap) */
+		if (move_window(fs, fs->bitbase + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
 		i = val / 8 % SS(fs); bm = 1 << (val % 8);
 		do {
 			do {
@@ -1323,8 +1328,7 @@ DWORD find_bitmap (	/* 0:Not found, 2..:Cluster block found, 0xFFFFFFFF:Disk err
 /* Set/Clear a block of allocation bitmap */
 /*----------------------------------------*/
 
-static
-FRESULT change_bitmap (
+static FRESULT change_bitmap (
 	FATFS* fs,	/* Filesystem object */
 	DWORD clst,	/* Cluster number to change from */
 	DWORD ncl,	/* Number of clusters to be changed */
@@ -1337,9 +1341,9 @@ FRESULT change_bitmap (
 
 
 	clst -= 2;	/* The first bit corresponds to cluster #2 */
-	sect = fs->database + clst / 8 / SS(fs);	/* Sector address (assuming bitmap is located top of the cluster heap) */
-	i = clst / 8 % SS(fs);						/* Byte offset in the sector */
-	bm = 1 << (clst % 8);						/* Bit mask in the byte */
+	sect = fs->bitbase + clst / 8 / SS(fs);	/* Sector address */
+	i = clst / 8 % SS(fs);					/* Byte offset in the sector */
+	bm = 1 << (clst % 8);					/* Bit mask in the byte */
 	for (;;) {
 		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
 		do {
@@ -1360,8 +1364,7 @@ FRESULT change_bitmap (
 /* Fill the first fragment of the FAT chain    */
 /*---------------------------------------------*/
 
-static
-FRESULT fill_first_frag (
+static FRESULT fill_first_frag (
 	FFOBJID* obj	/* Pointer to the corresponding object */
 )
 {
@@ -1384,8 +1387,7 @@ FRESULT fill_first_frag (
 /* Fill the last fragment of the FAT chain     */
 /*---------------------------------------------*/
 
-static
-FRESULT fill_last_frag (
+static FRESULT fill_last_frag (
 	FFOBJID* obj,	/* Pointer to the corresponding object */
 	DWORD lcl,		/* Last cluster of the fragment */
 	DWORD term		/* Value to set the last FAT entry */
@@ -1410,11 +1412,11 @@ FRESULT fill_last_frag (
 /*-----------------------------------------------------------------------*/
 /* FAT handling - Remove a cluster chain                                 */
 /*-----------------------------------------------------------------------*/
-static
-FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
+
+static FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
 	FFOBJID* obj,		/* Corresponding object */
 	DWORD clst,			/* Cluster to remove a chain from */
-	DWORD pclst			/* Previous cluster of clst (0:entire chain) */
+	DWORD pclst			/* Previous cluster of clst (0 if entire chain) */
 )
 {
 	FRESULT res = FR_OK;
@@ -1505,8 +1507,8 @@ FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
 /*-----------------------------------------------------------------------*/
 /* FAT handling - Stretch a chain or Create a new chain                  */
 /*-----------------------------------------------------------------------*/
-static
-DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
+
+static DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
 	FFOBJID* obj,		/* Corresponding object */
 	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
 )
@@ -1609,8 +1611,7 @@ DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk err
 /* FAT handling - Convert offset into cluster with link map table        */
 /*-----------------------------------------------------------------------*/
 
-static
-DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
+static DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
 	FIL* fp,		/* Pointer to the file object */
 	FSIZE_t ofs		/* File offset to be converted to cluster# */
 )
@@ -1640,25 +1641,24 @@ DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
 /*-----------------------------------------------------------------------*/
 
 #if !FF_FS_READONLY
-static
-FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
+static FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
 	FATFS *fs,		/* Filesystem object */
 	DWORD clst		/* Directory table to clear */
 )
 {
 	DWORD sect;
 	UINT n, szb;
-	BYTE *ibuf = NULL;
+	BYTE *ibuf;
 
 
 	if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 	sect = clst2sect(fs, clst);		/* Top of the cluster */
 	fs->winsect = sect;				/* Set window to top of the cluster */
-	mem_set(fs->win, 0, SS(fs));	/* Clear window buffer */
+	mem_set(fs->win, 0, sizeof fs->win);	/* Clear window buffer */
 #if FF_USE_LFN == 3		/* Quick table clear by using multi-secter write */
 	/* Allocate a temporary buffer */
-	for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs); szb > SS(fs) && !(ibuf = ff_memalloc(szb)); szb /= 2) ;
-	if (szb > SS(fs) && ibuf != NULL) {		/* Buffer allocated? */
+	for (szb = ((DWORD)fs->csize * SS(fs) >= MAX_MALLOC) ? MAX_MALLOC : fs->csize * SS(fs), ibuf = 0; szb > SS(fs) && (ibuf = ff_memalloc(szb)) == 0; szb /= 2) ;
+	if (szb > SS(fs)) {		/* Buffer allocated? */
 		mem_set(ibuf, 0, szb);
 		szb /= SS(fs);		/* Bytes -> Sectors */
 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
@@ -1666,7 +1666,7 @@ FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
 	} else
 #endif
 	{
-		ibuf = fs->win; szb = 1;	/* Use window buffer (single-sector writes may take a time) */
+		ibuf = fs->win; szb = 1;	/* Use window buffer (many single-sector writes may take a time) */
 		for (n = 0; n < fs->csize && disk_write(fs->pdrv, ibuf, sect + n, szb) == RES_OK; n += szb) ;	/* Fill the cluster with 0 */
 	}
 	return (n == fs->csize) ? FR_OK : FR_DISK_ERR;
@@ -1680,8 +1680,7 @@ FRESULT dir_clear (	/* Returns FR_OK or FR_DISK_ERR */
 /* Directory handling - Set directory index                              */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
+static FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 	FF_DIR* dp,		/* Pointer to directory object */
 	DWORD ofs		/* Offset of directory table */
 )
@@ -1729,10 +1728,9 @@ FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 /* Directory handling - Move directory table index next                  */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
-	FF_DIR* dp,		/* Pointer to the directory object */
-	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
+static FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
+	FF_DIR* dp,				/* Pointer to the directory object */
+	int stretch				/* 0: Do not stretch table, 1: Stretch table if needed */
 )
 {
 	DWORD ofs, clst;
@@ -1740,7 +1738,8 @@ FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Cou
 
 
 	ofs = dp->dptr + SZDIRE;	/* Next entry */
-	if (dp->sect == 0 || ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
+	if (ofs >= (DWORD)((FF_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) dp->sect = 0;	/* Disable it if the offset reached the max value */
+	if (dp->sect == 0) return FR_NO_FILE;	/* Report EOT if it has been disabled */
 
 	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 		dp->sect++;				/* Next sector */
@@ -1790,10 +1789,9 @@ FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Cou
 /* Directory handling - Reserve a block of directory entries             */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
-	FF_DIR* dp,		/* Pointer to the directory object */
-	UINT nent		/* Number of contiguous entries to allocate */
+static FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
+	FF_DIR* dp,				/* Pointer to the directory object */
+	UINT nent				/* Number of contiguous entries to allocate */
 )
 {
 	FRESULT res;
@@ -1833,10 +1831,9 @@ FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
 /* FAT: Directory handling - Load/Store start cluster number             */
 /*-----------------------------------------------------------------------*/
 
-static
-DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
-	FATFS* fs,		/* Pointer to the fs object */
-	const BYTE* dir	/* Pointer to the key entry */
+static DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
+	FATFS* fs,			/* Pointer to the fs object */
+	const BYTE* dir		/* Pointer to the key entry */
 )
 {
 	DWORD cl;
@@ -1851,8 +1848,7 @@ DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
 
 
 #if !FF_FS_READONLY
-static
-void st_clust (
+static void st_clust (
 	FATFS* fs,	/* Pointer to the fs object */
 	BYTE* dir,	/* Pointer to the key entry */
 	DWORD cl	/* Value to be set */
@@ -1871,8 +1867,8 @@ void st_clust (
 /*--------------------------------------------------------*/
 /* FAT-LFN: Compare a part of file name with an LFN entry */
 /*--------------------------------------------------------*/
-static
-int cmp_lfn (				/* 1:matched, 0:not matched */
+
+static int cmp_lfn (		/* 1:matched, 0:not matched */
 	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
 	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
 )
@@ -1888,7 +1884,7 @@ int cmp_lfn (				/* 1:matched, 0:not matched */
 	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 		if (wc != 0) {
-			if (i >= FF_MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
+			if (i >= FF_MAX_LFN + 1 || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
 				return 0;					/* Not matched */
 			}
 			wc = uc;
@@ -1907,8 +1903,8 @@ int cmp_lfn (				/* 1:matched, 0:not matched */
 /*-----------------------------------------------------*/
 /* FAT-LFN: Pick a part of file name from an LFN entry */
 /*-----------------------------------------------------*/
-static
-int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
+
+static int pick_lfn (	/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
 	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
 	BYTE* dir			/* Pointer to the LFN entry */
 )
@@ -1924,15 +1920,15 @@ int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
 	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
 		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
 		if (wc != 0) {
-			if (i >= FF_MAX_LFN) return 0;	/* Buffer overflow? */
+			if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
 			lfnbuf[i++] = wc = uc;			/* Store it */
 		} else {
 			if (uc != 0xFFFF) return 0;		/* Check filler */
 		}
 	}
 
-	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
-		if (i >= FF_MAX_LFN) return 0;		/* Buffer overflow? */
+	if (dir[LDIR_Ord] & LLEF && wc != 0) {	/* Put terminator if it is the last LFN part and not terminated */
+		if (i >= FF_MAX_LFN + 1) return 0;	/* Buffer overflow? */
 		lfnbuf[i] = 0;
 	}
 
@@ -1945,8 +1941,8 @@ int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
 /*-----------------------------------------*/
 /* FAT-LFN: Create an entry of LFN entries */
 /*-----------------------------------------*/
-static
-void put_lfn (
+
+static void put_lfn (
 	const WCHAR* lfn,	/* Pointer to the LFN */
 	BYTE* dir,			/* Pointer to the LFN entry to be created */
 	BYTE ord,			/* LFN order (1-20) */
@@ -1983,8 +1979,7 @@ void put_lfn (
 /* FAT-LFN: Create a Numbered SFN                                        */
 /*-----------------------------------------------------------------------*/
 
-static
-void gen_numname (
+static void gen_numname (
 	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
 	const BYTE* src,	/* Pointer to SFN */
 	const WCHAR* lfn,	/* Pointer to LFN */
@@ -2001,7 +1996,7 @@ void gen_numname (
 
 	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
 		sr = seq;
-		while (*lfn) {	/* Create a CRC */
+		while (*lfn) {	/* Create a CRC as hash value */
 			wc = *lfn++;
 			for (i = 0; i < 16; i++) {
 				sr = (sr << 1) + (wc & 1);
@@ -2042,8 +2037,7 @@ void gen_numname (
 /* FAT-LFN: Calculate checksum of an SFN entry                           */
 /*-----------------------------------------------------------------------*/
 
-static
-BYTE sum_sfn (
+static BYTE sum_sfn (
 	const BYTE* dir		/* Pointer to the SFN entry */
 )
 {
@@ -2065,8 +2059,7 @@ BYTE sum_sfn (
 /* exFAT: Checksum                                                       */
 /*-----------------------------------------------------------------------*/
 
-static
-WORD xdir_sum (			/* Get checksum of the directoly entry block */
+static WORD xdir_sum (	/* Get checksum of the directoly entry block */
 	const BYTE* dir		/* Directory entry block to be calculated */
 )
 {
@@ -2074,9 +2067,9 @@ WORD xdir_sum (			/* Get checksum of the directoly entry block */
 	WORD sum;
 
 
-	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
+	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;	/* Number of bytes of the entry block */
 	for (i = sum = 0; i < szblk; i++) {
-		if (i == XDIR_SetSum) {	/* Skip sum field */
+		if (i == XDIR_SetSum) {	/* Skip 2-byte sum field */
 			i++;
 		} else {
 			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
@@ -2087,8 +2080,7 @@ WORD xdir_sum (			/* Get checksum of the directoly entry block */
 
 
 
-static
-WORD xname_sum (		/* Get check sum (to be used as hash) of the name */
+static WORD xname_sum (	/* Get check sum (to be used as hash) of the file name */
 	const WCHAR* name	/* File name to be calculated */
 )
 {
@@ -2097,7 +2089,7 @@ WORD xname_sum (		/* Get check sum (to be used as hash) of the name */
 
 
 	while ((chr = *name++) != 0) {
-		chr = (WCHAR)ff_wtoupper(chr);		/* File name needs to be upper-case converted */
+		chr = (WCHAR)ff_wtoupper(chr);		/* File name needs to be up-case converted */
 		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
 		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
 	}
@@ -2106,10 +2098,9 @@ WORD xname_sum (		/* Get check sum (to be used as hash) of the name */
 
 
 #if !FF_FS_READONLY && FF_USE_MKFS
-static
-DWORD xsum32 (
-	BYTE  dat,	/* Byte to be calculated */
-	DWORD sum	/* Previous sum */
+static DWORD xsum32 (	/* Returns 32-bit checksum */
+	BYTE  dat,			/* Byte to be calculated (byte-by-byte processing) */
+	DWORD sum			/* Previous sum value */
 )
 {
 	sum = ((sum & 1) ? 0x80000000 : 0) + (sum >> 1) + dat;
@@ -2123,8 +2114,7 @@ DWORD xsum32 (
 /* exFAT: Get object information from a directory block */
 /*------------------------------------------------------*/
 
-static
-void get_xfileinfo (
+static void get_xfileinfo (
 	BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
 	FILINFO* fno		/* Buffer to store the extracted file information */
 )
@@ -2134,7 +2124,7 @@ void get_xfileinfo (
 
 	/* Get file name from the entry block */
 	si = SZDIRE * 2;	/* 1st C1 entry */
-	nc = hs = di = 0;
+	nc = 0; hs = 0; di = 0;
 	while (nc < dirb[XDIR_NumName]) {
 		if (si >= MAXDIRB(FF_MAX_LFN)) { di = 0; break; }	/* Truncated directory block? */
 		if ((si % SZDIRE) == 0) si += 2;		/* Skip entry type field */
@@ -2142,7 +2132,7 @@ void get_xfileinfo (
 		if (hs == 0 && IsSurrogate(wc)) {	/* Is it a surrogate? */
 			hs = wc; continue;	/* Get low surrogate */
 		}
-		wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in UTF-16 or UTF-8 encoding */
+		wc = put_utf((DWORD)hs << 16 | wc, &fno->fname[di], FF_LFN_BUF - di);	/* Store it in API encoding */
 		if (wc == 0) { di = 0; break; }	/* Buffer overflow or wrong encoding? */
 		di += wc;
 		hs = 0;
@@ -2150,7 +2140,7 @@ void get_xfileinfo (
 	if (hs != 0) di = 0;					/* Broken surrogate pair? */
 	if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object name? */
 	fno->fname[di] = 0;						/* Terminate the name */
-	fno->altname[0] = 0;					/* exFAT does not have SFN */
+	fno->altname[0] = 0;					/* exFAT does not support SFN */
 
 	fno->fattrib = dirb[XDIR_Attr];			/* Attribute */
 	fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
@@ -2165,9 +2155,8 @@ void get_xfileinfo (
 /* exFAT: Get a directry entry block */
 /*-----------------------------------*/
 
-static
-FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
-	FF_DIR* dp			/* Reading direcotry object pointing top of the entry block to load */
+static FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
+	FF_DIR* dp					/* Reading direcotry object pointing top of the entry block to load */
 )
 {
 	FRESULT res;
@@ -2175,33 +2164,33 @@ FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
 	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
 
 
-	/* Load 85 entry */
+	/* Load file-directory entry */
 	res = move_window(dp->obj.fs, dp->sect);
 	if (res != FR_OK) return res;
-	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;	/* Invalid order */
+	if (dp->dir[XDIR_Type] != ET_FILEDIR) return FR_INT_ERR;	/* Invalid order */
 	mem_cpy(dirb + 0 * SZDIRE, dp->dir, SZDIRE);
 	sz_ent = (dirb[XDIR_NumSec] + 1) * SZDIRE;
 	if (sz_ent < 3 * SZDIRE || sz_ent > 19 * SZDIRE) return FR_INT_ERR;
 
-	/* Load C0 entry */
+	/* Load stream-extension entry */
 	res = dir_next(dp, 0);
 	if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 	if (res != FR_OK) return res;
 	res = move_window(dp->obj.fs, dp->sect);
 	if (res != FR_OK) return res;
-	if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;	/* Invalid order */
+	if (dp->dir[XDIR_Type] != ET_STREAM) return FR_INT_ERR;	/* Invalid order */
 	mem_cpy(dirb + 1 * SZDIRE, dp->dir, SZDIRE);
 	if (MAXDIRB(dirb[XDIR_NumName]) > sz_ent) return FR_INT_ERR;
 
-	/* Load C1 entries */
-	i = 2 * SZDIRE;	/* C1 offset to load */
+	/* Load file-name entries */
+	i = 2 * SZDIRE;	/* Name offset to load */
 	do {
 		res = dir_next(dp, 0);
 		if (res == FR_NO_FILE) res = FR_INT_ERR;	/* It cannot be */
 		if (res != FR_OK) return res;
 		res = move_window(dp->obj.fs, dp->sect);
 		if (res != FR_OK) return res;
-		if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;	/* Invalid order */
+		if (dp->dir[XDIR_Type] != ET_FILENAME) return FR_INT_ERR;	/* Invalid order */
 		if (i < MAXDIRB(FF_MAX_LFN)) mem_cpy(dirb + i, dp->dir, SZDIRE);
 	} while ((i += SZDIRE) < sz_ent);
 
@@ -2217,8 +2206,7 @@ FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
 /* exFAT: Initialize object allocation info with loaded entry block */
 /*------------------------------------------------------------------*/
 
-static
-void init_alloc_info (
+static void init_alloc_info (
 	FATFS* fs,		/* Filesystem object */
 	FFOBJID* obj	/* Object allocation information to be initialized */
 )
@@ -2235,8 +2223,8 @@ void init_alloc_info (
 /*------------------------------------------------*/
 /* exFAT: Load the object's directory entry block */
 /*------------------------------------------------*/
-static
-FRESULT load_obj_xdir (
+
+static FRESULT load_obj_xdir (
 	FF_DIR* dp,			/* Blank directory object to be used to access containing direcotry */
 	const FFOBJID* obj	/* Object with its containing directory information */
 )
@@ -2264,8 +2252,8 @@ FRESULT load_obj_xdir (
 /*----------------------------------------*/
 /* exFAT: Store the directory entry block */
 /*----------------------------------------*/
-static
-FRESULT store_xdir (
+
+static FRESULT store_xdir (
 	FF_DIR* dp				/* Pointer to the direcotry object */
 )
 {
@@ -2297,8 +2285,7 @@ FRESULT store_xdir (
 /* exFAT: Create a new directory enrty block */
 /*-------------------------------------------*/
 
-static
-void create_xdir (
+static void create_xdir (
 	BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
 	const WCHAR* lfn	/* Pointer to the object name */
 )
@@ -2308,16 +2295,16 @@ void create_xdir (
 	WCHAR wc;
 
 
-	/* Create 85,C0 entry */
+	/* Create file-directory and stream-extension entry */
 	mem_set(dirb, 0, 2 * SZDIRE);
-	dirb[0 * SZDIRE + XDIR_Type] = 0x85;	/* 85 entry */
-	dirb[1 * SZDIRE + XDIR_Type] = 0xC0;	/* C0 entry */
+	dirb[0 * SZDIRE + XDIR_Type] = ET_FILEDIR;
+	dirb[1 * SZDIRE + XDIR_Type] = ET_STREAM;
 
-	/* Create C1 entries */
-	i = SZDIRE * 2;	/* Top of C1 entries */
+	/* Create file-name entries */
+	i = SZDIRE * 2;	/* Top of file_name entries */
 	nlen = nc1 = 0; wc = 1;
 	do {
-		dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
+		dirb[i++] = ET_FILENAME; dirb[i++] = 0;
 		do {	/* Fill name field */
 			if (wc != 0 && (wc = lfn[nlen]) != 0) nlen++;	/* Get a character if exist */
 			st_word(dirb + i, wc); 		/* Store it */
@@ -2341,18 +2328,17 @@ void create_xdir (
 /* Read an object from the directory                                     */
 /*-----------------------------------------------------------------------*/
 
-#define dir_read_file(dp) dir_read(dp, 0)
-#define dir_read_label(dp) dir_read(dp, 1)
+#define DIR_READ_FILE(dp) dir_read(dp, 0)
+#define DIR_READ_LABEL(dp) dir_read(dp, 1)
 
-static
-FRESULT dir_read (
+static FRESULT dir_read (
 	FF_DIR* dp,		/* Pointer to the directory object */
 	int vol			/* Filtered by 0:file/directory or 1:volume label */
 )
 {
 	FRESULT res = FR_NO_FILE;
 	FATFS *fs = dp->obj.fs;
-	BYTE a, c;
+	BYTE attr, b;
 #if FF_USE_LFN
 	BYTE ord = 0xFF, sum = 0xFF;
 #endif
@@ -2360,16 +2346,16 @@ FRESULT dir_read (
 	while (dp->sect) {
 		res = move_window(fs, dp->sect);
 		if (res != FR_OK) break;
-		c = dp->dir[DIR_Name];	/* Test for the entry type */
-		if (c == 0) {
+		b = dp->dir[DIR_Name];	/* Test for the entry type */
+		if (b == 0) {
 			res = FR_NO_FILE; break; /* Reached to end of the directory */
 		}
 #if FF_FS_EXFAT
 		if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 			if (FF_USE_LABEL && vol) {
-				if (c == 0x83) break;	/* Volume label entry? */
+				if (b == ET_VLABEL) break;	/* Volume label entry? */
 			} else {
-				if (c == 0x85) {		/* Start of the file entry block? */
+				if (b == ET_FILEDIR) {		/* Start of the file entry block? */
 					dp->blk_ofs = dp->dptr;	/* Get location of the block */
 					res = load_xdir(dp);	/* Load the entry block */
 					if (res == FR_OK) {
@@ -2381,19 +2367,19 @@ FRESULT dir_read (
 		} else
 #endif
 		{	/* On the FAT/FAT32 volume */
-			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
+			dp->obj.attr = attr = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 #if FF_USE_LFN		/* LFN configuration */
-			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
+			if (b == DDEM || b == '.' || (int)((attr & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
 				ord = 0xFF;
 			} else {
-				if (a == AM_LFN) {			/* An LFN entry is found */
-					if (c & LLEF) {			/* Is it start of an LFN sequence? */
+				if (attr == AM_LFN) {			/* An LFN entry is found */
+					if (b & LLEF) {			/* Is it start of an LFN sequence? */
 						sum = dp->dir[LDIR_Chksum];
-						c &= (BYTE)~LLEF; ord = c;
+						b &= (BYTE)~LLEF; ord = b;
 						dp->blk_ofs = dp->dptr;
 					}
 					/* Check LFN validity and capture it */
-					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
+					ord = (b == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(fs->lfnbuf, dp->dir)) ? ord - 1 : 0xFF;
 				} else {					/* An SFN entry is found */
 					if (ord != 0 || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
 						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
@@ -2402,7 +2388,7 @@ FRESULT dir_read (
 				}
 			}
 #else		/* Non LFN configuration */
-			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
+			if (b != DDEM && b != '.' && attr != AM_LFN && (int)((attr & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 				break;
 			}
 #endif
@@ -2423,9 +2409,8 @@ FRESULT dir_read (
 /* Directory handling - Find an object in the directory                  */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
-	FF_DIR* dp			/* Pointer to the directory object with the file name */
+static FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
+	FF_DIR* dp					/* Pointer to the directory object with the file name */
 )
 {
 	FRESULT res;
@@ -2443,7 +2428,7 @@ FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
 		UINT di, ni;
 		WORD hash = xname_sum(fs->lfnbuf);		/* Hash value of the name to find */
 
-		while ((res = dir_read_file(dp)) == FR_OK) {	/* Read an item */
+		while ((res = DIR_READ_FILE(dp)) == FR_OK) {	/* Read an item */
 #if FF_MAX_LFN < 255
 			if (fs->dirbuf[XDIR_NumName] > FF_MAX_LFN) continue;			/* Skip comparison if inaccessible object name */
 #endif
@@ -2505,9 +2490,8 @@ FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
 /* Register an object to the directory                                   */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
-	FF_DIR* dp				/* Target directory with object name to be created */
+static FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
+	FF_DIR* dp						/* Target directory with object name to be created */
 )
 {
 	FRESULT res;
@@ -2523,17 +2507,17 @@ FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many S
 #if FF_FS_EXFAT
 	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
-		res = dir_alloc(dp, nent);		/* Allocate entries */
+		res = dir_alloc(dp, nent);		/* Allocate directory entries */
 		if (res != FR_OK) return res;
 		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);	/* Set the allocated entry block offset */
 
-		if (dp->obj.stat & 4) {			/* Has the directory been stretched? */
+		if (dp->obj.stat & 4) {			/* Has the directory been stretched by new allocation? */
 			dp->obj.stat &= ~4;
 			res = fill_first_frag(&dp->obj);	/* Fill the first fragment on the FAT if needed */
 			if (res != FR_OK) return res;
 			res = fill_last_frag(&dp->obj, dp->clust, 0xFFFFFFFF);	/* Fill the last fragment on the FAT if needed */
 			if (res != FR_OK) return res;
-			if (dp->obj.sclust != 0) {		/* Is it a sub directory? */
+			if (dp->obj.sclust != 0) {		/* Is it a sub-directory? */
 				FF_DIR dj;
 
 				res = load_obj_xdir(&dj, &dp->obj);	/* Load the object status */
@@ -2612,9 +2596,8 @@ FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many S
 /* Remove an object from the directory                                   */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
-	FF_DIR* dp				/* Directory object pointing the entry to be removed */
+static FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
+	FF_DIR* dp					/* Directory object pointing the entry to be removed */
 )
 {
 	FRESULT res;
@@ -2659,14 +2642,14 @@ FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
 /* Get file information from directory entry                             */
 /*-----------------------------------------------------------------------*/
 
-static
-void get_fileinfo (
-	FF_DIR* dp,		/* Pointer to the directory object */
-	FILINFO* fno	/* Pointer to the file information to be filled */
+static void get_fileinfo (
+	FF_DIR* dp,			/* Pointer to the directory object */
+	FILINFO* fno		/* Pointer to the file information to be filled */
 )
 {
 	UINT si, di;
 #if FF_USE_LFN
+	BYTE lcf;
 	WCHAR wc, hs;
 	FATFS *fs = dp->obj.fs;
 #else
@@ -2714,7 +2697,7 @@ void get_fileinfo (
 		}
 		wc = ff_oem2uni(wc, CODEPAGE);		/* ANSI/OEM -> Unicode */
 		if (wc == 0) { di = 0; break; }		/* Wrong char in the current code page? */
-		wc = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);	/* Store it in UTF-16 or UTF-8 */
+		wc = put_utf(wc, &fno->altname[di], FF_SFN_BUF - di);	/* Store it in Unicode */
 		if (wc == 0) { di = 0; break; }		/* Buffer overflow? */
 		di += wc;
 #else					/* ANSI/OEM output */
@@ -2727,9 +2710,10 @@ void get_fileinfo (
 		if (di == 0) {	/* If LFN and SFN both are invalid, this object is inaccesible */
 			fno->fname[di++] = '?';
 		} else {
-			for (si = di = 0; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
+			for (si = di = 0, lcf = NS_BODY; fno->altname[si]; si++, di++) {	/* Copy altname[] to fname[] with case information */
 				wc = (WCHAR)fno->altname[si];
-				if (IsUpper(wc) && (dp->dir[DIR_NTres] & ((si >= 9) ? NS_EXT : NS_BODY))) wc += 0x20;
+				if (wc == '.') lcf = NS_EXT;
+				if (IsUpper(wc) && (dp->dir[DIR_NTres] & lcf)) wc += 0x20;
 				fno->fname[di] = (TCHAR)wc;
 			}
 		}
@@ -2764,9 +2748,8 @@ void get_fileinfo (
 /* Pattern matching                                                      */
 /*-----------------------------------------------------------------------*/
 
-static
-DWORD get_achar (		/* Get a character and advances ptr */
-	const TCHAR** ptr	/* Pointer to pointer to the ANSI/OEM or Unicode string */
+static DWORD get_achar (	/* Get a character and advances ptr */
+	const TCHAR** ptr		/* Pointer to pointer to the ANSI/OEM or Unicode string */
 )
 {
 	DWORD chr;
@@ -2796,8 +2779,7 @@ DWORD get_achar (		/* Get a character and advances ptr */
 }
 
 
-static
-int pattern_matching (	/* 0:not matched, 1:matched */
+static int pattern_matching (	/* 0:not matched, 1:matched */
 	const TCHAR* pat,	/* Matching pattern */
 	const TCHAR* nam,	/* String to be tested */
 	int skip,			/* Number of pre-skip chars (number of ?s) */
@@ -2844,10 +2826,9 @@ int pattern_matching (	/* 0:not matched, 1:matched */
 /* Pick a top segment and create the object name in directory form       */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
-	FF_DIR* dp,			/* Pointer to the directory object */
-	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
+static FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
+	FF_DIR* dp,					/* Pointer to the directory object */
+	const TCHAR** path			/* Pointer to pointer to the segment in the path string */
 )
 {
 #if FF_USE_LFN		/* LFN configuration */
@@ -3042,10 +3023,9 @@ FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
 /* Follow a file path                                                    */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
-	FF_DIR* dp,			/* Directory object to return last directory and found object */
-	const TCHAR* path	/* Full-path string to find a file or directory */
+static FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
+	FF_DIR* dp,					/* Directory object to return last directory and found object */
+	const TCHAR* path			/* Full-path string to find a file or directory */
 )
 {
 	FRESULT res;
@@ -3130,58 +3110,71 @@ FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
 /* Get logical drive number from path name                               */
 /*-----------------------------------------------------------------------*/
 
-static
-int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
-	const TCHAR** path	/* Pointer to pointer to the path name */
+static int get_ldnumber (	/* Returns logical drive number (-1:invalid drive number or null pointer) */
+	const TCHAR** path		/* Pointer to pointer to the path name */
 )
 {
 	const TCHAR *tp, *tt;
-	UINT i;
-	int vol = -1;
-#if FF_STR_VOLUME_ID		/* Find string drive id */
-	static const char* const volid[] = {FF_VOLUME_STRS};
+	TCHAR tc;
+	int i, vol = -1;
+#if FF_STR_VOLUME_ID		/* Find string volume ID */
 	const char *sp;
 	char c;
-	TCHAR tc;
 #endif
 
+	tt = tp = *path;
+	if (!tp) return vol;	/* Invalid path name? */
+	do tc = *tt++; while ((UINT)tc >= (FF_USE_LFN ? ' ' : '!') && tc != ':');	/* Find a colon in the path */
 
-	if (*path != 0) {	/* If the pointer is not a null */
-		for (tt = *path; (UINT)*tt >= (FF_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find a colon in the path */
-		if (*tt == ':') {	/* If a colon is exist in the path name */
-			tp = *path;
-			i = *tp++;
-			if (IsDigit(i) && tp == tt) {	/* Is there a numeric drive id + colon? */
-				if ((i -= '0') < FF_VOLUMES) {	/* If drive id is found, get the value and strip it */
-					vol = (int)i;
-					*path = ++tt;
-				}
-			}
-#if FF_STR_VOLUME_ID
-			 else {	/* No numeric drive number, find string drive id */
-				i = 0; tt++;
-				do {
-					sp = volid[i]; tp = *path;
-					do {	/* Compare a string drive id with path name */
-						c = *sp++; tc = *tp++;
-						if (IsLower(tc)) tc -= 0x20;
-					} while (c && (TCHAR)c == tc);
-				} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
-				if (i < FF_VOLUMES) {	/* If a drive id is found, get the value and strip it */
-					vol = (int)i;
-					*path = tt;
-				}
-			}
-#endif
-		} else {	/* No volume id and use default drive */
-#if FF_FS_RPATH != 0 && FF_VOLUMES >= 2
-			vol = CurrVol;	/* Current drive */
-#else
-			vol = 0;		/* Drive 0 */
+	if (tc == ':') {	/* DOS/Windows style volume ID? */
+		i = FF_VOLUMES;
+		if (IsDigit(*tp) && tp + 2 == tt) {	/* Is there a numeric volume ID + colon? */
+			i = (int)*tp - '0';	/* Get the LD number */
+		}
+#if FF_STR_VOLUME_ID == 1	/* Arbitrary string is enabled */
+		else {
+			i = 0;
+			do {
+				sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
+				do {	/* Compare the volume ID with path name */
+					c = *sp++; tc = *tp++;
+					if (IsLower(c)) c -= 0x20;
+					if (IsLower(tc)) tc -= 0x20;
+				} while (c && (TCHAR)c == tc);
+			} while ((c || tp != tt) && ++i < FF_VOLUMES);	/* Repeat for each id until pattern match */
+		}
 #endif
+		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
+			vol = i;		/* Drive number */
+			*path = tt;		/* Snip the drive prefix off */
 		}
+		return vol;
 	}
-	return vol;
+#if FF_STR_VOLUME_ID == 2		/* Unix style volume ID is enabled */
+	if (*tp == '/') {
+		i = 0;
+		do {
+			sp = VolumeStr[i]; tp = *path;	/* This string volume ID and path name */
+			do {	/* Compare the volume ID with path name */
+				c = *sp++; tc = *(++tp);
+				if (IsLower(c)) c -= 0x20;
+				if (IsLower(tc)) tc -= 0x20;
+			} while (c && (TCHAR)c == tc);
+		} while ((c || (tc != '/' && (UINT)tc >= (FF_USE_LFN ? ' ' : '!'))) && ++i < FF_VOLUMES);	/* Repeat for each ID until pattern match */
+		if (i < FF_VOLUMES) {	/* If a volume ID is found, get the drive number and strip it */
+			vol = i;		/* Drive number */
+			*path = tp;		/* Snip the drive prefix off */
+			return vol;
+		}
+	}
+#endif
+	/* No drive prefix is found */
+#if FF_FS_RPATH != 0
+	vol = CurrVol;	/* Default drive is current drive */
+#else
+	vol = 0;		/* Default drive is 0 */
+#endif
+	return vol;		/* Return the default drive */
 }
 
 
@@ -3191,16 +3184,15 @@ int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
 /* Load a sector and check if it is an FAT VBR                           */
 /*-----------------------------------------------------------------------*/
 
-static
-BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
-	FATFS* fs,	/* Filesystem object */
-	DWORD sect	/* Sector# (lba) to load and check if it is an FAT-VBR or not */
+static BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
+	FATFS* fs,			/* Filesystem object */
+	DWORD sect			/* Sector# (lba) to load and check if it is an FAT-VBR or not */
 )
 {
 	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 
-	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
+	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always here regardless of the sector size) */
 
 #if FF_FS_EXFAT
 	if (!mem_cmp(fs->win + BS_JmpBoot, "\xEB\x76\x90" "EXFAT   ", 11)) return 1;	/* Check if exFAT VBR */
@@ -3219,11 +3211,10 @@ BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk er
 /* Determine logical drive number and mount the volume if needed         */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
-	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
-	FATFS** rfs,		/* Pointer to pointer to the found filesystem object */
-	BYTE mode			/* !=0: Check write protection for write access */
+static FRESULT find_volume (	/* FR_OK(0): successful, !=0: an error occurred */
+	const TCHAR** path,			/* Pointer to pointer to the path name (drive number) */
+	FATFS** rfs,				/* Pointer to pointer to the found filesystem object */
+	BYTE mode					/* !=0: Check write protection for write access */
 )
 {
 	BYTE fmt, *pt;
@@ -3276,7 +3267,7 @@ FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
 	if (SS(fs) > FF_MAX_SS || SS(fs) < FF_MIN_SS || (SS(fs) & (SS(fs) - 1))) return FR_DISK_ERR;
 #endif
 
-	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK and SFD. */
+	/* Find an FAT partition on the drive. Supports only generic partitioning rules, FDISK (MBR) and SFD (w/o partition). */
 	bsect = 0;
 	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
@@ -3299,6 +3290,7 @@ FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
 #if FF_FS_EXFAT
 	if (fmt == 1) {
 		QWORD maxlba;
+		DWORD so, cv, bcl;
 
 		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && fs->win[i] == 0; i++) ;	/* Check zero filler */
 		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
@@ -3331,12 +3323,27 @@ FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
 		if (maxlba < (QWORD)fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
 		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
 
-		/* Check if bitmap location is in assumption (at the first cluster) */
-		if (move_window(fs, clst2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
-		for (i = 0; i < SS(fs); i += SZDIRE) {
-			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
+		/* Get bitmap location and check if it is contiguous (implementation assumption) */
+		so = i = 0;
+		for (;;) {	/* Find the bitmap entry in the root directory (in only first cluster) */
+			if (i == 0) {
+				if (so >= fs->csize) return FR_NO_FILESYSTEM;	/* Not found? */
+				if (move_window(fs, clst2sect(fs, fs->dirbase) + so) != FR_OK) return FR_DISK_ERR;
+				so++;
+			}
+			if (fs->win[i] == ET_BITMAP) break;				/* Is it a bitmap entry? */
+			i = (i + SZDIRE) % SS(fs);	/* Next entry */
+		}
+		bcl = ld_dword(fs->win + i + 20);					/* Bitmap cluster */
+		if (bcl < 2 || bcl >= fs->n_fatent) return FR_NO_FILESYSTEM;
+		fs->bitbase = fs->database + fs->csize * (bcl - 2);	/* Bitmap sector */
+		for (;;) {	/* Check if bitmap is contiguous */
+			if (move_window(fs, fs->fatbase + bcl / (SS(fs) / 4)) != FR_OK) return FR_DISK_ERR;
+			cv = ld_dword(fs->win + bcl % (SS(fs) / 4) * 4);
+			if (cv == 0xFFFFFFFF) break;				/* Last link? */
+			if (cv != ++bcl) return FR_NO_FILESYSTEM;	/* Fragmented? */
 		}
-		if (i == SS(fs)) return FR_NO_FILESYSTEM;
+
 #if !FF_FS_READONLY
 		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 #endif
@@ -3367,7 +3374,7 @@ FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
 		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 
 		/* Determine the FAT sub type */
-		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
+		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + FF_DIR */
 		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
@@ -3445,10 +3452,9 @@ FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
 /* Check if the file/directory object is valid or not                    */
 /*-----------------------------------------------------------------------*/
 
-static
-FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
-	FFOBJID* obj,	/* Pointer to the FFOBJID, the 1st member in the FIL/DIR object, to check validity */
-	FATFS** rfs		/* Pointer to pointer to the owner filesystem object to return */
+static FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
+	FFOBJID* obj,			/* Pointer to the FFOBJID, the 1st member in the FIL/FF_DIR object, to check validity */
+	FATFS** rfs				/* Pointer to pointer to the owner filesystem object to return */
 )
 {
 	FRESULT res = FR_INVALID_OBJECT;
@@ -3556,7 +3562,7 @@ FRESULT f_open (
 
 	if (!fp) return FR_INVALID_OBJECT;
 
-	/* Get logical drive */
+	/* Get logical drive number */
 	mode &= FF_FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND;
 	res = find_volume(&path, &fs, mode);
 	if (res == FR_OK) {
@@ -3587,7 +3593,7 @@ FRESULT f_open (
 				mode |= FA_CREATE_ALWAYS;		/* File is created */
 			}
 			else {								/* Any object with the same name is already existing */
-				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
+				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or FF_DIR) */
 					res = FR_DENIED;
 				} else {
 					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
@@ -3687,7 +3693,7 @@ FRESULT f_open (
 			fp->fptr = 0;			/* Set file pointer top of the file */
 #if !FF_FS_READONLY
 #if !FF_FS_TINY
-			mem_set(fp->buf, 0, FF_MAX_SS);	/* Clear sector buffer */
+			mem_set(fp->buf, 0, sizeof fp->buf);	/* Clear sector buffer */
 #endif
 			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 				fp->fptr = fp->obj.objsize;			/* Offset to seek */
@@ -3750,7 +3756,7 @@ FRESULT f_read (
 	remain = fp->obj.objsize - fp->fptr;
 	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
 
-	for ( ;  btr;								/* Repeat until all data read */
+	for ( ;  btr;								/* Repeat until btr bytes read */
 		btr -= rcnt, *br += rcnt, rbuff += rcnt, fp->fptr += rcnt) {
 		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
@@ -4066,9 +4072,8 @@ FRESULT f_close (
 /* Change Current Directory or Current Drive, Get Current Directory      */
 /*-----------------------------------------------------------------------*/
 
-#if FF_VOLUMES >= 2
 FRESULT f_chdrive (
-	const TCHAR* path		/* Drive number */
+	const TCHAR* path		/* Drive number to set */
 )
 {
 	int vol;
@@ -4077,23 +4082,26 @@ FRESULT f_chdrive (
 	/* Get logical drive number */
 	vol = get_ldnumber(&path);
 	if (vol < 0) return FR_INVALID_DRIVE;
-
 	CurrVol = (BYTE)vol;	/* Set it as current volume */
 
 	return FR_OK;
 }
-#endif
+
 
 
 FRESULT f_chdir (
 	const TCHAR* path	/* Pointer to the directory path */
 )
 {
+#if FF_STR_VOLUME_ID == 2
+	UINT i;
+#endif
 	FRESULT res;
 	FF_DIR dj;
 	FATFS *fs;
 	DEF_NAMBUF
 
+
 	/* Get logical drive */
 	res = find_volume(&path, &fs, 0);
 	if (res == FR_OK) {
@@ -4101,8 +4109,8 @@ FRESULT f_chdir (
 		INIT_NAMBUF(fs);
 		res = follow_path(&dj, path);		/* Follow the path */
 		if (res == FR_OK) {					/* Follow completed */
-			if (dj.fn[NSFLAG] & NS_NONAME) {
-				fs->cdir = dj.obj.sclust;	/* It is the start directory itself */
+			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Is it the start directory itself? */
+				fs->cdir = dj.obj.sclust;
 #if FF_FS_EXFAT
 				if (fs->fs_type == FS_EXFAT) {
 					fs->cdc_scl = dj.obj.c_scl;
@@ -4130,6 +4138,12 @@ FRESULT f_chdir (
 		}
 		FREE_NAMBUF();
 		if (res == FR_NO_FILE) res = FR_NO_PATH;
+#if FF_STR_VOLUME_ID == 2	/* Also current drive is changed at Unix style volume ID */
+		if (res == FR_OK) {
+			for (i = FF_VOLUMES - 1; i && fs != FatFs[i]; i--) ;	/* Set current drive */
+			CurrVol = (BYTE)i;
+		}
+#endif
 	}
 
 	LEAVE_FF(fs, res);
@@ -4139,7 +4153,7 @@ FRESULT f_chdir (
 #if FF_FS_RPATH >= 2
 FRESULT f_getcwd (
 	TCHAR* buff,	/* Pointer to the directory path */
-	UINT len		/* Size of path */
+	UINT len		/* Size of buff in unit of TCHAR */
 )
 {
 	FRESULT res;
@@ -4147,17 +4161,25 @@ FRESULT f_getcwd (
 	FATFS *fs;
 	UINT i, n;
 	DWORD ccl;
-	TCHAR *tp;
+	TCHAR *tp = buff;
+#if FF_VOLUMES >= 2
+	UINT vl;
+#if FF_STR_VOLUME_ID
+	const char *vp;
+#endif
+#endif
 	FILINFO fno;
 	DEF_NAMBUF
 
 
-	*buff = 0;
 	/* Get logical drive */
+	buff[0] = 0;	/* Set null string to get current volume */
 	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
 	if (res == FR_OK) {
 		dj.obj.fs = fs;
 		INIT_NAMBUF(fs);
+
+		/* Follow parent directories and create the path */
 		i = len;			/* Bottom of buffer (directory stack base) */
 		if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
 			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
@@ -4170,7 +4192,7 @@ FRESULT f_getcwd (
 				res = dir_sdi(&dj, 0);
 				if (res != FR_OK) break;
 				do {							/* Find the entry links to the child directory */
-					res = dir_read_file(&dj);
+					res = DIR_READ_FILE(&dj);
 					if (res != FR_OK) break;
 					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
 					res = dir_next(&dj, 0);
@@ -4178,32 +4200,44 @@ FRESULT f_getcwd (
 				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
 				if (res != FR_OK) break;
 				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
-				for (n = 0; fno.fname[n]; n++) ;
-				if (i < n + 3) {
+				for (n = 0; fno.fname[n]; n++) ;	/* Name length */
+				if (i < n + 1) {	/* Insufficient space to store the path name? */
 					res = FR_NOT_ENOUGH_CORE; break;
 				}
-				while (n) buff[--i] = fno.fname[--n];
+				while (n) buff[--i] = fno.fname[--n];	/* Stack the name */
 				buff[--i] = '/';
 			}
 		}
-		tp = buff;
 		if (res == FR_OK) {
-#if FF_VOLUMES >= 2
-			*tp++ = '0' + CurrVol;			/* Put drive number */
-			*tp++ = ':';
-#endif
-			if (i == len) {					/* Root-directory */
-				*tp++ = '/';
-			} else {						/* Sub-directroy */
-				do		/* Add stacked path str */
-					*tp++ = buff[i++];
-				while (i < len);
+			if (i == len) buff[--i] = '/';	/* Is it the root-directory? */
+#if FF_VOLUMES >= 2			/* Put drive prefix */
+			vl = 0;
+#if FF_STR_VOLUME_ID >= 1	/* String volume ID */
+			for (n = 0, vp = (const char*)VolumeStr[CurrVol]; vp[n]; n++) ;
+			if (i >= n + 2) {
+				if (FF_STR_VOLUME_ID == 2) *tp++ = (TCHAR)'/';
+				for (vl = 0; vl < n; *tp++ = (TCHAR)vp[vl], vl++) ;
+				if (FF_STR_VOLUME_ID == 1) *tp++ = (TCHAR)':';
+				vl++;
+			}
+#else						/* Numeric volume ID */
+			if (i >= 3) {
+				*tp++ = (TCHAR)'0' + CurrVol;
+				*tp++ = (TCHAR)':';
+				vl = 2;
+			}
+#endif
+			if (vl == 0) res = FR_NOT_ENOUGH_CORE;
+#endif
+			/* Add current directory path */
+			if (res == FR_OK) {
+				do *tp++ = buff[i++]; while (i < len);	/* Copy stacked path string */
 			}
 		}
-		*tp = 0;
 		FREE_NAMBUF();
 	}
 
+	*tp = 0;
 	LEAVE_FF(fs, res);
 }
 
@@ -4490,7 +4524,7 @@ FRESULT f_readdir (
 			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 		} else {
 			INIT_NAMBUF(fs);
-			res = dir_read_file(dp);		/* Read an item */
+			res = DIR_READ_FILE(dp);		/* Read an item */
 			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
 			if (res == FR_OK) {				/* A valid entry is found */
 				get_fileinfo(dp, fno);		/* Get the object information */
@@ -4635,7 +4669,7 @@ FRESULT f_getfree (
 					UINT b;
 
 					clst = fs->n_fatent - 2;	/* Number of clusters */
-					sect = fs->database;		/* Assuming bitmap starts at cluster 2 */
+					sect = fs->bitbase;			/* Bitmap sector */
 					i = 0;						/* Offset in the sector */
 					do {	/* Counts numbuer of bits with zero in the bitmap */
 						if (i == 0) {
@@ -4694,6 +4728,7 @@ FRESULT f_truncate (
 	FATFS *fs;
 	DWORD ncl;
 
+
 	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);
 	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
@@ -4797,7 +4832,7 @@ FRESULT f_unlink (
 #endif
 						res = dir_sdi(&sdj, 0);
 						if (res == FR_OK) {
-							res = dir_read_file(&sdj);			/* Test if the directory is empty */
+							res = DIR_READ_FILE(&sdj);			/* Test if the directory is empty */
 							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 						}
@@ -4835,73 +4870,69 @@ FRESULT f_mkdir (
 {
 	FRESULT res;
 	FF_DIR dj;
+	FFOBJID sobj;
 	FATFS *fs;
-	BYTE *dir;
 	DWORD dcl, pcl, tm;
 	DEF_NAMBUF
 
 
-	/* Get logical drive */
-	res = find_volume(&path, &fs, FA_WRITE);
+	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
 	if (res == FR_OK) {
 		dj.obj.fs = fs;
 		INIT_NAMBUF(fs);
 		res = follow_path(&dj, path);			/* Follow the file path */
-		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
-		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
+		if (res == FR_OK) res = FR_EXIST;		/* Name collision? */
+		if (FF_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {	/* Invalid name? */
 			res = FR_INVALID_NAME;
 		}
-		if (res == FR_NO_FILE) {				/* Can create a new directory */
-			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
-			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
+		if (res == FR_NO_FILE) {				/* It is clear to create a new directory */
+			sobj.fs = fs;						/* New object id to create a new chain */
+			dcl = create_chain(&sobj, 0);		/* Allocate a cluster for the new directory */
 			res = FR_OK;
-			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
-			if (dcl == 1) res = FR_INT_ERR;
-			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
-			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
+			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster? */
+			if (dcl == 1) res = FR_INT_ERR;		/* Any insanity? */
+			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;	/* Disk error? */
 			tm = GET_FATTIME();
-			if (res == FR_OK) {					/* Initialize the new directory table */
+			if (res == FR_OK) {
 				res = dir_clear(fs, dcl);		/* Clean up the new table */
-				if (res == FR_OK && (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT)) {	/* Create dot entries (FAT only) */
-					dir = fs->win;
-					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
-					dir[DIR_Name] = '.';
-					dir[DIR_Attr] = AM_DIR;
-					st_dword(dir + DIR_ModTime, tm);
-					st_clust(fs, dir, dcl);
-					mem_cpy(dir + SZDIRE, dir, SZDIRE); /* Create ".." entry */
-					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
-					st_clust(fs, dir + SZDIRE, pcl);
-					fs->wflag = 1;
+				if (res == FR_OK) {
+					if (!FF_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* Create dot entries (FAT only) */
+						mem_set(fs->win + DIR_Name, ' ', 11);	/* Create "." entry */
+						fs->win[DIR_Name] = '.';
+						fs->win[DIR_Attr] = AM_DIR;
+						st_dword(fs->win + DIR_ModTime, tm);
+						st_clust(fs, fs->win, dcl);
+						mem_cpy(fs->win + SZDIRE, fs->win, SZDIRE); /* Create ".." entry */
+						fs->win[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
+						st_clust(fs, fs->win + SZDIRE, pcl);
+						fs->wflag = 1;
+					}
+					res = dir_register(&dj);	/* Register the object to the parent directoy */
 				}
 			}
 			if (res == FR_OK) {
-				res = dir_register(&dj);	/* Register the object to the directoy */
-			}
-			if (res == FR_OK) {
 #if FF_FS_EXFAT
 				if (fs->fs_type == FS_EXFAT) {	/* Initialize directory entry block */
 					st_dword(fs->dirbuf + XDIR_ModTime, tm);	/* Created time */
 					st_dword(fs->dirbuf + XDIR_FstClus, dcl);	/* Table start cluster */
-					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);	/* File size needs to be valid */
-					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
+					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)fs->csize * SS(fs));	/* File size needs to be valid */
+					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)fs->csize * SS(fs));
 					fs->dirbuf[XDIR_GenFlags] = 3;				/* Initialize the object flag */
 					fs->dirbuf[XDIR_Attr] = AM_DIR;				/* Attribute */
 					res = store_xdir(&dj);
 				} else
 #endif
 				{
-					dir = dj.dir;
-					st_dword(dir + DIR_ModTime, tm);	/* Created time */
-					st_clust(fs, dir, dcl);				/* Table start cluster */
-					dir[DIR_Attr] = AM_DIR;				/* Attribute */
+					st_dword(dj.dir + DIR_ModTime, tm);	/* Created time */
+					st_clust(fs, dj.dir, dcl);			/* Table start cluster */
+					dj.dir[DIR_Attr] = AM_DIR;			/* Attribute */
 					fs->wflag = 1;
 				}
 				if (res == FR_OK) {
 					res = sync_fs(fs);
 				}
 			} else {
-				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
+				remove_chain(&sobj, dcl, 0);		/* Could not register, remove the allocated cluster */
 			}
 		}
 		FREE_NAMBUF();
@@ -5141,7 +5172,7 @@ FRESULT f_getlabel (
 		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 		res = dir_sdi(&dj, 0);
 		if (res == FR_OK) {
-		 	res = dir_read_label(&dj);		/* Find a volume label entry */
+		 	res = DIR_READ_LABEL(&dj);		/* Find a volume label entry */
 		 	if (res == FR_OK) {
 #if FF_FS_EXFAT
 				if (fs->fs_type == FS_EXFAT) {
@@ -5167,8 +5198,8 @@ FRESULT f_getlabel (
 						wc = dj.dir[si++];
 #if FF_USE_LFN && FF_LFN_UNICODE >= 1 	/* Unicode output */
 						if (dbc_1st((BYTE)wc) && si < 11) wc = wc << 8 | dj.dir[si++];	/* Is it a DBC? */
-						wc = ff_oem2uni(wc, CODEPAGE);
-						if (wc != 0) wc = put_utf(wc, &label[di], 4);
+						wc = ff_oem2uni(wc, CODEPAGE);					/* Convert it into Unicode */
+						if (wc != 0) wc = put_utf(wc, &label[di], 4);	/* Put it in Unicode */
 						if (wc == 0) { di = 0; break; }
 						di += wc;
 #else									/* ANSI/OEM output */
@@ -5226,7 +5257,7 @@ FRESULT f_setlabel (
 	BYTE dirvn[22];
 	UINT di;
 	WCHAR wc;
-	static const char badchr[] = "+.,;=[]\"*:<>\?|\x7F";	/* [0..] for FAT, [7..] for exFAT */
+	static const char badchr[] = "+.,;=[]/\\\"*:<>\?|\x7F";	/* [0..] for FAT, [7..] for exFAT */
 #if FF_USE_LFN
 	DWORD dc;
 #endif
@@ -5239,7 +5270,7 @@ FRESULT f_setlabel (
 	if (fs->fs_type == FS_EXFAT) {	/* On the exFAT volume */
 		mem_set(dirvn, 0, 22);
 		di = 0;
-		while (*label) {	/* Create volume label in directory form */
+		while ((UINT)*label >= ' ') {	/* Create volume label */
 			dc = tchar2uni(&label);	/* Get a Unicode character */
 			if (dc >= 0x10000) {
 				if (dc == 0xFFFFFFFF || di >= 10) {	/* Wrong surrogate or buffer overflow */
@@ -5258,7 +5289,7 @@ FRESULT f_setlabel (
 	{	/* On the FAT/FAT32 volume */
 		mem_set(dirvn, ' ', 11);
 		di = 0;
-		while (*label) {	/* Create volume label in directory form */
+		while ((UINT)*label >= ' ') {	/* Create volume label */
 #if FF_USE_LFN
 			dc = tchar2uni(&label);
 			wc = (dc < 0x10000) ? ff_uni2oem(ff_wtoupper(dc), CODEPAGE) : 0;
@@ -5286,7 +5317,7 @@ FRESULT f_setlabel (
 	dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
 	res = dir_sdi(&dj, 0);
 	if (res == FR_OK) {
-		res = dir_read_label(&dj);	/* Get volume label entry */
+		res = DIR_READ_LABEL(&dj);	/* Get volume label entry */
 		if (res == FR_OK) {
 			if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
 				dj.dir[XDIR_NumLabel] = (BYTE)di;	/* Change the volume label */
@@ -5308,7 +5339,7 @@ FRESULT f_setlabel (
 					if (res == FR_OK) {
 						mem_set(dj.dir, 0, SZDIRE);	/* Clean the entry */
 						if (FF_FS_EXFAT && fs->fs_type == FS_EXFAT) {
-							dj.dir[XDIR_Type] = 0x83;		/* Create 83 entry */
+							dj.dir[XDIR_Type] = ET_VLABEL;	/* Create volume label entry */
 							dj.dir[XDIR_NumLabel] = (BYTE)di;
 							mem_cpy(dj.dir + XDIR_Label, dirvn, 22);
 						} else {
@@ -5546,7 +5577,7 @@ FRESULT f_mkfs (
 	/* Get working buffer */
 #if FF_USE_LFN == 3
 	if (!work) {	/* Use heap memory for working buffer */
-		for (szb_buf = MAX_MALLOC, buf = 0; szb_buf >= ss && !(buf = ff_memalloc(szb_buf)); szb_buf /= 2) ;
+		for (szb_buf = MAX_MALLOC, buf = 0; szb_buf >= ss && (buf = ff_memalloc(szb_buf)) == 0; szb_buf /= 2) ;
 		sz_buf = szb_buf / ss;		/* Size of working buffer (sector) */
 	} else
 #endif
@@ -5613,7 +5644,7 @@ FRESULT f_mkfs (
 		b_fat = b_vol + 32;										/* FAT start at offset 32 */
 		sz_fat = ((sz_vol / au + 2) * 4 + ss - 1) / ss;			/* Number of FAT sectors */
 		b_data = (b_fat + sz_fat + sz_blk - 1) & ~(sz_blk - 1);	/* Align data area to the erase block boundary */
-		if (b_data >= sz_vol / 2) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume? */
+		if (b_data - b_vol >= sz_vol / 2) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too small volume? */
 		n_clst = (sz_vol - (b_data - b_vol)) / au;				/* Number of clusters */
 		if (n_clst <16) LEAVE_MKFS(FR_MKFS_ABORTED);			/* Too few clusters? */
 		if (n_clst > MAX_EXFAT) LEAVE_MKFS(FR_MKFS_ABORTED);	/* Too many clusters? */
@@ -5624,7 +5655,7 @@ FRESULT f_mkfs (
 		/* Create a compressed up-case table */
 		sect = b_data + au * tbl[0];	/* Table start sector */
 		sum = 0;						/* Table checksum to be stored in the 82 entry */
-		st = si = i = j = szb_case = 0;
+		st = 0; si = 0; i = 0; j = 0; szb_case = 0;
 		do {
 			switch (st) {
 			case 0:
@@ -5644,7 +5675,7 @@ FRESULT f_mkfs (
 				break;
 
 			default:
-				ch = (WCHAR)j; si += j;	/* Number of chars to skip */
+				ch = (WCHAR)j; si += (WCHAR)j;	/* Number of chars to skip */
 				st = 0;
 			}
 			sum = xsum32(buf[i + 0] = (BYTE)ch, sum);		/* Put it into the write buffer */
@@ -5694,14 +5725,14 @@ FRESULT f_mkfs (
 
 		/* Initialize the root directory */
 		mem_set(buf, 0, szb_buf);
-		buf[SZDIRE * 0 + 0] = 0x83;		/* 83 entry (volume label) */
-		buf[SZDIRE * 1 + 0] = 0x81;		/* 81 entry (allocation bitmap) */
-		st_dword(buf + SZDIRE * 1 + 20, 2);
-		st_dword(buf + SZDIRE * 1 + 24, szb_bit);
-		buf[SZDIRE * 2 + 0] = 0x82;		/* 82 entry (up-case table) */
-		st_dword(buf + SZDIRE * 2 + 4, sum);
-		st_dword(buf + SZDIRE * 2 + 20, 2 + tbl[0]);
-		st_dword(buf + SZDIRE * 2 + 24, szb_case);
+		buf[SZDIRE * 0 + 0] = ET_VLABEL;		/* Volume label entry */
+		buf[SZDIRE * 1 + 0] = ET_BITMAP;		/* Bitmap entry */
+		st_dword(buf + SZDIRE * 1 + 20, 2);				/* cluster */
+		st_dword(buf + SZDIRE * 1 + 24, szb_bit);		/* size */
+		buf[SZDIRE * 2 + 0] = ET_UPCASE;		/* Up-case table entry */
+		st_dword(buf + SZDIRE * 2 + 4, sum);			/* sum */
+		st_dword(buf + SZDIRE * 2 + 20, 2 + tbl[0]);	/* cluster */
+		st_dword(buf + SZDIRE * 2 + 24, szb_case);		/* size */
 		sect = b_data + au * (tbl[0] + tbl[1]);	nsect = au;	/* Start of the root directory and number of sectors */
 		do {	/* Fill root directory sectors */
 			n = (nsect > sz_buf) ? sz_buf : nsect;
@@ -5991,8 +6022,7 @@ FRESULT f_fdisk (
 	if (!buf) return FR_NOT_ENOUGH_CORE;
 
 	/* Determine the CHS without any consideration of the drive geometry */
-	for (n = 16; n < 256 && sz_disk / n / cluster_size > 1024; n *= 2)
-	{
+	for (n = 16; n < 256 && sz_disk / n / cluster_size > 1024; n *= 2) {
 		;
 	}
 	if (n == 256) n--;
@@ -6027,7 +6057,7 @@ FRESULT f_fdisk (
 		p[3] = (BYTE)b_cyl;					/* Start cylinder */
 		p[4] = 0x07;						/* System type (temporary setting) */
 		p[5] = e_hd;						/* End head */
-		p[6] = (BYTE)(((e_cyl >> 2) & 0xC0) | 63);	/* End sector */
+		p[6] = (BYTE)(((e_cyl >> 2) & 0xC0) | cluster_size);	/* End sector */
 		p[7] = (BYTE)e_cyl;					/* End cylinder */
 		st_dword(p + 8, s_part);			/* Start sector in LBA */
 		st_dword(p + 12, sz_part);			/* Number of sectors */
@@ -6064,68 +6094,22 @@ TCHAR* f_gets (
 {
 	int nc = 0;
 	TCHAR *p = buff;
-	BYTE s[2];
+	BYTE s[4];
 	UINT rc;
-	WCHAR wc;
-#if FF_USE_LFN && ((FF_LFN_UNICODE == 1 && FF_STRF_ENCODE == 3) || (FF_LFN_UNICODE == 2 && FF_STRF_ENCODE != 3))
 	DWORD dc;
+#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCODE <= 2
+	WCHAR wc;
 #endif
-#if FF_USE_LFN && FF_LFN_UNICODE == 1 && FF_STRF_ENCODE == 3
+#if FF_USE_LFN && FF_LFN_UNICODE && FF_STRF_ENCODE == 3
 	UINT ct;
 #endif
 
-#if FF_USE_LFN && FF_LFN_UNICODE == 1	/* UTF-16 output */
-#if FF_STRF_ENCODE == 0		/* Read a character in ANSI/OEM */
-	while (nc < len - 1) {
-		f_read(fp, s, 1, &rc);
-		if (rc != 1) break;
-		wc = s[0];
-		if (dbc_1st((BYTE)wc)) {
-			f_read(fp, s, 1, &rc);
-			if (rc != 1 || !dbc_2nd(s[0])) continue;
-			wc = wc << 8 | s[0];
-		}
-		wc = ff_oem2uni(wc, CODEPAGE);
-		if (wc == 0) continue;
-#elif FF_STRF_ENCODE == 1 || FF_STRF_ENCODE == 2	/* Read a character in UTF-16LE/BE */
-	while (nc < len - 1) {
-		f_read(fp, s, 2, &rc);
-		if (rc != 2) break;
-		wc = (FF_STRF_ENCODE == 1) ? s[1] << 8 | s[0] : s[0] << 8 | s[1];
-#elif FF_STRF_ENCODE == 3		/* Read a character in UTF-8 */
-	while (nc < len - 2) {
-		f_read(fp, s, 1, &rc);
-		if (rc != 1) break;
-		dc = s[0];
-		if (dc >= 0x80) {
-			ct = 0;
-			if ((dc & 0xE0) == 0xC0) { dc &= 0x1F; ct = 1; }
-			if ((dc & 0xF0) == 0xE0) { dc &= 0x0F; ct = 2; }
-			if ((dc & 0xF8) == 0xF0) { dc &= 0x07; ct = 3; }
-			if (ct == 0) continue;
-			do {
-				f_read(fp, s, 1, &rc);
-				if (rc != 1 || (s[0] & 0xC0) != 0x80) break;
-				dc = dc << 6 | (s[0] & 0x3F);
-			} while (--ct);
-			if (ct || dc < 0x80 || dc >= 0x110000) continue;
-		}
-		if (dc >= 0x10000) {
-			wc = (WCHAR)(0xD800 | ((dc >> 10) - 0x40));
-			*p++ = wc; nc++;
-			wc = (WCHAR)(0xDC00 | (dc & 0x3FF));
-		} else {
-			wc = (WCHAR)dc;
-		}
-#endif
-		/* Output it in UTF-16 encoding */
-		if (FF_USE_STRFUNC == 2 && wc == '\r') continue;
-		*p++ = wc; nc++;
-		if (wc == '\n') break;
-	}
-
-#elif FF_USE_LFN && FF_LFN_UNICODE == 2	&& FF_STRF_ENCODE != 3	/* UTF-8 output */
-	while (nc < len - 4) {
+#if FF_USE_LFN && FF_LFN_UNICODE			/* With code conversion (Unicode API) */
+	/* Make a room for the character and terminator  */
+	if (FF_LFN_UNICODE == 1) len -= (FF_STRF_ENCODE == 0) ? 1 : 2;
+	if (FF_LFN_UNICODE == 2) len -= (FF_STRF_ENCODE == 0) ? 3 : 4;
+	if (FF_LFN_UNICODE == 3) len -= 1;
+	while (nc < len) {
 #if FF_STRF_ENCODE == 0		/* Read a character in ANSI/OEM */
 		f_read(fp, s, 1, &rc);
 		if (rc != 1) break;
@@ -6137,26 +6121,53 @@ TCHAR* f_gets (
 		}
 		dc = ff_oem2uni(wc, CODEPAGE);
 		if (dc == 0) continue;
-#else 						/* Read a character in UTF-16LE/BE */
+#elif FF_STRF_ENCODE == 1 || FF_STRF_ENCODE == 2 	/* Read a character in UTF-16LE/BE */
 		f_read(fp, s, 2, &rc);
 		if (rc != 2) break;
-		dc = (FF_STRF_ENCODE == 1) ? s[1] << 8 | s[0] : s[0] << 8 | s[1];
-		if (IsSurrogate(dc)) {
+		dc = (FF_STRF_ENCODE == 1) ? ld_word(s) : s[0] << 8 | s[1];
+		if (IsSurrogateL(dc)) continue;
+		if (IsSurrogateH(dc)) {
 			f_read(fp, s, 2, &rc);
 			if (rc != 2) break;
-			wc = (FF_STRF_ENCODE == 1) ? s[1] << 8 | s[0] : s[0] << 8 | s[1];
-			if (!IsSurrogateH(dc) || !IsSurrogateL(wc)) continue;
+			wc = (FF_STRF_ENCODE == 1) ? ld_word(s) : s[0] << 8 | s[1];
+			if (!IsSurrogateL(wc)) continue;
 			dc = ((dc & 0x3FF) + 0x40) << 10 | (wc & 0x3FF);
 		}
-#endif
-		/* Output it in UTF-8 encoding */
-		if (FF_USE_STRFUNC == 2 && dc == '\r') continue;
+#else	/* Read a character in UTF-8 */
+		f_read(fp, s, 1, &rc);
+		if (rc != 1) break;
+		dc = s[0];
+		if (dc >= 0x80) {	/* Multi-byte character? */
+			ct = 0;
+			if ((dc & 0xE0) == 0xC0) { dc &= 0x1F; ct = 1; }	/* 2-byte? */
+			if ((dc & 0xF0) == 0xE0) { dc &= 0x0F; ct = 2; }	/* 3-byte? */
+			if ((dc & 0xF8) == 0xF0) { dc &= 0x07; ct = 3; }	/* 4-byte? */
+			if (ct == 0) continue;
+			f_read(fp, s, ct, &rc);		/* Get trailing bytes */
+			if (rc != ct) break;
+			rc = 0;
+			do {	/* Merge trailing bytes */
+				if ((s[rc] & 0xC0) != 0x80) break;
+				dc = dc << 6 | (s[rc] & 0x3F);
+			} while (++rc < ct);
+			if (rc != ct || dc < 0x80 || IsSurrogate(dc) || dc >= 0x110000) continue;	/* Wrong encoding? */
+		}
+#endif
+		if (FF_USE_STRFUNC == 2 && dc == '\r') continue;	/* Strip \r off if needed */
+#if FF_LFN_UNICODE == 1	|| FF_LFN_UNICODE == 3	/* Output it in UTF-16/32 encoding */
+		if (FF_LFN_UNICODE == 1 && dc >= 0x10000) {	/* Out of BMP at UTF-16? */
+			*p++ = (TCHAR)(0xD800 | ((dc >> 10) - 0x40)); nc++;	/* Make and output high surrogate */
+			dc = 0xDC00 | (dc & 0x3FF);		/* Make low surrogate */
+		}
+		*p++ = (TCHAR)dc; nc++;
+		if (dc == '\n') break;	/* End of line? */
+#elif FF_LFN_UNICODE == 2		/* Output it in UTF-8 encoding */
 		if (dc < 0x80) {	/* 1-byte */
 			*p++ = (TCHAR)dc;
 			nc++;
-			if (dc == '\n') break;
+			if (dc == '\n') break;	/* End of line? */
 		} else {
-			if (dc < 0x800) {	/* 2-byte */
+			if (dc < 0x800) {		/* 2-byte */
 				*p++ = (TCHAR)(0xC0 | (dc >> 6 & 0x1F));
 				*p++ = (TCHAR)(0x80 | (dc >> 0 & 0x3F));
 				nc += 2;
@@ -6175,21 +6186,23 @@ TCHAR* f_gets (
 				}
 			}
 		}
+#endif
 	}
 
-#else								/* Byte-by-byte without any conversion (ANSI/OEM API or UTF-8 to UTF-8) */
-	while (nc < len - 1) {
+#else			/* Byte-by-byte without any conversion (ANSI/OEM API) */
+	len -= 1;	/* Make a room for the terminator */
+	while (nc < len) {
 		f_read(fp, s, 1, &rc);
 		if (rc != 1) break;
-		wc = s[0];
-		if (FF_USE_STRFUNC == 2 && wc == '\r') continue;
-		*p++ = (TCHAR)wc; nc++;
-		if (wc == '\n') break;
+		dc = s[0];
+		if (FF_USE_STRFUNC == 2 && dc == '\r') continue;
+		*p++ = (TCHAR)dc; nc++;
+		if (dc == '\n') break;
 	}
 #endif
 
-	*p = 0;
-	return nc ? buff : 0;			/* When no data read (EOF or error), return with error. */
+	*p = 0;		/* Terminate the string */
+	return nc ? buff : 0;	/* When no data read due to EOF or error, return with error. */
 }
 
 
@@ -6214,20 +6227,19 @@ typedef struct {	/* Putchar output buffer and work area */
 } putbuff;
 
 
-static
-void putc_bfd (		/* Buffered write with code conversion */
+static void putc_bfd (		/* Buffered write with code conversion */
 	putbuff* pb,
 	TCHAR c
 )
 {
 	UINT n;
 	int i, nc;
-#if FF_USE_LFN && (FF_LFN_UNICODE == 1 || (FF_LFN_UNICODE == 2 && (FF_STRF_ENCODE != 3)))
+#if FF_USE_LFN && FF_LFN_UNICODE
 	WCHAR hs, wc;
-#endif
-#if FF_USE_LFN && FF_LFN_UNICODE == 2 && FF_STRF_ENCODE != 3
+#if FF_LFN_UNICODE == 2
 	DWORD dc;
 	TCHAR *tp;
+#endif
 #endif
 
 	if (FF_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
@@ -6236,45 +6248,21 @@ void putc_bfd (		/* Buffered write with code conversion */
 
 	i = pb->idx;			/* Write index of pb->buf[] */
 	if (i < 0) return;
-	nc = pb->nchr;			/* Write unit count */
+	nc = pb->nchr;			/* Write unit counter */
 
-#if FF_USE_LFN && FF_LFN_UNICODE >= 1
-#if FF_USE_LFN && FF_LFN_UNICODE == 1	/* UTF-16 input */
+#if FF_USE_LFN && FF_LFN_UNICODE
+#if FF_LFN_UNICODE == 1		/* UTF-16 input */
 	if (IsSurrogateH(c)) {
 		pb->hs = c; return;
 	}
-	wc = c; hs = pb->hs; pb->hs = 0;
+	hs = pb->hs; pb->hs = 0;
 	if (hs != 0) {
-		if (!IsSurrogateL(wc)) hs = 0;
-	} else {
-		if (IsSurrogateL(wc)) return;
-	}
-#if FF_STRF_ENCODE == 3			/* Write it in UTF-8 */
-	if (hs != 0) {				/* 4-byte */
-		nc += 4;
-		hs = (hs & 0x3FF) + 0x40;
-		pb->buf[i++] = (BYTE)(0xF0 | hs >> 8);
-		pb->buf[i++] = (BYTE)(0x80 | (hs >> 2 & 0x3F));
-		pb->buf[i++] = (BYTE)(0x80 | (hs & 3) << 4 | (wc >> 6 & 0x0F));
-		pb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F));
+		if (!IsSurrogateL(c)) hs = 0;
 	} else {
-		if (wc < 0x80) {		/* 1-byte */
-			nc++;
-			pb->buf[i++] = (BYTE)wc;
-		} else {
-			if (wc < 0x800) {	/* 2-byte */
-				nc += 2;
-				pb->buf[i++] = (BYTE)(0xC0 | wc >> 6);
-			} else {			/* 3-byte */
-				nc += 3;
-				pb->buf[i++] = (BYTE)(0xE0 | wc >> 12);
-				pb->buf[i++] = (BYTE)(0x80 | (wc >> 6 & 0x3F));
-			}
-			pb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F));
-		}
+		if (IsSurrogateL(c)) return;
 	}
-#endif
-#else									/* UTF-8 input */
+	wc = c;
+#elif FF_LFN_UNICODE == 2	/* UTF-8 input */
 	for (;;) {
 		if (pb->ct == 0) {	/* Out of multi-byte sequence? */
 			pb->bs[pb->wi = 0] = (BYTE)c;	/* Save 1st byte */
@@ -6283,67 +6271,82 @@ void putc_bfd (		/* Buffered write with code conversion */
 			if (((BYTE)c & 0xF0) == 0xE0) pb->ct = 2;	/* 3-byte? */
 			if (((BYTE)c & 0xF1) == 0xF0) pb->ct = 3;	/* 4-byte? */
 			return;
-		} else {			/* In the multi-byte sequence */
+		} else {				/* In the multi-byte sequence */
 			if (((BYTE)c & 0xC0) != 0x80) {	/* Broken sequence? */
 				pb->ct = 0; continue;
 			}
 			pb->bs[++pb->wi] = (BYTE)c;	/* Save the trailing byte */
-			if (--pb->ct == 0) break;	/* End of sequence? */
+			if (--pb->ct == 0) break;	/* End of multi-byte sequence? */
 			return;
 		}
 	}
-#if FF_STRF_ENCODE == 3		/* Write it in UTF-8 */
-	pb->buf[i++] = pb->bs[0]; nc++;
-	if (pb->bs[0] >= 0xC0) {
-		pb->buf[i++] = pb->bs[1]; nc++;
-	}
-	if (pb->bs[0] >= 0xE0) {
-		pb->buf[i++] = pb->bs[2]; nc++;
-	}
-	if (pb->bs[0] >= 0xF0) {
-		pb->buf[i++] = pb->bs[3]; nc++;
-	}
-#else						/* Write it in UTF-16 or ANSI/OEM */
 	tp = (TCHAR*)pb->bs;
 	dc = tchar2uni(&tp);	/* UTF-8 ==> UTF-16 */
 	if (dc == 0xFFFFFFFF) return;
 	wc = (WCHAR)dc;
 	hs = (WCHAR)(dc >> 16);
+#elif FF_LFN_UNICODE == 3	/* UTF-32 input */
+	if (IsSurrogate(c) || c >= 0x110000) return;
+	if (c >= 0x10000) {
+		hs = (WCHAR)(0xD800 | ((c >> 10) - 0x40)); 	/* Make high surrogate */
+		wc = 0xDC00 | (c & 0x3FF);					/* Make low surrogate */
+	} else {
+		hs = 0;
+		wc = (WCHAR)c;
+	}
 #endif
-#endif
-#if FF_USE_LFN && FF_LFN_UNICODE >= 1 && FF_STRF_ENCODE != 3
-#if FF_STRF_ENCODE == 2			/* Write a character in UTF-16BE */
+
+#if FF_STRF_ENCODE == 1		/* Write a character in UTF-16LE */
 	if (hs != 0) {
-		pb->buf[i++] = (BYTE)(hs >> 8);
-		pb->buf[i++] = (BYTE)hs;
+		st_word(&pb->buf[i], hs);
+		i += 2;
 		nc++;
 	}
-	pb->buf[i++] = (BYTE)(wc >> 8);
-	pb->buf[i++] = (BYTE)wc;
-	nc++;
-#elif FF_STRF_ENCODE == 1		/* Write a character in UTF-16LE */
+	st_word(&pb->buf[i], wc);
+	i += 2;
+#elif FF_STRF_ENCODE == 2	/* Write a character in UTF-16BE */
 	if (hs != 0) {
-		pb->buf[i++] = (BYTE)hs;
 		pb->buf[i++] = (BYTE)(hs >> 8);
+		pb->buf[i++] = (BYTE)hs;
 		nc++;
 	}
-	pb->buf[i++] = (BYTE)wc;
 	pb->buf[i++] = (BYTE)(wc >> 8);
-	nc++;
-#else							/* Write a character in ANSI/OEM */
+	pb->buf[i++] = (BYTE)wc;
+#elif FF_STRF_ENCODE == 3	/* Write it in UTF-8 */
+	if (hs != 0) {				/* 4-byte */
+		nc += 3;
+		hs = (hs & 0x3FF) + 0x40;
+		pb->buf[i++] = (BYTE)(0xF0 | hs >> 8);
+		pb->buf[i++] = (BYTE)(0x80 | (hs >> 2 & 0x3F));
+		pb->buf[i++] = (BYTE)(0x80 | (hs & 3) << 4 | (wc >> 6 & 0x0F));
+		pb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F));
+	} else {
+		if (wc < 0x80) {		/* 1-byte */
+			pb->buf[i++] = (BYTE)wc;
+		} else {
+			if (wc < 0x800) {	/* 2-byte */
+				nc += 1;
+				pb->buf[i++] = (BYTE)(0xC0 | wc >> 6);
+			} else {			/* 3-byte */
+				nc += 2;
+				pb->buf[i++] = (BYTE)(0xE0 | wc >> 12);
+				pb->buf[i++] = (BYTE)(0x80 | (wc >> 6 & 0x3F));
+			}
+			pb->buf[i++] = (BYTE)(0x80 | (wc & 0x3F));
+		}
+	}
+#else						/* Write it in ANSI/OEM */
 	if (hs != 0) return;
 	wc = ff_uni2oem(wc, CODEPAGE);	/* UTF-16 ==> ANSI/OEM */
-	if (wc == 0) return;;
+	if (wc == 0) return;
 	if (wc >= 0x100) {
 		pb->buf[i++] = (BYTE)(wc >> 8); nc++;
 	}
-	pb->buf[i++] = (BYTE)wc; nc++;
-#endif
+	pb->buf[i++] = (BYTE)wc;
 #endif
 
-#else									/* ANSI/OEM input */
+#else									/* ANSI/OEM input (without re-encode) */
 	pb->buf[i++] = (BYTE)c;
-	nc++;
 #endif
 
 	if (i >= (int)(sizeof pb->buf) - 4) {	/* Write buffered characters to the file */
@@ -6351,12 +6354,11 @@ void putc_bfd (		/* Buffered write with code conversion */
 		i = (n == (UINT)i) ? 0 : -1;
 	}
 	pb->idx = i;
-	pb->nchr = nc;
+	pb->nchr = nc + 1;
 }
 
 
-static
-int putc_flush (		/* Flush left characters in the buffer */
+static int putc_flush (		/* Flush left characters in the buffer */
 	putbuff* pb
 )
 {
@@ -6369,8 +6371,7 @@ int putc_flush (		/* Flush left characters in the buffer */
 }
 
 
-static
-void putc_init (		/* Initialize write buffer */
+static void putc_init (		/* Initialize write buffer */
 	putbuff* pb,
 	FIL* fp
 )
@@ -6544,7 +6545,7 @@ FRESULT f_setcp (
 )
 {
 	static const WORD       validcp[] = {  437,   720,   737,   771,   775,   850,   852,   857,   860,   861,   862,   863,   864,   865,   866,   869,   932,   936,   949,   950, 0};
-	static const BYTE *const tables[] = {Ct437, Ct720, Ct737, Ct771, Ct775, Ct850, Ct852, Ct857, Ct860, Ct861, Ct862, Ct863, Ct864, Ct865, Ct866, Ct869, Dc932, Dc936, Dc949, Dc950, 0};
+	static const BYTE* const tables[] = {Ct437, Ct720, Ct737, Ct771, Ct775, Ct850, Ct852, Ct857, Ct860, Ct861, Ct862, Ct863, Ct864, Ct865, Ct866, Ct869, Dc932, Dc936, Dc949, Dc950, 0};
 	UINT i;
 
 
diff --git a/components/fatfs/src/ff.h b/components/fatfs/src/ff.h
index 55c132982..d8ebeb833 100644
--- a/components/fatfs/src/ff.h
+++ b/components/fatfs/src/ff.h
@@ -1,8 +1,8 @@
 /*----------------------------------------------------------------------------/
-/  FatFs - Generic FAT Filesystem module  R0.13a                              /
+/  FatFs - Generic FAT Filesystem module  R0.13c                              /
 /-----------------------------------------------------------------------------/
 /
-/ Copyright (C) 2017, ChaN, all right reserved.
+/ Copyright (C) 2018, ChaN, all right reserved.
 /
 / FatFs module is an open source software. Redistribution and use of FatFs in
 / source and binary forms, with or without modification, are permitted provided
@@ -20,21 +20,41 @@
 
 
 #ifndef FF_DEFINED
-#define FF_DEFINED	89352	/* Revision ID */
+#define FF_DEFINED	86604	/* Revision ID */
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-#include "integer.h"	/* Basic integer types */
 #include "ffconf.h"		/* FatFs configuration options */
 
 #if FF_DEFINED != FFCONF_DEF
 #error Wrong configuration file (ffconf.h).
 #endif
 
-#ifdef FF_DEFINE_DIR
-#define FF_DIR DIR
+
+/* Integer types used for FatFs API */
+
+#if defined(_WIN32)	/* Main development platform */
+#define FF_INTDEF 2
+#include <windows.h>
+typedef unsigned __int64 QWORD;
+#elif (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) || defined(__cplusplus)	/* C99 or later */
+#define FF_INTDEF 2
+#include <stdint.h>
+typedef unsigned int	UINT;	/* int must be 16-bit or 32-bit */
+typedef unsigned char	BYTE;	/* char must be 8-bit */
+typedef uint16_t		WORD;	/* 16-bit unsigned integer */
+typedef uint16_t		WCHAR;	/* 16-bit unsigned integer */
+typedef uint32_t		DWORD;	/* 32-bit unsigned integer */
+typedef uint64_t		QWORD;	/* 64-bit unsigned integer */
+#else  	/* Earlier than C99 */
+#define FF_INTDEF 1
+typedef unsigned int	UINT;	/* int must be 16-bit or 32-bit */
+typedef unsigned char	BYTE;	/* char must be 8-bit */
+typedef unsigned short	WORD;	/* 16-bit unsigned integer */
+typedef unsigned short	WCHAR;	/* 16-bit unsigned integer */
+typedef unsigned long	DWORD;	/* 32-bit unsigned integer */
 #endif
 
 
@@ -48,6 +68,12 @@ typedef struct {
 extern PARTITION VolToPart[];	/* Volume - Partition resolution table */
 #endif
 
+#if FF_STR_VOLUME_ID
+#ifndef FF_VOLUME_STRS
+extern const char* VolumeStr[FF_VOLUMES];	/* User defied volume ID */
+#endif
+#endif
+
 
 
 /* Type of path name strings on FatFs API */
@@ -63,7 +89,11 @@ typedef WCHAR TCHAR;
 typedef char TCHAR;
 #define _T(x) u8 ## x
 #define _TEXT(x) u8 ## x
-#elif FF_USE_LFN && (FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 2)
+#elif FF_USE_LFN && FF_LFN_UNICODE == 3	/* Unicode in UTF-32 encoding */
+typedef DWORD TCHAR;
+#define _T(x) U ## x
+#define _TEXT(x) U ## x
+#elif FF_USE_LFN && (FF_LFN_UNICODE < 0 || FF_LFN_UNICODE > 3)
 #error Wrong FF_LFN_UNICODE setting
 #else									/* ANSI/OEM code in SBCS/DBCS */
 typedef char TCHAR;
@@ -78,6 +108,9 @@ typedef char TCHAR;
 /* Type of file size variables */
 
 #if FF_FS_EXFAT
+#if FF_INTDEF != 2
+#error exFAT feature wants C99 or later
+#endif
 typedef QWORD FSIZE_t;
 #else
 typedef DWORD FSIZE_t;
@@ -88,8 +121,8 @@ typedef DWORD FSIZE_t;
 /* Filesystem object structure (FATFS) */
 
 typedef struct {
-	BYTE	fs_type;		/* Filesystem type (0:N/A) */
-	BYTE	pdrv;			/* Physical drive number */
+	BYTE	fs_type;		/* Filesystem type (0:not mounted) */
+	BYTE	pdrv;			/* Associated physical drive */
 	BYTE	n_fats;			/* Number of FATs (1 or 2) */
 	BYTE	wflag;			/* win[] flag (b0:dirty) */
 	BYTE	fsi_flag;		/* FSINFO flags (b7:disabled, b0:dirty) */
@@ -126,6 +159,9 @@ typedef struct {
 	DWORD	fatbase;		/* FAT base sector */
 	DWORD	dirbase;		/* Root directory base sector/cluster */
 	DWORD	database;		/* Data base sector */
+#if FF_FS_EXFAT
+	DWORD	bitbase;		/* Allocation bitmap base sector */
+#endif
 	DWORD	winsect;		/* Current sector appearing in the win[] */
 	BYTE	win[FF_MAX_SS];	/* Disk access window for Directory, FAT (and file data at tiny cfg) */
 } FATFS;
@@ -138,7 +174,7 @@ typedef struct {
 	FATFS*	fs;				/* Pointer to the hosting volume of this object */
 	WORD	id;				/* Hosting volume mount ID */
 	BYTE	attr;			/* Object attribute */
-	BYTE	stat;			/* Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:flagmented in this session, b2:sub-directory stretched) */
+	BYTE	stat;			/* Object chain status (b1-0: =0:not contiguous, =2:contiguous, =3:fragmented in this session, b2:sub-directory stretched) */
 	DWORD	sclust;			/* Object data start cluster (0:no cluster or root directory) */
 	FSIZE_t	objsize;		/* Object size (valid when sclust != 0) */
 #if FF_FS_EXFAT
@@ -269,7 +305,7 @@ FRESULT f_getfree (const TCHAR* path, DWORD* nclst, FATFS** fatfs);	/* Get numbe
 FRESULT f_getlabel (const TCHAR* path, TCHAR* label, DWORD* vsn);	/* Get volume label */
 FRESULT f_setlabel (const TCHAR* label);							/* Set volume label */
 FRESULT f_forward (FIL* fp, UINT(*func)(const BYTE*,UINT), UINT btf, UINT* bf);	/* Forward data to the stream */
-FRESULT f_expand (FIL* fp, FSIZE_t szf, BYTE opt);					/* Allocate a contiguous block to the file */
+FRESULT f_expand (FIL* fp, FSIZE_t fsz, BYTE opt);					/* Allocate a contiguous block to the file */
 FRESULT f_mount (FATFS* fs, const TCHAR* path, BYTE opt);			/* Mount/Unmount a logical drive */
 FRESULT f_mkfs (const TCHAR* path, BYTE opt, DWORD au, void* work, UINT len);	/* Create a FAT volume */
 FRESULT f_fdisk (BYTE pdrv, const DWORD* szt, void* work);			/* Divide a physical drive into some partitions */
diff --git a/components/fatfs/src/ffconf.h b/components/fatfs/src/ffconf.h
index 9513b5160..79792beef 100644
--- a/components/fatfs/src/ffconf.h
+++ b/components/fatfs/src/ffconf.h
@@ -1,10 +1,10 @@
-#include <sys/param.h>
 #include "sdkconfig.h"
+
 /*---------------------------------------------------------------------------/
-/  FatFs - Configuration file
+/  FatFs Functional Configurations
 /---------------------------------------------------------------------------*/
 
-#define FFCONF_DEF 89352	/* Revision ID */
+#define FFCONF_DEF	86604	/* Revision ID */
 
 /*---------------------------------------------------------------------------/
 / Function Configurations
@@ -141,6 +141,7 @@
 /   0: ANSI/OEM in current CP (TCHAR = char)
 /   1: Unicode in UTF-16 (TCHAR = WCHAR)
 /   2: Unicode in UTF-8 (TCHAR = char)
+/   3: Unicode in UTF-32 (TCHAR = DWORD)
 /
 /  Also behavior of string I/O functions will be affected by this option.
 /  When LFN is not enabled, this option has no effect. */
@@ -186,11 +187,16 @@
 
 #define FF_STR_VOLUME_ID	0
 #define FF_VOLUME_STRS		"RAM","NAND","CF","SD","SD2","USB","USB2","USB3"
-/* FF_STR_VOLUME_ID switches string support for volume ID.
-/  When FF_STR_VOLUME_ID is set to 1, also pre-defined strings can be used as drive
-/  number in the path name. FF_VOLUME_STRS defines the drive ID strings for each
-/  logical drives. Number of items must be equal to FF_VOLUMES. Valid characters for
-/  the drive ID strings are: A-Z and 0-9. */
+/* FF_STR_VOLUME_ID switches support for volume ID in arbitrary strings.
+/  When FF_STR_VOLUME_ID is set to 1 or 2, arbitrary strings can be used as drive
+/  number in the path name. FF_VOLUME_STRS defines the volume ID strings for each
+/  logical drives. Number of items must not be less than FF_VOLUMES. Valid
+/  characters for the volume ID strings are A-Z, a-z and 0-9, however, they are
+/  compared in case-insensitive. If FF_STR_VOLUME_ID >= 1 and FF_VOLUME_STRS is
+/  not defined, a user defined volume string table needs to be defined as:
+/
+/  const char* VolumeStr[FF_VOLUMES] = {"ram","flash","sd","usb",...
+*/
 
 
 #define FF_MULTI_PARTITION	1
@@ -248,17 +254,17 @@
 
 #define FF_FS_EXFAT		0
 /* This option switches support for exFAT filesystem. (0:Disable or 1:Enable)
-/  When enable exFAT, also LFN needs to be enabled.
+/  To enable exFAT, also LFN needs to be enabled. (FF_USE_LFN >= 1)
 /  Note that enabling exFAT discards ANSI C (C89) compatibility. */
 
 
 #define FF_FS_NORTC		0
 #define FF_NORTC_MON	1
 #define FF_NORTC_MDAY	1
-#define FF_NORTC_YEAR	2017
+#define FF_NORTC_YEAR	2018
 /* The option FF_FS_NORTC switches timestamp functiton. If the system does not have
 /  any RTC function or valid timestamp is not needed, set FF_FS_NORTC = 1 to disable
-/  the timestamp function. All objects modified by FatFs will have a fixed timestamp
+/  the timestamp function. Every object modified by FatFs will have a fixed timestamp
 /  defined by FF_NORTC_MON, FF_NORTC_MDAY and FF_NORTC_YEAR in local time.
 /  To enable timestamp function (FF_FS_NORTC = 0), get_fattime() function need to be
 /  added to the project to read current time form real-time clock. FF_NORTC_MON,
@@ -298,14 +304,22 @@
 /  SemaphoreHandle_t and etc. A header file for O/S definitions needs to be
 /  included somewhere in the scope of ff.h. */
 
+#include <sys/param.h>
 #include "freertos/FreeRTOS.h"
 #include "freertos/semphr.h"
 
 /* Some memory allocation functions are declared here in addition to ff.h, so that
    they can be used also by external code when LFN feature is disabled.
  */
-void* ff_memalloc (UINT msize);
-void* ff_memcalloc (UINT num, UINT size);
+void* ff_memalloc (unsigned msize);
+void ff_memfree(void*);
 
 
 /*--- End of configuration options ---*/
+
+/* Redefine names of disk IO functions to prevent name collisions */
+#define disk_initialize     ff_disk_initialize
+#define disk_status         ff_disk_status
+#define disk_read           ff_disk_read
+#define disk_write          ff_disk_write
+#define disk_ioctl          ff_disk_ioctl
diff --git a/components/fatfs/src/ffsystem.c b/components/fatfs/src/ffsystem.c
index ac0236518..b88ce1555 100644
--- a/components/fatfs/src/ffsystem.c
+++ b/components/fatfs/src/ffsystem.c
@@ -1,47 +1,23 @@
 /*------------------------------------------------------------------------*/
 /* Sample Code of OS Dependent Functions for FatFs                        */
-/* (C)ChaN, 2017                                                          */
+/* (C)ChaN, 2018                                                          */
 /*------------------------------------------------------------------------*/
 
 
-#include <string.h>
 #include "ff.h"
-#include "sdkconfig.h"
-#ifdef CONFIG_FATFS_ALLOC_EXTRAM_FIRST
-#include "esp_heap_caps.h"
-#endif
 
 
+#if FF_USE_LFN == 3	/* Dynamic memory allocation */
 
 /*------------------------------------------------------------------------*/
 /* Allocate a memory block                                                */
 /*------------------------------------------------------------------------*/
 
-void* ff_memalloc (	/* Returns pointer to the allocated memory block (null on not enough core) */
+void* ff_memalloc (	/* Returns pointer to the allocated memory block (null if not enough core) */
 	UINT msize		/* Number of bytes to allocate */
 )
 {
-#ifdef CONFIG_FATFS_ALLOC_EXTRAM_FIRST
-	return heap_caps_malloc_prefer(size, 2, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM,
-											MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
-#else
-	return malloc(msize);
-#endif
-}
-
-/*------------------------------------------------------------------------*/
-/* Allocate and zero out memory block                                     */
-/*------------------------------------------------------------------------*/
-
-
-void* ff_memcalloc (UINT num, UINT size)
-{
-#ifdef CONFIG_FATFS_ALLOC_EXTRAM_FIRST
-	return heap_caps_calloc_prefer(num, size, 2, MALLOC_CAP_DEFAULT | MALLOC_CAP_SPIRAM,
-												MALLOC_CAP_DEFAULT | MALLOC_CAP_INTERNAL);
-#else
-	return calloc(num, size);
-#endif
+	return malloc(msize);	/* Allocate a new memory block with POSIX API */
 }
 
 
@@ -50,12 +26,13 @@ void* ff_memcalloc (UINT num, UINT size)
 /*------------------------------------------------------------------------*/
 
 void ff_memfree (
-	void* mblock	/* Pointer to the memory block to free (nothing to do for null) */
+	void* mblock	/* Pointer to the memory block to free (nothing to do if null) */
 )
 {
 	free(mblock);	/* Free the memory block with POSIX API */
 }
 
+#endif
 
 
 
@@ -69,14 +46,35 @@ void ff_memfree (
 /  When a 0 is returned, the f_mount() function fails with FR_INT_ERR.
 */
 
+//const osMutexDef_t Mutex[FF_VOLUMES];	/* Table of CMSIS-RTOS mutex */
+
 
 int ff_cre_syncobj (	/* 1:Function succeeded, 0:Could not create the sync object */
 	BYTE vol,			/* Corresponding volume (logical drive number) */
-	FF_SYNC_t *sobj		/* Pointer to return the created sync object */
+	FF_SYNC_t* sobj		/* Pointer to return the created sync object */
 )
 {
-    *sobj = xSemaphoreCreateMutex();
-    return (*sobj != NULL) ? 1 : 0;
+	/* Win32 */
+	*sobj = CreateMutex(NULL, FALSE, NULL);
+	return (int)(*sobj != INVALID_HANDLE_VALUE);
+
+	/* uITRON */
+//	T_CSEM csem = {TA_TPRI,1,1};
+//	*sobj = acre_sem(&csem);
+//	return (int)(*sobj > 0);
+
+	/* uC/OS-II */
+//	OS_ERR err;
+//	*sobj = OSMutexCreate(0, &err);
+//	return (int)(err == OS_NO_ERR);
+
+	/* FreeRTOS */
+//	*sobj = xSemaphoreCreateMutex();
+//	return (int)(*sobj != NULL);
+
+	/* CMSIS-RTOS */
+//	*sobj = osMutexCreate(&Mutex[vol]);
+//	return (int)(*sobj != NULL);
 }
 
 
@@ -92,8 +90,23 @@ int ff_del_syncobj (	/* 1:Function succeeded, 0:Could not delete due to an error
 	FF_SYNC_t sobj		/* Sync object tied to the logical drive to be deleted */
 )
 {
-    vSemaphoreDelete(sobj);
-    return 1;
+	/* Win32 */
+	return (int)CloseHandle(sobj);
+
+	/* uITRON */
+//	return (int)(del_sem(sobj) == E_OK);
+
+	/* uC/OS-II */
+//	OS_ERR err;
+//	OSMutexDel(sobj, OS_DEL_ALWAYS, &err);
+//	return (int)(err == OS_NO_ERR);
+
+	/* FreeRTOS */
+//  vSemaphoreDelete(sobj);
+//	return 1;
+
+	/* CMSIS-RTOS */
+//	return (int)(osMutexDelete(sobj) == osOK);
 }
 
 
@@ -108,7 +121,22 @@ int ff_req_grant (	/* 1:Got a grant to access the volume, 0:Could not get a gran
 	FF_SYNC_t sobj	/* Sync object to wait */
 )
 {
-    return (xSemaphoreTake(sobj, FF_FS_TIMEOUT) == pdTRUE) ? 1 : 0;
+	/* Win32 */
+	return (int)(WaitForSingleObject(sobj, FF_FS_TIMEOUT) == WAIT_OBJECT_0);
+
+	/* uITRON */
+//	return (int)(wai_sem(sobj) == E_OK);
+
+	/* uC/OS-II */
+//	OS_ERR err;
+//	OSMutexPend(sobj, FF_FS_TIMEOUT, &err));
+//	return (int)(err == OS_NO_ERR);
+
+	/* FreeRTOS */
+//	return (int)(xSemaphoreTake(sobj, FF_FS_TIMEOUT) == pdTRUE);
+
+	/* CMSIS-RTOS */
+//	return (int)(osMutexWait(sobj, FF_FS_TIMEOUT) == osOK);
 }
 
 
@@ -122,7 +150,21 @@ void ff_rel_grant (
 	FF_SYNC_t sobj	/* Sync object to be signaled */
 )
 {
-    xSemaphoreGive(sobj);
+	/* Win32 */
+	ReleaseMutex(sobj);
+
+	/* uITRON */
+//	sig_sem(sobj);
+
+	/* uC/OS-II */
+//	OSMutexPost(sobj);
+
+	/* FreeRTOS */
+//	xSemaphoreGive(sobj);
+
+	/* CMSIS-RTOS */
+//	osMutexRelease(sobj);
 }
 
 #endif
+
diff --git a/components/fatfs/src/ffunicode.c b/components/fatfs/src/ffunicode.c
index 901affe56..349901b1f 100644
--- a/components/fatfs/src/ffunicode.c
+++ b/components/fatfs/src/ffunicode.c
@@ -1,5 +1,5 @@
 /*------------------------------------------------------------------------*/
-/* Unicode handling functions for FatFs R0.13a                            */
+/* Unicode handling functions for FatFs R0.13c                            */
 /*------------------------------------------------------------------------*/
 /* This module will occupy a huge memory in the .const section when the    /
 /  FatFs is configured for LFN with DBCS. If the system has any Unicode    /
@@ -7,7 +7,7 @@
 /  that function to avoid silly memory consumption.                        /
 /-------------------------------------------------------------------------*/
 /*
-/ Copyright (C) 2017, ChaN, all right reserved.
+/ Copyright (C) 2018, ChaN, all right reserved.
 /
 / FatFs module is an open source software. Redistribution and use of FatFs in
 / source and binary forms, with or without modification, are permitted provided
@@ -25,9 +25,9 @@
 
 #include "ff.h"
 
-#if FF_USE_LFN	/* This module is blanked when non-LFN configuration */
+#if FF_USE_LFN	/* This module will be blanked at non-LFN configuration */
 
-#if FF_DEFINED != 89352	/* Revision ID */
+#if FF_DEFINED != 86604	/* Revision ID */
 #error Wrong include file (ff.h).
 #endif
 
@@ -40,8 +40,7 @@
 /*------------------------------------------------------------------------*/
 
 #if FF_CODE_PAGE == 932 || FF_CODE_PAGE == 0	/* Japanese */
-static
-const WCHAR uni2oem932[] = {	/* Unicode --> Shift_JIS pairs */
+static const WCHAR uni2oem932[] = {	/* Unicode --> Shift_JIS pairs */
 	0x00A7, 0x8198, 0x00A8, 0x814E, 0x00B0, 0x818B, 0x00B1, 0x817D,	0x00B4, 0x814C, 0x00B6, 0x81F7, 0x00D7, 0x817E, 0x00F7, 0x8180,
 	0x0391, 0x839F, 0x0392, 0x83A0, 0x0393, 0x83A1, 0x0394, 0x83A2,	0x0395, 0x83A3, 0x0396, 0x83A4, 0x0397, 0x83A5, 0x0398, 0x83A6,
 	0x0399, 0x83A7, 0x039A, 0x83A8, 0x039B, 0x83A9, 0x039C, 0x83AA,	0x039D, 0x83AB, 0x039E, 0x83AC, 0x039F, 0x83AD, 0x03A0, 0x83AE,
@@ -968,8 +967,7 @@ const WCHAR uni2oem932[] = {	/* Unicode --> Shift_JIS pairs */
 	0xFFE1, 0x8192, 0xFFE2, 0x81CA, 0xFFE3, 0x8150, 0xFFE4, 0xFA55,	0xFFE5, 0x818F, 0, 0
 };
 
-static
-const WCHAR oem2uni932[] = {	/* Shift_JIS --> Unicode pairs */
+static const WCHAR oem2uni932[] = {	/* Shift_JIS --> Unicode pairs */
 	0x00A1, 0xFF61, 0x00A2, 0xFF62, 0x00A3, 0xFF63, 0x00A4, 0xFF64,	0x00A5, 0xFF65, 0x00A6, 0xFF66, 0x00A7, 0xFF67, 0x00A8, 0xFF68,
 	0x00A9, 0xFF69, 0x00AA, 0xFF6A, 0x00AB, 0xFF6B, 0x00AC, 0xFF6C,	0x00AD, 0xFF6D, 0x00AE, 0xFF6E, 0x00AF, 0xFF6F, 0x00B0, 0xFF70,
 	0x00B1, 0xFF71, 0x00B2, 0xFF72, 0x00B3, 0xFF73, 0x00B4, 0xFF74,	0x00B5, 0xFF75, 0x00B6, 0xFF76, 0x00B7, 0xFF77, 0x00B8, 0xFF78,
@@ -1898,8 +1896,7 @@ const WCHAR oem2uni932[] = {	/* Shift_JIS --> Unicode pairs */
 #endif
 
 #if FF_CODE_PAGE == 936 || FF_CODE_PAGE == 0	/* Simplified Chinese */
-static
-const WCHAR uni2oem936[] = {	/* Unicode --> GBK pairs */
+static const WCHAR uni2oem936[] = {	/* Unicode --> GBK pairs */
 	0x00A4, 0xA1E8, 0x00A7, 0xA1EC, 0x00A8, 0xA1A7, 0x00B0, 0xA1E3,	0x00B1, 0xA1C0, 0x00B7, 0xA1A4, 0x00D7, 0xA1C1, 0x00E0, 0xA8A4,
 	0x00E1, 0xA8A2, 0x00E8, 0xA8A8, 0x00E9, 0xA8A6, 0x00EA, 0xA8BA,	0x00EC, 0xA8AC, 0x00ED, 0xA8AA, 0x00F2, 0xA8B0, 0x00F3, 0xA8AE,
 	0x00F7, 0xA1C2, 0x00F9, 0xA8B4, 0x00FA, 0xA8B2, 0x00FC, 0xA8B9,	0x0101, 0xA8A1, 0x0113, 0xA8A5, 0x011B, 0xA8A7, 0x012B, 0xA8A9,
@@ -4627,8 +4624,7 @@ const WCHAR uni2oem936[] = {	/* Unicode --> GBK pairs */
 	0, 0
 };
 
-static
-const WCHAR oem2uni936[] = {	/* GBK --> Unicode pairs */
+static const WCHAR oem2uni936[] = {	/* GBK --> Unicode pairs */
 	0x0080, 0x20AC, 0x8140, 0x4E02, 0x8141, 0x4E04, 0x8142, 0x4E05,	0x8143, 0x4E06, 0x8144, 0x4E0F, 0x8145, 0x4E12, 0x8146, 0x4E17,
 	0x8147, 0x4E1F, 0x8148, 0x4E20, 0x8149, 0x4E21, 0x814A, 0x4E23,	0x814B, 0x4E26, 0x814C, 0x4E29, 0x814D, 0x4E2E, 0x814E, 0x4E2F,
 	0x814F, 0x4E31, 0x8150, 0x4E33, 0x8151, 0x4E35, 0x8152, 0x4E37,	0x8153, 0x4E3C, 0x8154, 0x4E40, 0x8155, 0x4E41, 0x8156, 0x4E42,
@@ -7358,8 +7354,7 @@ const WCHAR oem2uni936[] = {	/* GBK --> Unicode pairs */
 #endif
 
 #if FF_CODE_PAGE == 949 || FF_CODE_PAGE == 0	/* Korean */
-static
-const WCHAR uni2oem949[] = {	/* Unicode --> Korean pairs */
+static const WCHAR uni2oem949[] = {	/* Unicode --> Korean pairs */
 	0x00A1, 0xA2AE, 0x00A4, 0xA2B4, 0x00A7, 0xA1D7, 0x00A8, 0xA1A7,	0x00AA, 0xA8A3, 0x00AD, 0xA1A9, 0x00AE, 0xA2E7, 0x00B0, 0xA1C6,
 	0x00B1, 0xA1BE, 0x00B2, 0xA9F7, 0x00B3, 0xA9F8, 0x00B4, 0xA2A5,	0x00B6, 0xA2D2, 0x00B7, 0xA1A4, 0x00B8, 0xA2AC, 0x00B9, 0xA9F6,
 	0x00BA, 0xA8AC, 0x00BC, 0xA8F9, 0x00BD, 0xA8F6, 0x00BE, 0xA8FA,	0x00BF, 0xA2AF, 0x00C6, 0xA8A1, 0x00D0, 0xA8A2, 0x00D7, 0xA1BF,
@@ -9494,8 +9489,7 @@ const WCHAR uni2oem949[] = {	/* Unicode --> Korean pairs */
 	0, 0
 };
 
-static
-const WCHAR oem2uni949[] = {	/* Korean --> Unicode pairs */
+static const WCHAR oem2uni949[] = {	/* Korean --> Unicode pairs */
 	0x8141, 0xAC02, 0x8142, 0xAC03, 0x8143, 0xAC05, 0x8144, 0xAC06,	0x8145, 0xAC0B, 0x8146, 0xAC0C, 0x8147, 0xAC0D, 0x8148, 0xAC0E,
 	0x8149, 0xAC0F, 0x814A, 0xAC18, 0x814B, 0xAC1E, 0x814C, 0xAC1F,	0x814D, 0xAC21, 0x814E, 0xAC22, 0x814F, 0xAC23, 0x8150, 0xAC25,
 	0x8151, 0xAC26, 0x8152, 0xAC27, 0x8153, 0xAC28, 0x8154, 0xAC29,	0x8155, 0xAC2A, 0x8156, 0xAC2B, 0x8157, 0xAC2E, 0x8158, 0xAC32,
@@ -11632,8 +11626,7 @@ const WCHAR oem2uni949[] = {	/* Korean --> Unicode pairs */
 #endif
 
 #if FF_CODE_PAGE == 950 || FF_CODE_PAGE == 0	/* Traditional Chinese */
-static
-const WCHAR uni2oem950[] = {	/* Unicode --> Big5 pairs */
+static const WCHAR uni2oem950[] = {	/* Unicode --> Big5 pairs */
 	0x00A7, 0xA1B1, 0x00AF, 0xA1C2, 0x00B0, 0xA258, 0x00B1, 0xA1D3,	0x00B7, 0xA150, 0x00D7, 0xA1D1, 0x00F7, 0xA1D2, 0x02C7, 0xA3BE,
 	0x02C9, 0xA3BC, 0x02CA, 0xA3BD, 0x02CB, 0xA3BF, 0x02CD, 0xA1C5,	0x02D9, 0xA3BB, 0x0391, 0xA344, 0x0392, 0xA345, 0x0393, 0xA346,
 	0x0394, 0xA347, 0x0395, 0xA348, 0x0396, 0xA349, 0x0397, 0xA34A,	0x0398, 0xA34B, 0x0399, 0xA34C, 0x039A, 0xA34D, 0x039B, 0xA34E,
@@ -13324,8 +13317,7 @@ const WCHAR uni2oem950[] = {	/* Unicode --> Big5 pairs */
 	0xFF5C, 0xA155, 0xFF5D, 0xA162, 0xFF5E, 0xA1E3, 0xFFE0, 0xA246,	0xFFE1, 0xA247, 0xFFE3, 0xA1C3, 0xFFE5, 0xA244, 0, 0
 };
 
-static
-const WCHAR oem2uni950[] = {	/* Big5 --> Unicode pairs */
+static const WCHAR oem2uni950[] = {	/* Big5 --> Unicode pairs */
 	0xA140, 0x3000, 0xA141, 0xFF0C, 0xA142, 0x3001, 0xA143, 0x3002,	0xA144, 0xFF0E, 0xA145, 0x2027, 0xA146, 0xFF1B, 0xA147, 0xFF1A,
 	0xA148, 0xFF1F, 0xA149, 0xFF01, 0xA14A, 0xFE30, 0xA14B, 0x2026,	0xA14C, 0x2025, 0xA14D, 0xFE50, 0xA14E, 0xFE51, 0xA14F, 0xFE52,
 	0xA150, 0x00B7, 0xA151, 0xFE54, 0xA152, 0xFE55, 0xA153, 0xFE56,	0xA154, 0xFE57, 0xA155, 0xFF5C, 0xA156, 0x2013, 0xA157, 0xFE31,
@@ -15018,8 +15010,7 @@ const WCHAR oem2uni950[] = {	/* Big5 --> Unicode pairs */
 #endif
 
 #if FF_CODE_PAGE == 437 || FF_CODE_PAGE == 0
-static
-const WCHAR uc437[] = {	/*  CP437(U.S.) to Unicode conversion table */
+static const WCHAR uc437[] = {	/*  CP437(U.S.) to Unicode conversion table */
 	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
 	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
 	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
@@ -15031,8 +15022,7 @@ const WCHAR uc437[] = {	/*  CP437(U.S.) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 720 || FF_CODE_PAGE == 0
-static
-const WCHAR uc720[] = {	/*  CP720(Arabic) to Unicode conversion table */
+static const WCHAR uc720[] = {	/*  CP720(Arabic) to Unicode conversion table */
 	0x0000, 0x0000, 0x00E9, 0x00E2, 0x0000, 0x00E0, 0x0000, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x0000, 0x0000, 0x0000,
 	0x0000, 0x0651, 0x0652, 0x00F4, 0x00A4, 0x0640, 0x00FB, 0x00F9, 0x0621, 0x0622, 0x0623, 0x0624, 0x00A3, 0x0625, 0x0626, 0x0627,
 	0x0628, 0x0629, 0x062A, 0x062B, 0x062C, 0x062D, 0x062E, 0x062F, 0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x00AB, 0x00BB,
@@ -15044,8 +15034,7 @@ const WCHAR uc720[] = {	/*  CP720(Arabic) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 737 || FF_CODE_PAGE == 0
-static
-const WCHAR uc737[] = {	/*  CP737(Greek) to Unicode conversion table */
+static const WCHAR uc737[] = {	/*  CP737(Greek) to Unicode conversion table */
 	0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x0398, 0x0399, 0x039A, 0x039B, 0x039C, 0x039D, 0x039E, 0x039F, 0x03A0,
 	0x03A1, 0x03A3, 0x03A4, 0x03A5, 0x03A6, 0x03A7, 0x03A8, 0x03A9, 0x03B1, 0x03B2, 0x03B3, 0x03B4, 0x03B5, 0x03B6, 0x03B7, 0x03B8,
 	0x03B9, 0x03BA, 0x03BB, 0x03BC, 0x03BD, 0x03BE, 0x03BF, 0x03C0, 0x03C1, 0x03C3, 0x03C2, 0x03C4, 0x03C5, 0x03C6, 0x03C7, 0x03C8,
@@ -15057,8 +15046,7 @@ const WCHAR uc737[] = {	/*  CP737(Greek) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 771 || FF_CODE_PAGE == 0
-static
-const WCHAR uc771[] = {	/*  CP771(KBL) to Unicode conversion table */
+static const WCHAR uc771[] = {	/*  CP771(KBL) to Unicode conversion table */
 	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
 	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
 	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
@@ -15070,8 +15058,7 @@ const WCHAR uc771[] = {	/*  CP771(KBL) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 775 || FF_CODE_PAGE == 0
-static
-const WCHAR uc775[] = {	/*  CP775(Baltic) to Unicode conversion table */
+static const WCHAR uc775[] = {	/*  CP775(Baltic) to Unicode conversion table */
 	0x0106, 0x00FC, 0x00E9, 0x0101, 0x00E4, 0x0123, 0x00E5, 0x0107, 0x0142, 0x0113, 0x0156, 0x0157, 0x012B, 0x0179, 0x00C4, 0x00C5,
 	0x00C9, 0x00E6, 0x00C6, 0x014D, 0x00F6, 0x0122, 0x00A2, 0x015A, 0x015B, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x00A4,
 	0x0100, 0x012A, 0x00F3, 0x017B, 0x017C, 0x017A, 0x201D, 0x00A6, 0x00A9, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x0141, 0x00AB, 0x00BB,
@@ -15083,8 +15070,7 @@ const WCHAR uc775[] = {	/*  CP775(Baltic) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 850 || FF_CODE_PAGE == 0
-static
-const WCHAR uc850[] = {	/*  CP850(Latin 1) to Unicode conversion table */
+static const WCHAR uc850[] = {	/*  CP850(Latin 1) to Unicode conversion table */
 	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
 	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x00D7, 0x0192,
 	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
@@ -15096,8 +15082,7 @@ const WCHAR uc850[] = {	/*  CP850(Latin 1) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 852 || FF_CODE_PAGE == 0
-static
-const WCHAR uc852[] = {	/*  CP852(Latin 2) to Unicode conversion table */
+static const WCHAR uc852[] = {	/*  CP852(Latin 2) to Unicode conversion table */
 	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x016F, 0x0107, 0x00E7, 0x0142, 0x00EB, 0x0150, 0x0151, 0x00EE, 0x0179, 0x00C4, 0x0106,
 	0x00C9, 0x0139, 0x013A, 0x00F4, 0x00F6, 0x013D, 0x013E, 0x015A, 0x015B, 0x00D6, 0x00DC, 0x0164, 0x0165, 0x0141, 0x00D7, 0x010D,
 	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x0104, 0x0105, 0x017D, 0x017E, 0x0118, 0x0119, 0x00AC, 0x017A, 0x010C, 0x015F, 0x00AB, 0x00BB,
@@ -15109,8 +15094,7 @@ const WCHAR uc852[] = {	/*  CP852(Latin 2) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 855 || FF_CODE_PAGE == 0
-static
-const WCHAR uc855[] = {	/*  CP855(Cyrillic) to Unicode conversion table */
+static const WCHAR uc855[] = {	/*  CP855(Cyrillic) to Unicode conversion table */
 	0x0452, 0x0402, 0x0453, 0x0403, 0x0451, 0x0401, 0x0454, 0x0404, 0x0455, 0x0405, 0x0456, 0x0406, 0x0457, 0x0407, 0x0458, 0x0408,
 	0x0459, 0x0409, 0x045A, 0x040A, 0x045B, 0x040B, 0x045C, 0x040C, 0x045E, 0x040E, 0x045F, 0x040F, 0x044E, 0x042E, 0x044A, 0x042A,
 	0x0430, 0x0410, 0x0431, 0x0411, 0x0446, 0x0426, 0x0434, 0x0414, 0x0435, 0x0415, 0x0444, 0x0424, 0x0433, 0x0413, 0x00AB, 0x00BB,
@@ -15122,8 +15106,7 @@ const WCHAR uc855[] = {	/*  CP855(Cyrillic) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 857 || FF_CODE_PAGE == 0
-static
-const WCHAR uc857[] = {	/*  CP857(Turkish) to Unicode conversion table */
+static const WCHAR uc857[] = {	/*  CP857(Turkish) to Unicode conversion table */
 	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x0131, 0x00C4, 0x00C5,
 	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x0130, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x015E, 0x015F,
 	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x011E, 0x011F, 0x00BF, 0x00AE, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
@@ -15135,8 +15118,7 @@ const WCHAR uc857[] = {	/*  CP857(Turkish) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 860 || FF_CODE_PAGE == 0
-static
-const WCHAR uc860[] = {	/*  CP860(Portuguese) to Unicode conversion table */
+static const WCHAR uc860[] = {	/*  CP860(Portuguese) to Unicode conversion table */
 	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E3, 0x00E0, 0x00C1, 0x00E7, 0x00EA, 0x00CA, 0x00E8, 0x00CD, 0x00D4, 0x00EC, 0x00C3, 0x00C2,
 	0x00C9, 0x00C0, 0x00C8, 0x00F4, 0x00F5, 0x00F2, 0x00DA, 0x00F9, 0x00CC, 0x00D5, 0x00DC, 0x00A2, 0x00A3, 0x00D9, 0x20A7, 0x00D3,
 	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x00D2, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
@@ -15148,8 +15130,7 @@ const WCHAR uc860[] = {	/*  CP860(Portuguese) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 861 || FF_CODE_PAGE == 0
-static
-const WCHAR uc861[] = {	/*  CP861(Icelandic) to Unicode conversion table */
+static const WCHAR uc861[] = {	/*  CP861(Icelandic) to Unicode conversion table */
 	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E6, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00D0, 0x00F0, 0x00DE, 0x00C4, 0x00C5,
 	0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00FE, 0x00FB, 0x00DD, 0x00FD, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x20A7, 0x0192,
 	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00C1, 0x00CD, 0x00D3, 0x00DA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
@@ -15161,8 +15142,7 @@ const WCHAR uc861[] = {	/*  CP861(Icelandic) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 862 || FF_CODE_PAGE == 0
-static
-const WCHAR uc862[] = {	/*  CP862(Hebrew) to Unicode conversion table */
+static const WCHAR uc862[] = {	/*  CP862(Hebrew) to Unicode conversion table */
 	0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6, 0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
 	0x05E0, 0x05E1, 0x05E2, 0x05E3, 0x05E4, 0x05E5, 0x05E6, 0x05E7, 0x05E8, 0x05E9, 0x05EA, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
 	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
@@ -15174,8 +15154,7 @@ const WCHAR uc862[] = {	/*  CP862(Hebrew) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 863 || FF_CODE_PAGE == 0
-static
-const WCHAR uc863[] = {	/*  CP863(Canadian French) to Unicode conversion table */
+static const WCHAR uc863[] = {	/*  CP863(Canadian French) to Unicode conversion table */
 	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00C2, 0x00E0, 0x00B6, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x2017, 0x00C0,
 	0x00C9, 0x00C8, 0x00CA, 0x00F4, 0x00CB, 0x00CF, 0x00FB, 0x00F9, 0x00A4, 0x00D4, 0x00DC, 0x00A2, 0x00A3, 0x00D9, 0x00DB, 0x0192,
 	0x00A6, 0x00B4, 0x00F3, 0x00FA, 0x00A8, 0x00BB, 0x00B3, 0x00AF, 0x00CE, 0x3210, 0x00AC, 0x00BD, 0x00BC, 0x00BE, 0x00AB, 0x00BB,
@@ -15187,8 +15166,7 @@ const WCHAR uc863[] = {	/*  CP863(Canadian French) to Unicode conversion table *
 };
 #endif
 #if FF_CODE_PAGE == 864 || FF_CODE_PAGE == 0
-static
-const WCHAR uc864[] = {	/*  CP864(Arabic) to Unicode conversion table */
+static const WCHAR uc864[] = {	/*  CP864(Arabic) to Unicode conversion table */
 	0x00B0, 0x00B7, 0x2219, 0x221A, 0x2592, 0x2500, 0x2502, 0x253C, 0x2524, 0x252C, 0x251C, 0x2534, 0x2510, 0x250C, 0x2514, 0x2518,
 	0x03B2, 0x221E, 0x03C6, 0x00B1, 0x00BD, 0x00BC, 0x2248, 0x00AB, 0x00BB, 0xFEF7, 0xFEF8, 0x0000, 0x0000, 0xFEFB, 0xFEFC, 0x0000,
 	0x00A0, 0x00AD, 0xFE82, 0x00A3, 0x00A4, 0xFE84, 0x0000, 0x20AC, 0xFE8E, 0xFE8F, 0xFE95, 0xFE99, 0x060C, 0xFE9D, 0xFEA1, 0xFEA5,
@@ -15200,8 +15178,7 @@ const WCHAR uc864[] = {	/*  CP864(Arabic) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 865 || FF_CODE_PAGE == 0
-static
-const WCHAR uc865[] = {	/*  CP865(Nordic) to Unicode conversion table */
+static const WCHAR uc865[] = {	/*  CP865(Nordic) to Unicode conversion table */
 	0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7, 0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
 	0x00C5, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9, 0x00FF, 0x00D6, 0x00DC, 0x00F8, 0x00A3, 0x00D8, 0x20A7, 0x0192,
 	0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA, 0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00A4,
@@ -15213,8 +15190,7 @@ const WCHAR uc865[] = {	/*  CP865(Nordic) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 866 || FF_CODE_PAGE == 0
-static
-const WCHAR uc866[] = {	/*  CP866(Russian) to Unicode conversion table */
+static const WCHAR uc866[] = {	/*  CP866(Russian) to Unicode conversion table */
 	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
 	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
 	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437, 0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
@@ -15226,8 +15202,7 @@ const WCHAR uc866[] = {	/*  CP866(Russian) to Unicode conversion table */
 };
 #endif
 #if FF_CODE_PAGE == 869 || FF_CODE_PAGE == 0
-static
-const WCHAR uc869[] = {	/*  CP869(Greek 2) to Unicode conversion table */
+static const WCHAR uc869[] = {	/*  CP869(Greek 2) to Unicode conversion table */
 	0x00B7, 0x00B7, 0x00B7, 0x00B7, 0x00B7, 0x00B7, 0x0386, 0x00B7, 0x00B7, 0x00AC, 0x00A6, 0x2018, 0x2019, 0x0388, 0x2015, 0x0389,
 	0x038A, 0x03AA, 0x038C, 0x00B7, 0x00B7, 0x038E, 0x03AB, 0x00A9, 0x038F, 0x00B2, 0x00B3, 0x03AC, 0x00A3, 0x03AD, 0x03AE, 0x03AF,
 	0x03CA, 0x0390, 0x03CC, 0x03CD, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397, 0x00BD, 0x0398, 0x0399, 0x00AB, 0x00BB,
@@ -15261,7 +15236,7 @@ WCHAR ff_uni2oem (	/* Returns OEM code character, zero on error */
 		c = (WCHAR)uni;
 
 	} else {			/* Non-ASCII */
-		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it a valid code? */
+		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it in BMP and valid code page? */
 			for (c = 0; c < 0x80 && uni != p[c]; c++) ;
 			c = (c + 0x80) & 0xFF;
 		}
@@ -15308,30 +15283,28 @@ WCHAR ff_uni2oem (	/* Returns OEM code character, zero on error */
 {
 	const WCHAR *p;
 	WCHAR c = 0, uc;
-	UINT i, n, li, hi;
+	UINT i = 0, n, li, hi;
 
 
 	if (uni < 0x80) {	/* ASCII? */
 		c = (WCHAR)uni;
 
 	} else {			/* Non-ASCII */
-		if (uni < 0x10000) {	/* Is it in BMP? */
-			if (cp == FF_CODE_PAGE) {	/* Is it a valid code? */
-				uc = (WCHAR)uni;
-				p = CVTBL(uni2oem, FF_CODE_PAGE);
-				hi = sizeof CVTBL(uni2oem, FF_CODE_PAGE) / 4 - 1;
-				li = 0;
-				for (n = 16; n; n--) {
-					i = li + (hi - li) / 2;
-					if (uc == p[i * 2]) break;
-					if (uc > p[i * 2]) {
-						li = i;
-					} else {
-						hi = i;
-					}
+		if (uni < 0x10000 && cp == FF_CODE_PAGE) {	/* Is it in BMP and valid code page? */
+			uc = (WCHAR)uni;
+			p = CVTBL(uni2oem, FF_CODE_PAGE);
+			hi = sizeof CVTBL(uni2oem, FF_CODE_PAGE) / 4 - 1;
+			li = 0;
+			for (n = 16; n; n--) {
+				i = li + (hi - li) / 2;
+				if (uc == p[i * 2]) break;
+				if (uc > p[i * 2]) {
+					li = i;
+				} else {
+					hi = i;
 				}
-				if (n != 0) c = p[i * 2 + 1];
 			}
+			if (n != 0) c = p[i * 2 + 1];
 		}
 	}
 
@@ -15346,14 +15319,14 @@ WCHAR ff_oem2uni (	/* Returns Unicode character, zero on error */
 {
 	const WCHAR *p;
 	WCHAR c = 0;
-	UINT i, n, li, hi;
+	UINT i = 0, n, li, hi;
 
 
 	if (oem < 0x80) {	/* ASCII? */
 		c = oem;
 
 	} else {			/* Extended char */
-		if (cp == FF_CODE_PAGE) {	/* Is it a valid code page? */
+		if (cp == FF_CODE_PAGE) {	/* Is it valid code page? */
 			p = CVTBL(oem2uni, FF_CODE_PAGE);
 			hi = sizeof CVTBL(oem2uni, FF_CODE_PAGE) / 4 - 1;
 			li = 0;
@@ -15383,7 +15356,7 @@ WCHAR ff_oem2uni (	/* Returns Unicode character, zero on error */
 #if FF_CODE_PAGE == 0
 
 static const WORD cp_code[]          = {  437,   720,   737,   771,   775,   850,   852,   855,   857,   860,   861,   862,   863,   864,   865,   866,   869, 0};
-static const WCHAR *const cp_table[] = {uc437, uc720, uc737, uc771, uc775, uc850, uc852, uc855, uc857, uc860, uc861, uc862, uc863, uc864, uc865, uc866, uc869, 0};
+static const WCHAR* const cp_table[] = {uc437, uc720, uc737, uc771, uc775, uc850, uc852, uc855, uc857, uc860, uc861, uc862, uc863, uc864, uc865, uc866, uc869, 0};
 
 
 WCHAR ff_uni2oem (	/* Returns OEM code character, zero on error */
@@ -15404,20 +15377,20 @@ WCHAR ff_uni2oem (	/* Returns OEM code character, zero on error */
 			uc = (WCHAR)uni;
 			p = 0;
 			if (cp < 900) {	/* SBCS */
-				for (i = 0; cp_code[i] != 0 && cp_code[i] != cp; i++) ;		/* Get table */
+				for (i = 0; cp_code[i] != 0 && cp_code[i] != cp; i++) ;		/* Get conversion table */
 				p = cp_table[i];
-				if (p) {	/* Is it a valid CP ? */
+				if (p) {	/* Is it valid code page ? */
 					for (c = 0; c < 0x80 && uc != p[c]; c++) ;	/* Find OEM code in the table */
 					c = (c + 0x80) & 0xFF;
 				}
 			} else {	/* DBCS */
-				switch (cp) {
+				switch (cp) {	/* Get conversion table */
 				case 932 : p = uni2oem932; hi = sizeof uni2oem932 / 4 - 1; break;
 				case 936 : p = uni2oem936; hi = sizeof uni2oem936 / 4 - 1; break;
 				case 949 : p = uni2oem949; hi = sizeof uni2oem949 / 4 - 1; break;
 				case 950 : p = uni2oem950; hi = sizeof uni2oem950 / 4 - 1; break;
 				}
-				if (p) {	/* Is it a valid code page? */
+				if (p) {	/* Is it valid code page? */
 					li = 0;
 					for (n = 16; n; n--) {	/* Find OEM code */
 						i = li + (hi - li) / 2;
@@ -15496,50 +15469,90 @@ DWORD ff_wtoupper (	/* Returns up-converted code point */
 	DWORD uni		/* Unicode code point to be up-converted */
 )
 {
-	/* Compressed upper conversion table */
-	static const WORD cvt1[] = {	/* U+0000 - U+0FFF */
+	const WORD *p;
+	WORD uc, bc, nc, cmd;
+	static const WORD cvt1[] = {	/* Compressed up conversion table for U+0000 - U+0FFF */
 		/* Basic Latin */
 		0x0061,0x031A,
 		/* Latin-1 Supplement */
-		0x00E0,0x0317,  0x00F8,0x0307,  0x00FF,0x0001,0x0178,
+		0x00E0,0x0317,
+		0x00F8,0x0307,
+		0x00FF,0x0001,0x0178,
 		/* Latin Extended-A */
-		0x0100,0x0130,  0x0132,0x0106,  0x0139,0x0110,  0x014A,0x012E,  0x0179,0x0106,
+		0x0100,0x0130,
+		0x0132,0x0106,
+		0x0139,0x0110,
+		0x014A,0x012E,
+		0x0179,0x0106,
 		/* Latin Extended-B */
 		0x0180,0x004D,0x0243,0x0181,0x0182,0x0182,0x0184,0x0184,0x0186,0x0187,0x0187,0x0189,0x018A,0x018B,0x018B,0x018D,0x018E,0x018F,0x0190,0x0191,0x0191,0x0193,0x0194,0x01F6,0x0196,0x0197,0x0198,0x0198,0x023D,0x019B,0x019C,0x019D,0x0220,0x019F,0x01A0,0x01A0,0x01A2,0x01A2,0x01A4,0x01A4,0x01A6,0x01A7,0x01A7,0x01A9,0x01AA,0x01AB,0x01AC,0x01AC,0x01AE,0x01AF,0x01AF,0x01B1,0x01B2,0x01B3,0x01B3,0x01B5,0x01B5,0x01B7,0x01B8,0x01B8,0x01BA,0x01BB,0x01BC,0x01BC,0x01BE,0x01F7,0x01C0,0x01C1,0x01C2,0x01C3,0x01C4,0x01C5,0x01C4,0x01C7,0x01C8,0x01C7,0x01CA,0x01CB,0x01CA,
-		0x01CD,0x0110,  0x01DD,0x0001,0x018E,  0x01DE,0x0112,  0x01F3,0x0003,0x01F1,0x01F4,0x01F4,  0x01F8,0x0128,
-		0x0222,0x0112,  0x023A,0x0009,0x2C65,0x023B,0x023B,0x023D,0x2C66,0x023F,0x0240,0x0241,0x0241,  0x0246,0x010A,
+		0x01CD,0x0110,
+		0x01DD,0x0001,0x018E,
+		0x01DE,0x0112,
+		0x01F3,0x0003,0x01F1,0x01F4,0x01F4,
+		0x01F8,0x0128,
+		0x0222,0x0112,
+		0x023A,0x0009,0x2C65,0x023B,0x023B,0x023D,0x2C66,0x023F,0x0240,0x0241,0x0241,
+		0x0246,0x010A,
 		/* IPA Extensions */
 		0x0253,0x0040,0x0181,0x0186,0x0255,0x0189,0x018A,0x0258,0x018F,0x025A,0x0190,0x025C,0x025D,0x025E,0x025F,0x0193,0x0261,0x0262,0x0194,0x0264,0x0265,0x0266,0x0267,0x0197,0x0196,0x026A,0x2C62,0x026C,0x026D,0x026E,0x019C,0x0270,0x0271,0x019D,0x0273,0x0274,0x019F,0x0276,0x0277,0x0278,0x0279,0x027A,0x027B,0x027C,0x2C64,0x027E,0x027F,0x01A6,0x0281,0x0282,0x01A9,0x0284,0x0285,0x0286,0x0287,0x01AE,0x0244,0x01B1,0x01B2,0x0245,0x028D,0x028E,0x028F,0x0290,0x0291,0x01B7,
 		/* Greek, Coptic */
-		0x037B,0x0003,0x03FD,0x03FE,0x03FF,  0x03AC,0x0004,0x0386,0x0388,0x0389,0x038A,  0x03B1,0x0311,
-		0x03C2,0x0002,0x03A3,0x03A3,  0x03C4,0x0308,  0x03CC,0x0003,0x038C,0x038E,0x038F,  0x03D8,0x0118,
+		0x037B,0x0003,0x03FD,0x03FE,0x03FF,
+		0x03AC,0x0004,0x0386,0x0388,0x0389,0x038A,
+		0x03B1,0x0311,
+		0x03C2,0x0002,0x03A3,0x03A3,
+		0x03C4,0x0308,
+		0x03CC,0x0003,0x038C,0x038E,0x038F,
+		0x03D8,0x0118,
 		0x03F2,0x000A,0x03F9,0x03F3,0x03F4,0x03F5,0x03F6,0x03F7,0x03F7,0x03F9,0x03FA,0x03FA,
 		/* Cyrillic */
-		0x0430,0x0320,  0x0450,0x0710,  0x0460,0x0122,  0x048A,0x0136,  0x04C1,0x010E,  0x04CF,0x0001,0x04C0,  0x04D0,0x0144,
+		0x0430,0x0320,
+		0x0450,0x0710,
+		0x0460,0x0122,
+		0x048A,0x0136,
+		0x04C1,0x010E,
+		0x04CF,0x0001,0x04C0,
+		0x04D0,0x0144,
 		/* Armenian */
 		0x0561,0x0426,
 
-		0x0000
+		0x0000	/* EOT */
 	};
-	static const WORD cvt2[] = {	/* U+1000 - U+FFFF */
+	static const WORD cvt2[] = {	/* Compressed up conversion table for U+1000 - U+FFFF */
 		/* Phonetic Extensions */
 		0x1D7D,0x0001,0x2C63,
 		/* Latin Extended Additional */
-		0x1E00,0x0196,  0x1EA0,0x015A,
+		0x1E00,0x0196,
+		0x1EA0,0x015A,
 		/* Greek Extended */
-		0x1F00,0x0608,  0x1F10,0x0606,  0x1F20,0x0608,  0x1F30,0x0608,  0x1F40,0x0606,
-		0x1F51,0x0007,0x1F59,0x1F52,0x1F5B,0x1F54,0x1F5D,0x1F56,0x1F5F,  0x1F60,0x0608,
+		0x1F00,0x0608,
+		0x1F10,0x0606,
+		0x1F20,0x0608,
+		0x1F30,0x0608,
+		0x1F40,0x0606,
+		0x1F51,0x0007,0x1F59,0x1F52,0x1F5B,0x1F54,0x1F5D,0x1F56,0x1F5F,
+		0x1F60,0x0608,
 		0x1F70,0x000E,0x1FBA,0x1FBB,0x1FC8,0x1FC9,0x1FCA,0x1FCB,0x1FDA,0x1FDB,0x1FF8,0x1FF9,0x1FEA,0x1FEB,0x1FFA,0x1FFB,
-		0x1F80,0x0608,  0x1F90,0x0608,  0x1FA0,0x0608,  0x1FB0,0x0004,0x1FB8,0x1FB9,0x1FB2,0x1FBC,
-		0x1FCC,0x0001,0x1FC3,  0x1FD0,0x0602,  0x1FE0,0x0602,  0x1FE5,0x0001,0x1FEC,  0x1FF3,0x0001,0x1FFC,
+		0x1F80,0x0608,
+		0x1F90,0x0608,
+		0x1FA0,0x0608,
+		0x1FB0,0x0004,0x1FB8,0x1FB9,0x1FB2,0x1FBC,
+		0x1FCC,0x0001,0x1FC3,
+		0x1FD0,0x0602,
+		0x1FE0,0x0602,
+		0x1FE5,0x0001,0x1FEC,
+		0x1FF3,0x0001,0x1FFC,
 		/* Letterlike Symbols */
 		0x214E,0x0001,0x2132,
 		/* Number forms */
-		0x2170,0x0210,  0x2184,0x0001,0x2183,
+		0x2170,0x0210,
+		0x2184,0x0001,0x2183,
 		/* Enclosed Alphanumerics */
-		0x24D0,0x051A,  0x2C30,0x042F,
+		0x24D0,0x051A,
+		0x2C30,0x042F,
 		/* Latin Extended-C */
-		0x2C60,0x0102,  0x2C67,0x0106, 0x2C75,0x0102,
+		0x2C60,0x0102,
+		0x2C67,0x0106, 0x2C75,0x0102,
 		/* Coptic */
 		0x2C80,0x0164,
 		/* Georgian Supplement */
@@ -15547,18 +15560,16 @@ DWORD ff_wtoupper (	/* Returns up-converted code point */
 		/* Full-width */
 		0xFF41,0x031A,
 
-		0x0000
+		0x0000	/* EOT */
 	};
-	const WORD *p;
-	WORD uc, bc, nc, cmd;
 
 
 	if (uni < 0x10000) {	/* Is it in BMP? */
 		uc = (WORD)uni;
 		p = uc < 0x1000 ? cvt1 : cvt2;
 		for (;;) {
-			bc = *p++;								/* Get block base */
-			if (!bc || uc < bc) break;
+			bc = *p++;								/* Get the block base */
+			if (bc == 0 || uc < bc) break;			/* Not matched? */
 			nc = *p++; cmd = nc >> 8; nc &= 0xFF;	/* Get processing command and block size */
 			if (uc < bc + nc) {	/* In the block? */
 				switch (cmd) {
@@ -15574,7 +15585,7 @@ DWORD ff_wtoupper (	/* Returns up-converted code point */
 				}
 				break;
 			}
-			if (!cmd) p += nc;
+			if (cmd == 0) p += nc;	/* Skip table if needed */
 		}
 		uni = uc;
 	}
diff --git a/components/fatfs/src/integer.h b/components/fatfs/src/integer.h
deleted file mode 100644
index 4fcf5c443..000000000
--- a/components/fatfs/src/integer.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*-------------------------------------------*/
-/* Integer type definitions for FatFs module */
-/*-------------------------------------------*/
-
-#ifndef FF_INTEGER
-#define FF_INTEGER
-
-#ifdef _WIN32	/* FatFs development platform */
-
-#include <windows.h>
-#include <tchar.h>
-typedef unsigned __int64 QWORD;
-
-
-#else			/* Embedded platform */
-
-/* These types MUST be 16-bit or 32-bit */
-typedef int				INT;
-typedef unsigned int	UINT;
-
-/* This type MUST be 8-bit */
-typedef unsigned char	BYTE;
-
-/* These types MUST be 16-bit */
-typedef short			SHORT;
-typedef unsigned short	WORD;
-typedef unsigned short	WCHAR;
-
-/* These types MUST be 32-bit */
-typedef long			LONG;
-typedef unsigned long	DWORD;
-
-/* This type MUST be 64-bit (Remove this for ANSI C (C89) compatibility) */
-typedef unsigned long long QWORD;
-
-#endif
-
-#endif
diff --git a/components/fatfs/src/vfs_fat_sdmmc.c b/components/fatfs/src/vfs_fat_sdmmc.c
deleted file mode 100644
index 131a0493a..000000000
--- a/components/fatfs/src/vfs_fat_sdmmc.c
+++ /dev/null
@@ -1,184 +0,0 @@
-// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-#include <stdlib.h>
-#include <string.h>
-#include "esp_log.h"
-#include "esp_vfs.h"
-#include "esp_vfs_fat.h"
-#include "vfs_fat_internal.h"
-#include "driver/sdmmc_host.h"
-#include "driver/sdspi_host.h"
-#include "sdmmc_cmd.h"
-#include "diskio.h"
-
-static const char* TAG = "vfs_fat_sdmmc";
-static sdmmc_card_t* s_card = NULL;
-static uint8_t s_pdrv = 0;
-static char * s_base_path = NULL;
-
-esp_err_t esp_vfs_fat_sdmmc_mount(const char* base_path,
-    const sdmmc_host_t* host_config,
-    const void* slot_config,
-    const esp_vfs_fat_mount_config_t* mount_config,
-    sdmmc_card_t** out_card)
-{
-    const size_t workbuf_size = 4096;
-    void* workbuf = NULL;
-    FATFS* fs = NULL;
-
-    if (s_card != NULL) {
-        return ESP_ERR_INVALID_STATE;
-    }
-
-    // connect SDMMC driver to FATFS
-    BYTE pdrv = 0xFF;
-    if (ff_diskio_get_drive(&pdrv) != ESP_OK || pdrv == 0xFF) {
-        ESP_LOGD(TAG, "the maximum count of volumes is already mounted");
-        return ESP_ERR_NO_MEM;
-    }
-
-    s_base_path = strdup(base_path);
-    if(!s_base_path){
-        ESP_LOGD(TAG, "could not copy base_path");
-        return ESP_ERR_NO_MEM;
-    }
-    esp_err_t err = ESP_OK;
-    // not using ff_memalloc here, as allocation in internal RAM is preferred
-    s_card = malloc(sizeof(sdmmc_card_t));
-    if (s_card == NULL) {
-        err = ESP_ERR_NO_MEM;
-        goto fail;
-    }
-
-    err = (*host_config->init)();
-    if (err != ESP_OK) {
-        ESP_LOGD(TAG, "host init returned rc=0x%x", err);
-        goto fail;
-    }
-
-    // configure SD slot
-    if (host_config->flags == SDMMC_HOST_FLAG_SPI) {
-        err = sdspi_host_init_slot(host_config->slot,
-                (const sdspi_slot_config_t*) slot_config);
-    } else {
-        err = sdmmc_host_init_slot(host_config->slot,
-                (const sdmmc_slot_config_t*) slot_config);
-    }
-    if (err != ESP_OK) {
-        ESP_LOGD(TAG, "slot_config returned rc=0x%x", err);
-        goto fail;
-    }
-
-    // probe and initialize card
-    err = sdmmc_card_init(host_config, s_card);
-    if (err != ESP_OK) {
-        ESP_LOGD(TAG, "sdmmc_card_init failed 0x(%x)", err);
-        goto fail;
-    }
-    if (out_card != NULL) {
-        *out_card = s_card;
-    }
-
-    ff_diskio_register_sdmmc(pdrv, s_card);
-    s_pdrv = pdrv;
-    ESP_LOGD(TAG, "using pdrv=%i", pdrv);
-    char drv[3] = {(char)('0' + pdrv), ':', 0};
-
-    // connect FATFS to VFS
-    err = esp_vfs_fat_register(base_path, drv, mount_config->max_files, &fs);
-    if (err == ESP_ERR_INVALID_STATE) {
-        // it's okay, already registered with VFS
-    } else if (err != ESP_OK) {
-        ESP_LOGD(TAG, "esp_vfs_fat_register failed 0x(%x)", err);
-        goto fail;
-    }
-
-    // Try to mount partition
-    FRESULT res = f_mount(fs, drv, 1);
-    if (res != FR_OK) {
-        err = ESP_FAIL;
-        ESP_LOGW(TAG, "failed to mount card (%d)", res);
-        if (!(res == FR_NO_FILESYSTEM && mount_config->format_if_mount_failed)) {
-            goto fail;
-        }
-        ESP_LOGW(TAG, "partitioning card");
-        workbuf = ff_memalloc(workbuf_size);
-        if (workbuf == NULL) {
-            err = ESP_ERR_NO_MEM;
-            goto fail;
-        }
-        DWORD plist[] = {100, 0, 0, 0};
-        res = f_fdisk(s_pdrv, plist, workbuf);
-        if (res != FR_OK) {
-            err = ESP_FAIL;
-            ESP_LOGD(TAG, "f_fdisk failed (%d)", res);
-            goto fail;
-        }
-        size_t alloc_unit_size = esp_vfs_fat_get_allocation_unit_size(
-                s_card->csd.sector_size,
-                mount_config->allocation_unit_size);
-        ESP_LOGW(TAG, "formatting card, allocation unit size=%d", alloc_unit_size);
-        res = f_mkfs(drv, FM_ANY, alloc_unit_size, workbuf, workbuf_size);
-        if (res != FR_OK) {
-            err = ESP_FAIL;
-            ESP_LOGD(TAG, "f_mkfs failed (%d)", res);
-            goto fail;
-        }
-        free(workbuf);
-        workbuf = NULL;
-        ESP_LOGW(TAG, "mounting again");
-        res = f_mount(fs, drv, 0);
-        if (res != FR_OK) {
-            err = ESP_FAIL;
-            ESP_LOGD(TAG, "f_mount failed after formatting (%d)", res);
-            goto fail;
-        }
-    }
-    return ESP_OK;
-
-fail:
-    host_config->deinit();
-    free(workbuf);
-    if (fs) {
-        f_mount(NULL, drv, 0);
-    }
-    esp_vfs_fat_unregister_path(base_path);
-    ff_diskio_unregister(pdrv);
-    free(s_card);
-    s_card = NULL;
-    free(s_base_path);
-    s_base_path = NULL;
-    return err;
-}
-
-esp_err_t esp_vfs_fat_sdmmc_unmount()
-{
-    if (s_card == NULL) {
-        return ESP_ERR_INVALID_STATE;
-    }
-    // unmount
-    char drv[3] = {(char)('0' + s_pdrv), ':', 0};
-    f_mount(0, drv, 0);
-    // release SD driver
-    esp_err_t (*host_deinit)() = s_card->host.deinit;
-    ff_diskio_unregister(s_pdrv);
-    free(s_card);
-    s_card = NULL;
-    (*host_deinit)();
-    esp_err_t err = esp_vfs_fat_unregister_path(s_base_path);
-    free(s_base_path);
-    s_base_path = NULL;
-    return err;
-}
diff --git a/components/fatfs/test/CMakeLists.txt b/components/fatfs/test/CMakeLists.txt
index 5e0431c46..bb32fd2d9 100644
--- a/components/fatfs/test/CMakeLists.txt
+++ b/components/fatfs/test/CMakeLists.txt
@@ -1,8 +1,5 @@
-set(COMPONENT_SRCDIRS ".")
-set(COMPONENT_ADD_INCLUDEDIRS ".")
-
-set(COMPONENT_REQUIRES unity test_utils vfs fatfs)
-
-set(COMPONENT_EMBED_TXTFILES fatfs.img)
-
-register_component()
\ No newline at end of file
+idf_component_register(SRC_DIRS .
+                       INCLUDE_DIRS .
+                       REQUIRES unity test_utils vfs fatfs
+                       EMBED_TXTFILES fatfs.img
+                      )
\ No newline at end of file
diff --git a/components/fatfs/test/test_fatfs_common.c b/components/fatfs/test/test_fatfs_common.c
index 77e53707c..09e293826 100644
--- a/components/fatfs/test/test_fatfs_common.c
+++ b/components/fatfs/test/test_fatfs_common.c
@@ -16,8 +16,10 @@
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#include <fcntl.h>
 #include <sys/time.h>
 #include <sys/unistd.h>
+#include <sys/stat.h>
 #include <errno.h>
 #include <utime.h>
 #include "unity.h"
@@ -98,6 +100,88 @@ void test_fatfs_read_file_utf_8(const char* filename)
     TEST_ASSERT_EQUAL(0, fclose(f));
 }
 
+void test_fatfs_pread_file(const char* filename)
+{
+    char buf[32] = { 0 };
+    const int fd = open(filename, O_RDONLY);
+    TEST_ASSERT_NOT_EQUAL(-1, fd);
+
+    int r = pread(fd, buf, sizeof(buf), 0); // it is a regular read() with offset==0
+    TEST_ASSERT_EQUAL(0, strcmp(fatfs_test_hello_str, buf));
+    TEST_ASSERT_EQUAL(strlen(fatfs_test_hello_str), r);
+
+    memset(buf, 0, sizeof(buf));
+    r = pread(fd, buf, sizeof(buf), 1); // offset==1
+    TEST_ASSERT_EQUAL(0, strcmp(fatfs_test_hello_str + 1, buf));
+    TEST_ASSERT_EQUAL(strlen(fatfs_test_hello_str) - 1, r);
+
+    memset(buf, 0, sizeof(buf));
+    r = pread(fd, buf, sizeof(buf), 5); // offset==5
+    TEST_ASSERT_EQUAL(0, strcmp(fatfs_test_hello_str + 5, buf));
+    TEST_ASSERT_EQUAL(strlen(fatfs_test_hello_str) - 5, r);
+
+    // regular read() should work now because pread() should not affect the current position in file
+
+    memset(buf, 0, sizeof(buf));
+    r = read(fd, buf, sizeof(buf)); // note that this is read() and not pread()
+    TEST_ASSERT_EQUAL(0, strcmp(fatfs_test_hello_str, buf));
+    TEST_ASSERT_EQUAL(strlen(fatfs_test_hello_str), r);
+
+    memset(buf, 0, sizeof(buf));
+    r = pread(fd, buf, sizeof(buf), 10); // offset==10
+    TEST_ASSERT_EQUAL(0, strcmp(fatfs_test_hello_str + 10, buf));
+    TEST_ASSERT_EQUAL(strlen(fatfs_test_hello_str) - 10, r);
+
+    memset(buf, 0, sizeof(buf));
+    r = pread(fd, buf, sizeof(buf), strlen(fatfs_test_hello_str) + 1); // offset to EOF
+    TEST_ASSERT_EQUAL(0, r);
+
+    TEST_ASSERT_EQUAL(0, close(fd));
+}
+
+static void test_pwrite(const char *filename, off_t offset, const char *msg)
+{
+    const int fd = open(filename, O_WRONLY);
+    TEST_ASSERT_NOT_EQUAL(-1, fd);
+
+    const off_t current_pos = lseek(fd, 0, SEEK_END); // O_APPEND is not the same - jumps to the end only before write()
+
+    const int r = pwrite(fd, msg, strlen(msg), offset);
+    TEST_ASSERT_EQUAL(strlen(msg), r);
+
+    TEST_ASSERT_EQUAL(current_pos, lseek(fd, 0, SEEK_CUR)); // pwrite should not move the pointer
+
+    TEST_ASSERT_EQUAL(0, close(fd));
+}
+
+static void test_file_content(const char *filename, const char *msg)
+{
+    char buf[32] = { 0 };
+    const int fd = open(filename, O_RDONLY);
+    TEST_ASSERT_NOT_EQUAL(-1, fd);
+
+    int r = read(fd, buf, sizeof(buf));
+    TEST_ASSERT_NOT_EQUAL(-1, r);
+    TEST_ASSERT_EQUAL(0, strcmp(msg, buf));
+
+    TEST_ASSERT_EQUAL(0, close(fd));
+}
+
+void test_fatfs_pwrite_file(const char *filename)
+{
+    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC);
+    TEST_ASSERT_NOT_EQUAL(-1, fd);
+    TEST_ASSERT_EQUAL(0, close(fd));
+
+    test_pwrite(filename, 0, "Hello");
+    test_file_content(filename, "Hello");
+
+    test_pwrite(filename, strlen("Hello"), ", world!");
+    test_file_content(filename, "Hello, world!");
+    test_pwrite(filename, strlen("Hello, "), "Dolly");
+    test_file_content(filename, "Hello, Dolly!");
+}
+
 void test_fatfs_open_max_files(const char* filename_prefix, size_t files_count)
 {
     FILE** files = calloc(files_count, sizeof(FILE*));
diff --git a/components/fatfs/test/test_fatfs_common.h b/components/fatfs/test/test_fatfs_common.h
index ba330b6b6..0a792434b 100644
--- a/components/fatfs/test/test_fatfs_common.h
+++ b/components/fatfs/test/test_fatfs_common.h
@@ -41,6 +41,10 @@ void test_fatfs_read_file(const char* filename);
 
 void test_fatfs_read_file_utf_8(const char* filename);
 
+void test_fatfs_pread_file(const char* filename);
+
+void test_fatfs_pwrite_file(const char* filename);
+
 void test_fatfs_open_max_files(const char* filename_prefix, size_t files_count);
 
 void test_fatfs_lseek(const char* filename);
diff --git a/components/fatfs/test/test_fatfs_rawflash.c b/components/fatfs/test/test_fatfs_rawflash.c
index 5e60bb296..ca949e1ab 100644
--- a/components/fatfs/test/test_fatfs_rawflash.c
+++ b/components/fatfs/test/test_fatfs_rawflash.c
@@ -43,15 +43,24 @@ static void test_setup(size_t max_files)
 
     TEST_ASSERT(part->size == (fatfs_end - fatfs_start - 1));
 
-    esp_partition_erase_range(part, 0, part->size);
-    for (int i = 0; i < part->size; i+= SPI_FLASH_SEC_SIZE) {
-        ESP_ERROR_CHECK( esp_partition_write(part, i, fatfs_start + i, SPI_FLASH_SEC_SIZE) );
+    spi_flash_mmap_handle_t mmap_handle;
+    const void* mmap_ptr;
+    TEST_ESP_OK(esp_partition_mmap(part, 0, part->size, SPI_FLASH_MMAP_DATA, &mmap_ptr, &mmap_handle));
+    bool content_valid = memcmp(fatfs_start, mmap_ptr, part->size) == 0;
+    spi_flash_munmap(mmap_handle);
+
+    if (!content_valid) {
+        printf("Copying fatfs.img into test partition...\n");
+        esp_partition_erase_range(part, 0, part->size);
+        for (int i = 0; i < part->size; i+= SPI_FLASH_SEC_SIZE) {
+            ESP_ERROR_CHECK( esp_partition_write(part, i, fatfs_start + i, SPI_FLASH_SEC_SIZE) );
+        }
     }
 
     TEST_ESP_OK(esp_vfs_fat_rawflash_mount("/spiflash", "flash_test", &mount_config));
 }
 
-static void test_teardown()
+static void test_teardown(void)
 {
     TEST_ESP_OK(esp_vfs_fat_rawflash_unmount("/spiflash","flash_test"));
 }
@@ -319,12 +328,8 @@ TEST_CASE("(raw) multiple tasks can use same volume", "[fatfs]")
     test_teardown();
 }
 
-TEST_CASE("(raw) write/read speed test", "[fatfs][timeout=60]")
+TEST_CASE("(raw) read speed test", "[fatfs][timeout=60]")
 {
-    /* Erase partition before running the test to get consistent results */
-    const esp_partition_t* part = get_test_data_partition();
-    esp_partition_erase_range(part, 0, part->size);
-
     test_setup(5);
 
     const size_t buf_size = 16 * 1024;
diff --git a/components/fatfs/test/test_fatfs_sdmmc.c b/components/fatfs/test/test_fatfs_sdmmc.c
index e1a6cfb3b..d6fd3b143 100644
--- a/components/fatfs/test/test_fatfs_sdmmc.c
+++ b/components/fatfs/test/test_fatfs_sdmmc.c
@@ -25,12 +25,21 @@
 #include "esp_vfs_fat.h"
 #include "freertos/FreeRTOS.h"
 #include "freertos/task.h"
-#include "driver/sdmmc_host.h"
 #include "driver/sdmmc_defs.h"
 #include "sdmmc_cmd.h"
-#include "diskio.h"
 #include "ff.h"
 #include "test_fatfs_common.h"
+#include "soc/soc_caps.h"
+
+#define SDSPI_MOSI_PIN  15
+#define SDSPI_MISO_PIN  2
+#define SDSPI_CS_PIN    13
+#define SDSPI_CLK_PIN   14
+#define SDSPI_HOST_ID   HSPI_HOST
+
+
+#ifdef SOC_SDMMC_HOST_SUPPORTED
+#include "driver/sdmmc_host.h"
 
 
 static void test_setup(void)
@@ -87,6 +96,20 @@ TEST_CASE("(SD) can read file", "[fatfs][test_env=UT_T1_SDMODE]")
     test_teardown();
 }
 
+TEST_CASE("(SD) can read file with pread()", "[fatfs][test_env=UT_T1_SDMODE]")
+{
+    test_setup();
+    test_fatfs_create_file_with_text(test_filename, fatfs_test_hello_str);
+    test_fatfs_pread_file(test_filename);
+    test_teardown();
+}
+
+TEST_CASE("(SD) pwrite() works well", "[fatfs][test_env=UT_T1_SDMODE]")
+{
+    test_setup();
+    test_fatfs_pwrite_file(test_filename);
+    test_teardown();
+}
 
 TEST_CASE("(SD) overwrite and append file", "[fatfs][sd][test_env=UT_T1_SDMODE]")
 {
@@ -165,7 +188,7 @@ TEST_CASE("(SD) multiple tasks can use same volume", "[fatfs][test_env=UT_T1_SDM
     test_teardown();
 }
 
-static void speed_test(void* buf, size_t buf_size, size_t file_size, bool write);
+static void sdmmc_speed_test(void *buf, size_t buf_size, size_t file_size, bool write);
 
 TEST_CASE("(SD) write/read speed test", "[fatfs][sd][test_env=UT_T1_SDMODE][timeout=60]")
 {
@@ -177,20 +200,20 @@ TEST_CASE("(SD) write/read speed test", "[fatfs][sd][test_env=UT_T1_SDMODE][time
     esp_fill_random(buf, buf_size);
     const size_t file_size = 1 * 1024 * 1024;
 
-    speed_test(buf, 4 * 1024, file_size, true);
-    speed_test(buf, 8 * 1024, file_size, true);
-    speed_test(buf, 16 * 1024, file_size, true);
+    sdmmc_speed_test(buf, 4 * 1024, file_size, true);
+    sdmmc_speed_test(buf, 8 * 1024, file_size, true);
+    sdmmc_speed_test(buf, 16 * 1024, file_size, true);
 
-    speed_test(buf, 4 * 1024, file_size, false);
-    speed_test(buf, 8 * 1024, file_size, false);
-    speed_test(buf, 16 * 1024, file_size, false);
+    sdmmc_speed_test(buf, 4 * 1024, file_size, false);
+    sdmmc_speed_test(buf, 8 * 1024, file_size, false);
+    sdmmc_speed_test(buf, 16 * 1024, file_size, false);
 
     free(buf);
 
     HEAP_SIZE_CHECK(heap_size, 0);
 }
 
-static void speed_test(void* buf, size_t buf_size, size_t file_size, bool write)
+static void sdmmc_speed_test(void *buf, size_t buf_size, size_t file_size, bool write)
 {
     sdmmc_host_t host = SDMMC_HOST_DEFAULT();
     host.max_freq_khz = SDMMC_FREQ_HIGHSPEED;
@@ -281,3 +304,73 @@ TEST_CASE("(SD) opendir, readdir, rewinddir, seekdir work as expected using UTF-
     test_teardown();
 }
 #endif // CONFIG_FATFS_API_ENCODING_UTF_8 && CONFIG_FATFS_CODEPAGE == 936
+
+#endif  //SDMMC HOST SUPPORTED
+
+#if !TEMPORARY_DISABLED_FOR_TARGETS(ESP32S2BETA)
+
+static void sdspi_speed_test(void *buf, size_t buf_size, size_t file_size, bool write);
+
+TEST_CASE("(SDSPI) write/read speed test", "[fatfs][sd][test_env=UT_T1_SPIMODE][timeout=60]")
+{
+    size_t heap_size;
+    HEAP_SIZE_CAPTURE(heap_size);
+
+    const size_t buf_size = 16 * 1024;
+    uint32_t* buf = (uint32_t*) calloc(1, buf_size);
+    esp_fill_random(buf, buf_size);
+    const size_t file_size = 1 * 1024 * 1024;
+
+    spi_bus_config_t bus_cfg = {
+        .mosi_io_num = SDSPI_MOSI_PIN,
+        .miso_io_num = SDSPI_MISO_PIN,
+        .sclk_io_num = SDSPI_CLK_PIN,
+        .quadwp_io_num = -1,
+        .quadhd_io_num = -1,
+        .max_transfer_sz = 4000,
+    };
+    esp_err_t err = spi_bus_initialize(SDSPI_HOST_ID, &bus_cfg, 1);
+    TEST_ESP_OK(err);
+
+    sdspi_speed_test(buf, 4 * 1024, file_size, true);
+    sdspi_speed_test(buf, 8 * 1024, file_size, true);
+    sdspi_speed_test(buf, 16 * 1024, file_size, true);
+
+    sdspi_speed_test(buf, 4 * 1024, file_size, false);
+    sdspi_speed_test(buf, 8 * 1024, file_size, false);
+    sdspi_speed_test(buf, 16 * 1024, file_size, false);
+
+    free(buf);
+    spi_bus_free(SDSPI_HOST_ID);
+
+    HEAP_SIZE_CHECK(heap_size, 0);
+}
+
+static void sdspi_speed_test(void *buf, size_t buf_size, size_t file_size, bool write)
+{
+    const char path[] = "/sdcard";
+    sdmmc_card_t *card;
+    card = NULL;
+    sdspi_device_config_t device_cfg = {
+        .gpio_cs = SDSPI_CS_PIN,
+        .host_id = SDSPI_HOST_ID,
+        .gpio_cd = SDSPI_SLOT_NO_CD,
+        .gpio_wp = SDSPI_SLOT_NO_WP,
+        .gpio_int = SDSPI_SLOT_NO_INT,
+    };
+
+    sdmmc_host_t host = SDSPI_HOST_DEFAULT();
+    host.slot = SDSPI_HOST_ID;
+    esp_vfs_fat_sdmmc_mount_config_t mount_config = {
+        .format_if_mount_failed = write,
+        .max_files = 5,
+        .allocation_unit_size = 64 * 1024
+    };
+    TEST_ESP_OK(esp_vfs_fat_sdspi_mount(path, &host, &device_cfg, &mount_config, &card));
+
+    test_fatfs_rw_speed("/sdcard/4mb.bin", buf, buf_size, file_size, write);
+
+    TEST_ESP_OK(esp_vfs_fat_sdcard_unmount(path, card));
+}
+
+#endif
\ No newline at end of file
diff --git a/components/fatfs/test/test_fatfs_spiflash.c b/components/fatfs/test/test_fatfs_spiflash.c
index 6c3355939..64dbe4ff0 100644
--- a/components/fatfs/test/test_fatfs_spiflash.c
+++ b/components/fatfs/test/test_fatfs_spiflash.c
@@ -32,7 +32,7 @@
 
 
 static wl_handle_t s_test_wl_handle;
-static void test_setup()
+static void test_setup(void)
 {
     esp_vfs_fat_sdmmc_mount_config_t mount_config = {
         .format_if_mount_failed = true,
@@ -42,7 +42,7 @@ static void test_setup()
     TEST_ESP_OK(esp_vfs_fat_spiflash_mount("/spiflash", NULL, &mount_config, &s_test_wl_handle));
 }
 
-static void test_teardown()
+static void test_teardown(void)
 {
     TEST_ESP_OK(esp_vfs_fat_spiflash_unmount("/spiflash", s_test_wl_handle));
 }
@@ -70,6 +70,21 @@ TEST_CASE("(WL) can read file", "[fatfs][wear_levelling]")
     test_teardown();
 }
 
+TEST_CASE("(WL) can read file with pread", "[fatfs][wear_levelling]")
+{
+    test_setup();
+    test_fatfs_create_file_with_text("/spiflash/hello.txt", fatfs_test_hello_str);
+    test_fatfs_pread_file("/spiflash/hello.txt");
+    test_teardown();
+}
+
+TEST_CASE("(WL) pwrite() works well", "[fatfs][wear_levelling]")
+{
+    test_setup();
+    test_fatfs_pwrite_file("/spiflash/hello.txt");
+    test_teardown();
+}
+
 TEST_CASE("(WL) can open maximum number of files", "[fatfs][wear_levelling]")
 {
     size_t max_files = FOPEN_MAX - 3; /* account for stdin, stdout, stderr */
diff --git a/components/fatfs/test_fatfs_host/Makefile b/components/fatfs/test_fatfs_host/Makefile
index 4c43e16aa..2e63322c0 100644
--- a/components/fatfs/test_fatfs_host/Makefile
+++ b/components/fatfs/test_fatfs_host/Makefile
@@ -58,13 +58,13 @@ OBJ_FILES := $(addprefix $(BUILD_DIR)/, $(filter %.o, $(notdir $(SOURCE_FILES:.c
 
 define COMPILE_C
 $(call CTARGET, ${1}, $(BUILD_DIR)) : ${1} $(SDKCONFIG)
-	mkdir -p $(BUILD_DIR) 
+	mkdir -p $(BUILD_DIR)
 	$(CC) $(CPPFLAGS) $(CFLAGS) -c -o $(call CTARGET, ${1}, $(BUILD_DIR)) ${1}
 endef
 
 define COMPILE_CPP
 $(call CPPTARGET, ${1}, $(BUILD_DIR)) : ${1} $(SDKCONFIG)
-	mkdir -p $(BUILD_DIR) 
+	mkdir -p $(BUILD_DIR)
 	$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c -o $(call CPPTARGET, ${1}, $(BUILD_DIR)) ${1}
 endef
 
@@ -81,12 +81,11 @@ $(foreach cxxfile, $(CPPFILES), $(eval $(call COMPILE_CPP, $(cxxfile))))
 TEST_SOURCE_FILES = \
 	test_fatfs.cpp \
 	main.cpp \
-	test_utils.c
 
 TEST_OBJ_FILES = $(filter %.o, $(TEST_SOURCE_FILES:.cpp=.o) $(TEST_SOURCE_FILES:.c=.o))
 
 $(TEST_PROGRAM): lib $(TEST_OBJ_FILES) $(WEAR_LEVELLING_BUILD_DIR)/$(WEAR_LEVELLING_LIB) $(SPI_FLASH_SIM_BUILD_DIR)/$(SPI_FLASH_SIM_LIB) $(STUBS_LIB_BUILD_DIR)/$(STUBS_LIB) partition_table.bin $(SDKCONFIG)
-	g++ $(LDFLAGS) $(CXXFLAGS) -o $@  $(TEST_OBJ_FILES) -L$(BUILD_DIR) -l:$(COMPONENT_LIB) -L$(WEAR_LEVELLING_BUILD_DIR) -l:$(WEAR_LEVELLING_LIB) -L$(SPI_FLASH_SIM_BUILD_DIR) -l:$(SPI_FLASH_SIM_LIB) -L$(STUBS_LIB_BUILD_DIR) -l:$(STUBS_LIB) 
+	g++ $(LDFLAGS) $(CXXFLAGS) -o $@  $(TEST_OBJ_FILES) -L$(BUILD_DIR) -l:$(COMPONENT_LIB) -L$(WEAR_LEVELLING_BUILD_DIR) -l:$(WEAR_LEVELLING_LIB) -L$(SPI_FLASH_SIM_BUILD_DIR) -l:$(SPI_FLASH_SIM_LIB) -L$(STUBS_LIB_BUILD_DIR) -l:$(STUBS_LIB)
 
 test: $(TEST_PROGRAM)
 	./$(TEST_PROGRAM)
diff --git a/components/fatfs/test_fatfs_host/Makefile.files b/components/fatfs/test_fatfs_host/Makefile.files
index 267148577..2055ab890 100644
--- a/components/fatfs/test_fatfs_host/Makefile.files
+++ b/components/fatfs/test_fatfs_host/Makefile.files
@@ -1,30 +1,39 @@
 SOURCE_FILES := \
 	$(addprefix ../src/, \
-	diskio.c \
-	ff.c \
-	ffsystem.c \
-	ffunicode.c \
-	diskio_wl.c \
-	) 
+		ff.c \
+		ffunicode.c \
+	) \
+	$(addprefix ../diskio/,\
+		diskio.c \
+		diskio_wl.c \
+	) \
+	../port/linux/ffsystem.c
 
 INCLUDE_DIRS := \
 	. \
+	../diskio \
 	../src \
 	$(addprefix ../../spi_flash/sim/stubs/, \
-	app_update/include \
-	driver/include \
-	esp32/include \
-	freertos/include \
-	log/include \
-	newlib/include \
-	sdmmc/include \
-	vfs/include \
+		app_update/include \
+		driver/include \
+		esp32/include \
+		freertos/include \
+		log/include \
+		newlib/include \
+		sdmmc/include \
+		vfs/include \
 	) \
 	$(addprefix ../../../components/, \
-	soc/esp32/include \
-	esp32/include \
-	bootloader_support/include \
-	app_update/include \
-	spi_flash/include \
-	wear_levelling/include \
+		esp_rom/include \
+		xtensa/include \
+		xtensa/esp32/include \
+		soc/soc/esp32/include \
+		soc/include \
+		soc/soc/include \
+		esp32/include \
+		esp_common/include \
+		bootloader_support/include \
+		app_update/include \
+		spi_flash/include \
+		wear_levelling/include \
 	)
diff --git a/components/fatfs/test_fatfs_host/partition_table.csv b/components/fatfs/test_fatfs_host/partition_table.csv
index cb7fccd87..9b4dbd1ba 100644
--- a/components/fatfs/test_fatfs_host/partition_table.csv
+++ b/components/fatfs/test_fatfs_host/partition_table.csv
@@ -1,5 +1,5 @@
 # Name,   Type, SubType, Offset,  Size, Flags
-# Note: if you change the phy_init or app partition offset, make sure to change the offset in Kconfig.projbuild
+# Note: if you have increased the bootloader size, make sure to update the offsets to avoid overlap
 nvs,      data, nvs,     0x9000,  0x6000,
 phy_init, data, phy,     0xf000,  0x1000,
 factory,  app,  factory, 0x10000, 1M,
diff --git a/components/fatfs/test_fatfs_host/sdkconfig/sdkconfig.h b/components/fatfs/test_fatfs_host/sdkconfig/sdkconfig.h
index 45ca4b706..1c08df4ae 100644
--- a/components/fatfs/test_fatfs_host/sdkconfig/sdkconfig.h
+++ b/components/fatfs/test_fatfs_host/sdkconfig/sdkconfig.h
@@ -1,6 +1,8 @@
 # pragma once
-
+#define CONFIG_IDF_TARGET_ESP32 1
 #define CONFIG_WL_SECTOR_SIZE   4096
 #define CONFIG_LOG_DEFAULT_LEVEL 3
 #define CONFIG_PARTITION_TABLE_OFFSET 0x8000
 #define CONFIG_ESPTOOLPY_FLASHSIZE "8MB"
+//currently use the legacy implementation, since the stubs for new HAL are not done yet
+#define CONFIG_SPI_FLASH_USE_LEGACY_IMPL
diff --git a/components/fatfs/test_fatfs_host/test_fatfs.cpp b/components/fatfs/test_fatfs_host/test_fatfs.cpp
index 98a4d40c7..d1f7119e6 100644
--- a/components/fatfs/test_fatfs_host/test_fatfs.cpp
+++ b/components/fatfs/test_fatfs_host/test_fatfs.cpp
@@ -4,16 +4,16 @@
 #include "ff.h"
 #include "esp_partition.h"
 #include "wear_levelling.h"
-#include "diskio.h"
+#include "diskio_impl.h"
 #include "diskio_wl.h"
 
 #include "catch.hpp"
 
-extern "C" void init_spi_flash(const char* chip_size, size_t block_size, size_t sector_size, size_t page_size, const char* partition_bin);
+extern "C" void _spi_flash_init(const char* chip_size, size_t block_size, size_t sector_size, size_t page_size, const char* partition_bin);
 
 TEST_CASE("create volume, open file, write and read back data", "[fatfs]")
 {
-    init_spi_flash(CONFIG_ESPTOOLPY_FLASHSIZE, CONFIG_WL_SECTOR_SIZE * 16, CONFIG_WL_SECTOR_SIZE, CONFIG_WL_SECTOR_SIZE, "partition_table.bin");
+    _spi_flash_init(CONFIG_ESPTOOLPY_FLASHSIZE, CONFIG_WL_SECTOR_SIZE * 16, CONFIG_WL_SECTOR_SIZE, CONFIG_WL_SECTOR_SIZE, "partition_table.bin");
 
     FRESULT fr_result;
     BYTE pdrv;
diff --git a/components/fatfs/test_fatfs_host/test_utils.c b/components/fatfs/test_fatfs_host/test_utils.c
deleted file mode 100644
index 3e4b05758..000000000
--- a/components/fatfs/test_fatfs_host/test_utils.c
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "esp_spi_flash.h"
-#include "esp_partition.h"
-
-void init_spi_flash(const char* chip_size, size_t block_size, size_t sector_size, size_t page_size, const char* partition_bin)
-{
-    spi_flash_init(chip_size, block_size, sector_size, page_size, partition_bin);
-}
diff --git a/components/fatfs/src/esp_vfs_fat.h b/components/fatfs/vfs/esp_vfs_fat.h
similarity index 75%
rename from components/fatfs/src/esp_vfs_fat.h
rename to components/fatfs/vfs/esp_vfs_fat.h
index a2a05951e..a3ffe387a 100644
--- a/components/fatfs/src/esp_vfs_fat.h
+++ b/components/fatfs/vfs/esp_vfs_fat.h
@@ -17,7 +17,6 @@
 #include "esp_err.h"
 #include "driver/gpio.h"
 #include "driver/sdmmc_types.h"
-#include "driver/sdmmc_host.h"
 #include "driver/sdspi_host.h"
 #include "ff.h"
 #include "wear_levelling.h"
@@ -51,20 +50,6 @@ extern "C" {
 esp_err_t esp_vfs_fat_register(const char* base_path, const char* fat_drive,
         size_t max_files, FATFS** out_fs);
 
-/**
- * @brief Un-register FATFS from VFS
- *
- * @note FATFS structure returned by esp_vfs_fat_register is destroyed after
- *       this call. Make sure to call f_mount function to unmount it before
- *       calling esp_vfs_fat_unregister.
- *       This function is left for compatibility and will be changed in
- *       future versions to accept base_path and replace the method below
- * @return
- *      - ESP_OK on success
- *      - ESP_ERR_INVALID_STATE if FATFS is not registered in VFS
- */
-esp_err_t esp_vfs_fat_unregister() __attribute__((deprecated));
-
 /**
  * @brief Un-register FATFS from VFS
  *
@@ -127,6 +112,9 @@ typedef esp_vfs_fat_mount_config_t esp_vfs_fat_sdmmc_mount_config_t;
  * probing SD card, locating and mounting partition, and registering FATFS in VFS,
  * with proper error checking and handling of exceptional conditions.
  *
+ * @note Use this API to mount a card through SDSPI is deprecated. Please call
+ *       `esp_vfs_fat_sdspi_mount()` instead for that case.
+ *
  * @param base_path     path where partition should be registered (e.g. "/sdcard")
  * @param host_config   Pointer to structure describing SDMMC host. When using
  *                      SDMMC peripheral, this structure can be initialized using
@@ -136,8 +124,8 @@ typedef esp_vfs_fat_mount_config_t esp_vfs_fat_sdmmc_mount_config_t;
  * @param slot_config   Pointer to structure with slot configuration.
  *                      For SDMMC peripheral, pass a pointer to sdmmc_slot_config_t
  *                      structure initialized using SDMMC_SLOT_CONFIG_DEFAULT.
- *                      For SPI peripheral, pass a pointer to sdspi_slot_config_t
- *                      structure initialized using SDSPI_SLOT_CONFIG_DEFAULT.
+ *                      (Deprecated) For SPI peripheral, pass a pointer to sdspi_slot_config_t
+ *                      structure initialized using SDSPI_SLOT_CONFIG_DEFAULT().
  * @param mount_config  pointer to structure with extra parameters for mounting FATFS
  * @param[out] out_card  if not NULL, pointer to the card information structure will be returned via this argument
  * @return
@@ -153,14 +141,70 @@ esp_err_t esp_vfs_fat_sdmmc_mount(const char* base_path,
     const esp_vfs_fat_mount_config_t* mount_config,
     sdmmc_card_t** out_card);
 
+/**
+ * @brief Convenience function to get FAT filesystem on SD card registered in VFS
+ *
+ * This is an all-in-one function which does the following:
+ * - initializes an SPI Master device based on the SPI Master driver with configuration in
+ *   slot_config, and attach it to an initialized SPI bus.
+ * - initializes SD card with configuration in host_config_input
+ * - mounts FAT partition on SD card using FATFS library, with configuration in mount_config
+ * - registers FATFS library with VFS, with prefix given by base_prefix variable
+ *
+ * This function is intended to make example code more compact.
+ * For real world applications, developers should implement the logic of
+ * probing SD card, locating and mounting partition, and registering FATFS in VFS,
+ * with proper error checking and handling of exceptional conditions.
+ *
+ * @note This function try to attach the new SD SPI device to the bus specified in host_config.
+ *       Make sure the SPI bus specified in `host_config->slot` have been initialized by
+ *       `spi_bus_initialize()` before.
+ *
+ * @param base_path     path where partition should be registered (e.g. "/sdcard")
+ * @param host_config_input Pointer to structure describing SDMMC host. This structure can be
+ *                          initialized using SDSPI_HOST_DEFAULT() macro.
+ * @param slot_config   Pointer to structure with slot configuration.
+ *                      For SPI peripheral, pass a pointer to sdspi_device_config_t
+ *                      structure initialized using SDSPI_DEVICE_CONFIG_DEFAULT().
+ * @param mount_config  pointer to structure with extra parameters for mounting FATFS
+ * @param[out] out_card If not NULL, pointer to the card information structure will be returned via
+ *                      this argument. It is suggested to hold this handle and use it to unmount the card later if
+ *                      needed. Otherwise it's not suggested to use more than one card at the same time and unmount one
+ *                      of them in your application.
+ * @return
+ *      - ESP_OK on success
+ *      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount was already called
+ *      - ESP_ERR_NO_MEM if memory can not be allocated
+ *      - ESP_FAIL if partition can not be mounted
+ *      - other error codes from SDMMC or SPI drivers, SDMMC protocol, or FATFS drivers
+ */
+esp_err_t esp_vfs_fat_sdspi_mount(const char* base_path,
+                                  const sdmmc_host_t* host_config_input,
+                                  const sdspi_device_config_t* slot_config,
+                                  const esp_vfs_fat_mount_config_t* mount_config,
+                                  sdmmc_card_t** out_card);
+
 /**
  * @brief Unmount FAT filesystem and release resources acquired using esp_vfs_fat_sdmmc_mount
  *
+ * @deprecated Use `esp_vfs_fat_sdcard_unmount()` instead.
+ *
+ * @return
+ *      - ESP_OK on success
+ *      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount hasn't been called
+ */
+esp_err_t esp_vfs_fat_sdmmc_unmount(void);
+
+/**
+ * @brief Unmount an SD card from the FAT filesystem and release resources acquired using
+ *        `esp_vfs_fat_sdmmc_mount()` or `esp_vfs_fat_sdspi_mount()`
+ *
  * @return
  *      - ESP_OK on success
+ *      - ESP_ERR_INVALID_ARG if the card argument is unregistered
  *      - ESP_ERR_INVALID_STATE if esp_vfs_fat_sdmmc_mount hasn't been called
  */
-esp_err_t esp_vfs_fat_sdmmc_unmount();
+esp_err_t esp_vfs_fat_sdcard_unmount(const char *base_path, sdmmc_card_t *card);
 
 /**
  * @brief Convenience function to initialize FAT filesystem in SPI flash and register it in VFS
diff --git a/components/fatfs/src/vfs_fat.c b/components/fatfs/vfs/vfs_fat.c
similarity index 96%
rename from components/fatfs/src/vfs_fat.c
rename to components/fatfs/vfs/vfs_fat.c
index ea74c82ee..69e0dc06a 100644
--- a/components/fatfs/src/vfs_fat.c
+++ b/components/fatfs/vfs/vfs_fat.c
@@ -22,7 +22,7 @@
 #include "esp_vfs.h"
 #include "esp_log.h"
 #include "ff.h"
-#include "diskio.h"
+#include "diskio_impl.h"
 
 typedef struct {
     char fat_drive[8];  /* FAT drive name */
@@ -68,6 +68,8 @@ static const char* TAG = "vfs_fat";
 static ssize_t vfs_fat_write(void* p, int fd, const void * data, size_t size);
 static off_t vfs_fat_lseek(void* p, int fd, off_t size, int mode);
 static ssize_t vfs_fat_read(void* ctx, int fd, void * dst, size_t size);
+static ssize_t vfs_fat_pread(void *ctx, int fd, void *dst, size_t size, off_t offset);
+static ssize_t vfs_fat_pwrite(void *ctx, int fd, const void *src, size_t size, off_t offset);
 static int vfs_fat_open(void* ctx, const char * path, int flags, int mode);
 static int vfs_fat_close(void* ctx, int fd);
 static int vfs_fat_fstat(void* ctx, int fd, struct stat * st);
@@ -102,7 +104,7 @@ static size_t find_context_index_by_path(const char* base_path)
     return FF_VOLUMES;
 }
 
-static size_t find_unused_context_index()
+static size_t find_unused_context_index(void)
 {
     for(size_t i=0; i<FF_VOLUMES; i++) {
         if (!s_fat_ctxs[i]) {
@@ -150,15 +152,17 @@ esp_err_t esp_vfs_fat_register(const char* base_path, const char* fat_drive, siz
         .utime_p = &vfs_fat_utime,
     };
     size_t ctx_size = sizeof(vfs_fat_ctx_t) + max_files * sizeof(FIL);
-    vfs_fat_ctx_t* fat_ctx = (vfs_fat_ctx_t*) ff_memcalloc(1, ctx_size);
+    vfs_fat_ctx_t* fat_ctx = (vfs_fat_ctx_t*) ff_memalloc(ctx_size);
     if (fat_ctx == NULL) {
         return ESP_ERR_NO_MEM;
     }
+    memset(fat_ctx, 0, ctx_size);
     fat_ctx->o_append = ff_memalloc(max_files * sizeof(bool));
     if (fat_ctx->o_append == NULL) {
         free(fat_ctx);
         return ESP_ERR_NO_MEM;
     }
+    memset(fat_ctx->o_append, 0, max_files * sizeof(bool));
     fat_ctx->max_files = max_files;
     strlcpy(fat_ctx->fat_drive, fat_drive, sizeof(fat_ctx->fat_drive) - 1);
     strlcpy(fat_ctx->base_path, base_path, sizeof(fat_ctx->base_path) - 1);
@@ -199,19 +203,6 @@ esp_err_t esp_vfs_fat_unregister_path(const char* base_path)
     return ESP_OK;
 }
 
-esp_err_t esp_vfs_fat_unregister()
-{
-    if (s_fat_ctx == NULL) {
-        return ESP_ERR_INVALID_STATE;
-    }
-    esp_err_t err = esp_vfs_fat_unregister_path(s_fat_ctx->base_path);
-    if (err != ESP_OK) {
-        return err;
-    }
-    s_fat_ctx = NULL;
-    return ESP_OK;
-}
-
 static int get_next_fd(vfs_fat_ctx_t* fat_ctx)
 {
     for (size_t i = 0; i < fat_ctx->max_files; ++i) {
@@ -249,9 +240,7 @@ static int fresult_to_errno(FRESULT fr)
 {
     switch(fr) {
         case FR_DISK_ERR:       return EIO;
-        case FR_INT_ERR:
-            assert(0 && "fatfs internal error");
-            return EIO;
+        case FR_INT_ERR:        return EIO;
         case FR_NOT_READY:      return ENODEV;
         case FR_NO_FILE:        return ENOENT;
         case FR_NO_PATH:        return ENOENT;
@@ -512,8 +501,8 @@ static int vfs_fat_link(void* ctx, const char* n1, const char* n2)
     prepend_drive_to_path(fat_ctx, &n1, &n2);
     const size_t copy_buf_size = fat_ctx->fs.csize;
     FRESULT res;
-    FIL* pf1 = ff_memcalloc(1, sizeof(FIL));
-    FIL* pf2 = ff_memcalloc(1, sizeof(FIL));
+    FIL* pf1 = (FIL*) ff_memalloc(sizeof(FIL));
+    FIL* pf2 = (FIL*) ff_memalloc(sizeof(FIL));
     void* buf = ff_memalloc(copy_buf_size);
     if (buf == NULL || pf1 == NULL || pf2 == NULL) {
         _lock_release(&fat_ctx->lock);
@@ -524,6 +513,8 @@ static int vfs_fat_link(void* ctx, const char* n1, const char* n2)
         errno = ENOMEM;
         return -1;
     }
+    memset(pf1, 0, sizeof(*pf1));
+    memset(pf2, 0, sizeof(*pf2));
     res = f_open(pf1, n1, FA_READ | FA_OPEN_EXISTING);
     if (res != FR_OK) {
         _lock_release(&fat_ctx->lock);
@@ -591,12 +582,14 @@ static DIR* vfs_fat_opendir(void* ctx, const char* name)
     vfs_fat_ctx_t* fat_ctx = (vfs_fat_ctx_t*) ctx;
     _lock_acquire(&fat_ctx->lock);
     prepend_drive_to_path(fat_ctx, &name, NULL);
-    vfs_fat_dir_t* fat_dir = ff_memcalloc(1, sizeof(vfs_fat_dir_t));
+    vfs_fat_dir_t* fat_dir = ff_memalloc(sizeof(vfs_fat_dir_t));
     if (!fat_dir) {
         _lock_release(&fat_ctx->lock);
         errno = ENOMEM;
         return NULL;
     }
+    memset(fat_dir, 0, sizeof(*fat_dir));
+
     FRESULT res = f_opendir(&fat_dir->ffdir, name);
     _lock_release(&fat_ctx->lock);
     if (res != FR_OK) {
@@ -766,7 +759,7 @@ static int vfs_fat_truncate(void* ctx, const char *path, off_t length)
     _lock_acquire(&fat_ctx->lock);
     prepend_drive_to_path(fat_ctx, &path, NULL);
 
-    file = (FIL*) ff_memcalloc(1, sizeof(FIL));
+    file = (FIL*) ff_memalloc(sizeof(FIL));
     if (file == NULL) {
         _lock_release(&fat_ctx->lock);
         ESP_LOGD(TAG, "truncate alloc failed");
@@ -774,6 +767,7 @@ static int vfs_fat_truncate(void* ctx, const char *path, off_t length)
         ret = -1;
         goto out;
     }
+    memset(file, 0, sizeof(*file));
 
     res = f_open(file, path, FA_WRITE);
 
diff --git a/components/fatfs/src/vfs_fat_internal.h b/components/fatfs/vfs/vfs_fat_internal.h
similarity index 100%
rename from components/fatfs/src/vfs_fat_internal.h
rename to components/fatfs/vfs/vfs_fat_internal.h
diff --git a/components/fatfs/vfs/vfs_fat_sdmmc.c b/components/fatfs/vfs/vfs_fat_sdmmc.c
new file mode 100644
index 000000000..7764b58dc
--- /dev/null
+++ b/components/fatfs/vfs/vfs_fat_sdmmc.c
@@ -0,0 +1,399 @@
+// Copyright 2015-2016 Espressif Systems (Shanghai) PTE LTD
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+#include <stdlib.h>
+#include <string.h>
+#include "esp_log.h"
+#include "esp_vfs.h"
+#include "esp_vfs_fat.h"
+#include "vfs_fat_internal.h"
+#include "driver/sdspi_host.h"
+#include "sdmmc_cmd.h"
+#include "diskio_impl.h"
+#include "diskio_sdmmc.h"
+#include "driver/sdmmc_defs.h"
+
+#ifdef SOC_SDMMC_HOST_SUPPORTED
+#include "driver/sdmmc_host.h"
+#endif
+
+static const char* TAG = "vfs_fat_sdmmc";
+static sdmmc_card_t* s_card = NULL;
+static uint8_t s_pdrv = FF_DRV_NOT_USED;
+static char * s_base_path = NULL;
+
+#define CHECK_EXECUTE_RESULT(err, str) do { \
+    if ((err) !=ESP_OK) { \
+        ESP_LOGE(TAG, str" (0x%x).", err); \
+        goto cleanup; \
+    } \
+    } while(0)
+
+static void call_host_deinit(const sdmmc_host_t *host_config);
+static esp_err_t partition_card(const esp_vfs_fat_mount_config_t *mount_config,
+                                const char *drv, sdmmc_card_t *card, BYTE pdrv);
+
+static esp_err_t mount_prepare_mem(const char *base_path,
+        BYTE *out_pdrv,
+        char **out_dup_path,
+        sdmmc_card_t** out_card)
+{
+    esp_err_t err = ESP_OK;
+    char* dup_path = NULL;
+    sdmmc_card_t* card = NULL;
+
+    // connect SDMMC driver to FATFS
+    BYTE pdrv = FF_DRV_NOT_USED;
+    if (ff_diskio_get_drive(&pdrv) != ESP_OK || pdrv == FF_DRV_NOT_USED) {
+        ESP_LOGD(TAG, "the maximum count of volumes is already mounted");
+        return ESP_ERR_NO_MEM;
+
+    }
+
+    // not using ff_memalloc here, as allocation in internal RAM is preferred
+    card = (sdmmc_card_t*)malloc(sizeof(sdmmc_card_t));
+    if (card == NULL) {
+        ESP_LOGD(TAG, "could not locate new sdmmc_card_t");
+        err = ESP_ERR_NO_MEM;
+        goto cleanup;
+    }
+
+    dup_path = strdup(base_path);
+    if(!dup_path){
+        ESP_LOGD(TAG, "could not copy base_path");
+        err = ESP_ERR_NO_MEM;
+        goto cleanup;
+    }
+
+    *out_card = card;
+    *out_pdrv = pdrv;
+    *out_dup_path = dup_path;
+    return ESP_OK;
+cleanup:
+    free(card);
+    free(dup_path);
+    return err;
+}
+
+static esp_err_t mount_to_vfs_fat(const esp_vfs_fat_mount_config_t *mount_config, sdmmc_card_t *card, uint8_t pdrv,
+                                  const char *base_path)
+{
+    FATFS* fs = NULL;
+    esp_err_t err;
+    ff_diskio_register_sdmmc(pdrv, card);
+    ESP_LOGD(TAG, "using pdrv=%i", pdrv);
+    char drv[3] = {(char)('0' + pdrv), ':', 0};
+
+    // connect FATFS to VFS
+    err = esp_vfs_fat_register(base_path, drv, mount_config->max_files, &fs);
+    if (err == ESP_ERR_INVALID_STATE) {
+        // it's okay, already registered with VFS
+    } else if (err != ESP_OK) {
+        ESP_LOGD(TAG, "esp_vfs_fat_register failed 0x(%x)", err);
+        goto fail;
+    }
+
+    // Try to mount partition
+    FRESULT res = f_mount(fs, drv, 1);
+    if (res != FR_OK) {
+        err = ESP_FAIL;
+        ESP_LOGW(TAG, "failed to mount card (%d)", res);
+        if (!((res == FR_NO_FILESYSTEM || res == FR_INT_ERR)
+              && mount_config->format_if_mount_failed)) {
+            goto fail;
+        }
+
+        err = partition_card(mount_config, drv, card, pdrv);
+        if (err != ESP_OK) {
+            goto fail;
+        }
+
+        ESP_LOGW(TAG, "mounting again");
+        res = f_mount(fs, drv, 0);
+        if (res != FR_OK) {
+            err = ESP_FAIL;
+            ESP_LOGD(TAG, "f_mount failed after formatting (%d)", res);
+            goto fail;
+        }
+    }
+    return ESP_OK;
+
+fail:
+    if (fs) {
+        f_mount(NULL, drv, 0);
+    }
+    esp_vfs_fat_unregister_path(base_path);
+    ff_diskio_unregister(pdrv);
+    return err;
+}
+
+static esp_err_t partition_card(const esp_vfs_fat_mount_config_t *mount_config,
+                                const char *drv, sdmmc_card_t *card, BYTE pdrv)
+{
+    FRESULT res = FR_OK;
+    esp_err_t err;
+    const size_t workbuf_size = 4096;
+    void* workbuf = NULL;
+    ESP_LOGW(TAG, "partitioning card");
+
+    workbuf = ff_memalloc(workbuf_size);
+    if (workbuf == NULL) {
+        return ESP_ERR_NO_MEM;
+    }
+
+    DWORD plist[] = {100, 0, 0, 0};
+    res = f_fdisk(pdrv, plist, workbuf);
+    if (res != FR_OK) {
+        err = ESP_FAIL;
+        ESP_LOGD(TAG, "f_fdisk failed (%d)", res);
+        goto fail;
+    }
+    size_t alloc_unit_size = esp_vfs_fat_get_allocation_unit_size(
+                card->csd.sector_size,
+                mount_config->allocation_unit_size);
+    ESP_LOGW(TAG, "formatting card, allocation unit size=%d", alloc_unit_size);
+    res = f_mkfs(drv, FM_ANY, alloc_unit_size, workbuf, workbuf_size);
+    if (res != FR_OK) {
+        err = ESP_FAIL;
+        ESP_LOGD(TAG, "f_mkfs failed (%d)", res);
+        goto fail;
+    }
+
+    free(workbuf);
+    return ESP_OK;
+fail:
+    free(workbuf);
+    return err;
+}
+
+#if SOC_SDMMC_HOST_SUPPORTED
+static esp_err_t init_sdmmc_host(int slot, const void *slot_config, int *out_slot)
+{
+    *out_slot = slot;
+    return sdmmc_host_init_slot(slot, (const sdmmc_slot_config_t*) slot_config);
+}
+
+static esp_err_t init_sdspi_host_deprecated(int slot, const void *slot_config, int *out_slot)
+{
+    *out_slot = slot;
+    return sdspi_host_init_slot(slot, (const sdspi_slot_config_t*) slot_config);
+}
+
+esp_err_t esp_vfs_fat_sdmmc_mount(const char* base_path,
+                                  const sdmmc_host_t* host_config,
+                                  const void* slot_config,
+                                  const esp_vfs_fat_mount_config_t* mount_config,
+                                  sdmmc_card_t** out_card)
+{
+    esp_err_t err;
+    int card_handle = -1;   //uninitialized
+    sdmmc_card_t* card = NULL;
+    BYTE pdrv = FF_DRV_NOT_USED;
+    char* dup_path = NULL;
+    bool host_inited = false;
+
+    err = mount_prepare_mem(base_path, &pdrv, &dup_path, &card);
+    if (err != ESP_OK) {
+        ESP_LOGE(TAG, "mount_prepare failed");
+        return err;
+    }
+
+    if (host_config->flags == SDMMC_HOST_FLAG_SPI) {
+        //Deprecated API
+        //the init() function is usually empty, doesn't require any deinit to revert it
+        err = (*host_config->init)();
+        CHECK_EXECUTE_RESULT(err, "host init failed");
+        err = init_sdspi_host_deprecated(host_config->slot, slot_config, &card_handle);
+        CHECK_EXECUTE_RESULT(err, "slot init failed");
+        //Set `host_inited` to true to indicate that host_config->deinit() needs
+        //to be called to revert `init_sdspi_host_deprecated`; set `card_handle`
+        //to -1 to indicate that no other deinit is required.
+        host_inited = true;
+        card_handle = -1;
+    } else {
+        err = (*host_config->init)();
+        CHECK_EXECUTE_RESULT(err, "host init failed");
+        //deinit() needs to be called to revert the init
+        host_inited = true;
+        //If this failed (indicated by card_handle != -1), slot deinit needs to called()
+        //leave card_handle as is to indicate that (though slot deinit not implemented yet.
+        err = init_sdmmc_host(host_config->slot, slot_config, &card_handle);
+        CHECK_EXECUTE_RESULT(err, "slot init failed");
+    }
+
+    // probe and initialize card
+    err = sdmmc_card_init(host_config, card);
+    CHECK_EXECUTE_RESULT(err, "sdmmc_card_init failed");
+
+    err = mount_to_vfs_fat(mount_config, card, pdrv, dup_path);
+    CHECK_EXECUTE_RESULT(err, "mount_to_vfs failed");
+
+    if (out_card != NULL) {
+        *out_card = card;
+    }
+    if (s_card == NULL) {
+        //store the ctx locally to be back-compatible
+        s_card = card;
+        s_pdrv = pdrv;
+        s_base_path = dup_path;
+    } else {
+        free(dup_path);
+    }
+    return ESP_OK;
+cleanup:
+    if (host_inited) {
+        call_host_deinit(host_config);
+    }
+    free(card);
+    free(dup_path);
+    return err;
+}
+#endif
+
+static esp_err_t init_sdspi_host(int slot, const void *slot_config, int *out_slot)
+{
+    esp_err_t err = sdspi_host_init_device((const sdspi_device_config_t*)slot_config, out_slot);
+    if (err != ESP_OK) {
+        ESP_LOGE(TAG,
+"Failed to attach sdspi device onto an SPI bus (rc=0x%x), please initialize the \
+bus first and check the device parameters."
+            , err);
+    }
+    return err;
+}
+
+esp_err_t esp_vfs_fat_sdspi_mount(const char* base_path,
+                                  const sdmmc_host_t* host_config_input,
+                                  const sdspi_device_config_t* slot_config,
+                                  const esp_vfs_fat_mount_config_t* mount_config,
+                                  sdmmc_card_t** out_card)
+{
+    const sdmmc_host_t* host_config = host_config_input;
+    esp_err_t err;
+    int card_handle = -1;   //uninitialized
+    bool host_inited = false;
+    BYTE pdrv = FF_DRV_NOT_USED;
+    sdmmc_card_t* card = NULL;
+    char* dup_path = NULL;
+
+    err = mount_prepare_mem(base_path, &pdrv, &dup_path, &card);
+    if (err != ESP_OK) {
+        ESP_LOGE(TAG, "mount_prepare failed");
+        return err;
+    }
+
+    //the init() function is usually empty, doesn't require any deinit to revert it
+    err = (*host_config->init)();
+    CHECK_EXECUTE_RESULT(err, "host init failed");
+
+    err = init_sdspi_host(host_config->slot, slot_config, &card_handle);
+    CHECK_EXECUTE_RESULT(err, "slot init failed");
+    //Set `host_inited` to true to indicate that host_config->deinit() needs
+    //to be called to revert `init_sdspi_host`
+    host_inited = true;
+
+    /*
+     * The `slot` argument inside host_config should be replaced by the SD SPI handled returned
+     * above. But the input pointer is const, so create a new variable.
+     */
+    sdmmc_host_t new_config;
+    if (card_handle != host_config->slot) {
+        new_config = *host_config_input;
+        host_config = &new_config;
+        new_config.slot = card_handle;
+    }
+
+    // probe and initialize card
+    err = sdmmc_card_init(host_config, card);
+    CHECK_EXECUTE_RESULT(err, "sdmmc_card_init failed");
+
+    err = mount_to_vfs_fat(mount_config, card, pdrv, dup_path);
+    CHECK_EXECUTE_RESULT(err, "mount_to_vfs failed");
+
+    if (out_card != NULL) {
+        *out_card = card;
+    }
+    if (s_card == NULL) {
+        //store the ctx locally to be back-compatible
+        s_card = card;
+        s_pdrv = pdrv;
+        s_base_path = dup_path;
+    } else {
+        free(dup_path);
+    }
+    return ESP_OK;
+
+cleanup:
+    if (host_inited) {
+        call_host_deinit(host_config);
+    }
+    free(card);
+    free(dup_path);
+    return err;
+
+}
+
+static void local_card_remove(void)
+{
+    s_card = NULL;
+    free(s_base_path);
+    s_base_path = NULL;
+    s_pdrv = FF_DRV_NOT_USED;
+}
+
+static void call_host_deinit(const sdmmc_host_t *host_config)
+{
+    if (host_config->flags & SDMMC_HOST_FLAG_DEINIT_ARG) {
+        host_config->deinit_p(host_config->slot);
+    } else {
+        host_config->deinit();
+    }
+}
+
+static esp_err_t unmount_card_core(const char *base_path, sdmmc_card_t *card)
+{
+    BYTE pdrv = ff_diskio_get_pdrv_card(card);
+    if (pdrv == 0xff) {
+        return ESP_ERR_INVALID_ARG;
+    }
+
+    // unmount
+    char drv[3] = {(char)('0' + pdrv), ':', 0};
+    f_mount(0, drv, 0);
+    // release SD driver
+    ff_diskio_unregister(pdrv);
+
+    call_host_deinit(&card->host);
+    free(card);
+
+    esp_err_t err = esp_vfs_fat_unregister_path(base_path);
+    return err;
+}
+
+esp_err_t esp_vfs_fat_sdmmc_unmount(void)
+{
+    sdmmc_card_t* card = s_card;
+    esp_err_t err = unmount_card_core(s_base_path, card);
+    local_card_remove();
+    return err;
+}
+
+esp_err_t esp_vfs_fat_sdcard_unmount(const char *base_path, sdmmc_card_t *card)
+{
+    esp_err_t err = unmount_card_core(base_path, card);
+    if (s_card == card) {
+        local_card_remove();
+    }
+    return err;
+}
diff --git a/components/fatfs/src/vfs_fat_spiflash.c b/components/fatfs/vfs/vfs_fat_spiflash.c
similarity index 97%
rename from components/fatfs/src/vfs_fat_spiflash.c
rename to components/fatfs/vfs/vfs_fat_spiflash.c
index 9fbe95381..3110d2e2d 100644
--- a/components/fatfs/src/vfs_fat_spiflash.c
+++ b/components/fatfs/vfs/vfs_fat_spiflash.c
@@ -18,7 +18,7 @@
 #include "esp_vfs.h"
 #include "esp_vfs_fat.h"
 #include "vfs_fat_internal.h"
-#include "diskio.h"
+#include "diskio_impl.h"
 
 #include "diskio_rawflash.h"
 
@@ -76,7 +76,8 @@ esp_err_t esp_vfs_fat_spiflash_mount(const char* base_path,
     FRESULT fresult = f_mount(fs, drv, 1);
     if (fresult != FR_OK) {
         ESP_LOGW(TAG, "f_mount failed (%d)", fresult);
-        if (!(fresult == FR_NO_FILESYSTEM && mount_config->format_if_mount_failed)) {
+        if (!((fresult == FR_NO_FILESYSTEM || fresult == FR_INT_ERR)
+              && mount_config->format_if_mount_failed)) {
             result = ESP_FAIL;
             goto fail;
         }
diff --git a/components/soc/esp32/include/soc/spi_pins.h b/components/soc/esp32/include/soc/spi_pins.h
index eb7af8582..13a658677 100644
--- a/components/soc/esp32/include/soc/spi_pins.h
+++ b/components/soc/esp32/include/soc/spi_pins.h
@@ -15,6 +15,8 @@
 #ifndef _SOC_SPI_PINS_H_
 #define _SOC_SPI_PINS_H_
 
+#define SOC_SPI_PERIPH_NUM      3
+
 #define SPI_IOMUX_PIN_NUM_MISO  7
 #define SPI_IOMUX_PIN_NUM_MOSI  8
 #define SPI_IOMUX_PIN_NUM_CLK   6
